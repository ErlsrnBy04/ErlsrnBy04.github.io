<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[C++]C++并发编程实战Chapter7</title>
    <link href="/2025/02/22/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter7/"/>
    <url>/2025/02/22/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter7/</url>
    
    <content type="html"><![CDATA[<h1 id="7-设计无锁数据结构"><a href="#7-设计无锁数据结构" class="headerlink" title="7 设计无锁数据结构"></a>7 设计无锁数据结构</h1><h2 id="定义和推论"><a href="#定义和推论" class="headerlink" title="定义和推论"></a>定义和推论</h2><p>算法和数据结构中只要采用了互斥、条件变量或future进行同步操作，就称之为阻塞型算法和阻塞型数据结构。操作系统往往会把被阻塞的线程彻底暂停，并将其时间片分配给其他线程，等到有线程执行了恰当的操作，阻塞方被解除。</p><h3 id="非阻塞型数据结构"><a href="#非阻塞型数据结构" class="headerlink" title="非阻塞型数据结构"></a>非阻塞型数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">spinlock_mutex</span><br>&#123;<br>    std::atomic_flag flag;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">spinlock_mutex</span>():<br>        <span class="hljs-built_in">flag</span>(ATOMIC_FLAG_INIT)<br>    &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(flag.<span class="hljs-built_in">test_and_set</span>(std::memory_order_acquire));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        flag.<span class="hljs-built_in">clear</span>(std::memory_order_release);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>之前实现的自旋锁虽然不存在阻塞调用，但是仍然存在互斥，任何时刻只有一个线程能够锁定。因此，只分析非阻塞&#x2F;阻塞，无法判断其适用性，需要根据一下条款进行进一步判断：</p><ul><li>无阻碍（obstruction-free）：假定其他线程全都暂停，则目标线程将在有限步骤内完成自己的操作。</li><li>无锁（lock-free）：如果多个线程共同操作同一份数据，那么在有限步骤内，其中某一线程能够完成自己的操作。</li><li>免等（wait-free）：在某份数据上，每个线程经过有限步骤就能完成自己的操作，即便该份数据同时被其他多个线程所操作。</li></ul><h3 id="无锁数据结构"><a href="#无锁数据结构" class="headerlink" title="无锁数据结构"></a>无锁数据结构</h3>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++并发编程实战Chapter5</title>
    <link href="/2025/02/17/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter5/"/>
    <url>/2025/02/17/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter5/</url>
    
    <content type="html"><![CDATA[<h1 id="5-C-内存模型和原子操作"><a href="#5-C-内存模型和原子操作" class="headerlink" title="5 C++内存模型和原子操作"></a>5 C++内存模型和原子操作</h1><h2 id="内存模型基础"><a href="#内存模型基础" class="headerlink" title="内存模型基础"></a>内存模型基础</h2><h3 id="对象、内存区域和并发"><a href="#对象、内存区域和并发" class="headerlink" title="对象、内存区域和并发"></a>对象、内存区域和并发</h3><p>所有与多线程相关的事项都会牵涉内存区域。如果两个线程各自访问分离的内存区域，则相安无事，一切运作良好；反之，如果两个线程访问同一内存区域，我们就要警惕了。假使没有线程更新内存区域，则不必在意，只读数据无须保护或同步。</p><p>任一线程改动数据都可能引发条件竞争。要避免条件竞争，就必须强制两个线程按一定的次序访问。</p><ul><li>可以用互斥来保证这种次序。</li><li>利用原子操作的同步性质，强制两个线程遵循一定的访问次序。</li></ul><h3 id="改动序列"><a href="#改动序列" class="headerlink" title="改动序列"></a>改动序列</h3><p>在一个C++程序中，每个对象都具有一个改动序列[1]，它由所有线程在对象上的全部写操作构成，其中第一个写操作即为对象的初始化。大部分情况下，这个序列会随程序的多次运行而发生变化，但是在程序的任意一次运行过程中，所含的全部线程都必须形成相同的改动序列。</p><p>改动序列的要求：</p><ul><li>只要某线程看到过某个对象，则该线程的后续读操作必须获得相对新近的值</li><li>该线程就同一对象的后续写操作，必然出现在改动序列后方</li><li>如果某线程先向一个对象写数据，过后再读取它，那么必须读取前面写的值。</li><li>若在改动序列中，上述读写操作之间还有别的写操作，则必须读取最后写的值。</li><li>在程序内部，对于同一个对象，全部线程都必须就其形成相同的改动序列，并且在所有对象上都要求如此，而多个对象上的改动序列只是相对关系，线程之间不必达成一致。</li></ul><h2 id="C-中的原子操作及其类别"><a href="#C-中的原子操作及其类别" class="headerlink" title="C++中的原子操作及其类别"></a>C++中的原子操作及其类别</h2><p>原子操作是不可分割的操作（indivisible operation）。该操作要么完全做好，要么完全没做。</p><h3 id="标准原子类型"><a href="#标准原子类型" class="headerlink" title="标准原子类型"></a>标准原子类型</h3><p>标准原子类型的定义位于头文件 <code>&lt;atomic&gt;</code> 内。这些类型的操作全是原子化的，并且，根据语言的定义，C++内建的原子操作也仅仅支持这些类型。</p><p>标准的原子类型几乎都具备成员函数 <code>is_lock_free()</code> ,(只有 <code>std::atomic_flag</code> 不具备该成员函数，它一定采用无锁操作)准许使用者判定某一给定类型上的操作是能由原子指令直接实现，还是要借助编译器和程序库的内部锁来实现。</p><p>从C++17开始，全部原子类型都含有一个静态常量表达式成员变量，形如<code>X::is_always_lock_free</code> ，考察编译生成的一个特定版本的程序，当且仅当在所有支持该程序运行的硬件上，原子类型X全都以无锁结构形式实现，该成员变量的值才为true。</p><p>对于原子类型上的每一种操作，我们都可以提供额外的参数，从枚举类<code>std::memory_order</code> 取值，用于设定所需的内存次序语义。具有6个可能的值，包括 <code>std::memory_order_relaxed</code> 、<code>std::memory_order_acquire</code> 、<code>std::memory_order_consume</code> 、<code>std::memory_order_acq_rel</code> 、<code>std:: memory_order_release</code> 和 <code>std::memory_order_seq_cst</code>。默认内存次序是最严格的 <code>std::memory_order_seq_cst</code></p><p>操作的类别决定了内存次序所准许的取值：</p><ul><li>存储（store）操作，可选用的内存次序有 <code>std::memory_order_relaxed</code>、<code>std::memory_order_release</code> 或<code>std::memory_order_seq_cst</code>。</li><li>载入（load）操作，可选用的内存次序有 <code>std::memory_order_relaxed</code>、<code>std::memory_order_consume</code> 、<code>std::memory_order_acquire</code> 或<code>std::memory_order_seq_cst</code>。</li><li>“读-改-写”（read-modify-write）操作，可选用的内存次序有<code>std::memory_order_relaxed</code> 、<code>std::memory_order_acquire</code> 、<code>std::memory_order_consume</code> 、<code>std::memory_order_acq_rel</code> 、<code>std:: memory_order_release</code> 和 <code>std::memory_order_seq_cst</code></li></ul><h3 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a><code>std::atomic_flag</code></h3><p><code>std::atomic_flag</code> 是最简单的标准原子类型，表示一个布尔标志。该类型的对象只有两种状态：成立或置零。<code>std::atomic_flag</code> 类型的对象必须由宏<code>ATOMIC_FLAG_INIT</code> 初始化，它把标志初始化为置零状态。</p><p>完成初始化后，我们只能执行3种操作：销毁、置零、读取原有的值并设置标志成立。这分别对应于析构函数、成员函数 <code>clear()</code> 、成员函数 <code>test_and_set()</code>。</p><p>我们可以采用 <code>std::atomic_flag</code> 来实现自旋锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpinLock</span>() : <span class="hljs-built_in">flag</span>(ATOMIC_FLAG_INIT) <br>    &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(flag.<span class="hljs-built_in">test_and_set</span>());<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        flag.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    std::atomic_flag flag;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="std-atomic"><a href="#std-atomic" class="headerlink" title="std::atomic&lt;bool&gt;"></a><code>std::atomic&lt;bool&gt;</code></h3><p><code>std::atomic&lt;bool&gt;</code> 是基于整数的最基本的原子类型。尽管也无法拷贝构造或拷贝赋值，但我们还是能依据非原子布尔量创建其对象，初始值是true或false皆可。该类型的实例还能接受非原子布尔量的赋值。</p><p>需要注意，与惯例不同，原子类型的赋值操作符不返回引用，而是按值返回（该值属于对应的非原子类型，返回的是赋予的值）。</p><p><code>std::atomic&lt;bool&gt;</code> 通过 <code>store()</code> 操作进行写作操，通过 <code>exchange()</code> 操作代替 <code>test_and_set()</code> 操作，获取原有的值，自行选定新值作为替换。</p><p>支持单纯的读取：隐式做法是将实例转换为普通布尔值，显示做法是调用 <code>load()</code>.</p><p>还引入了一种操作：若原子对象当前的值符合预期，就赋予新值。它与<code>exchange()</code> 一样，同为“读-改-写”操作。</p><p>这一新操作被称为“比较-交换”（compare-exchange），实现形式是成员函数<code>compare_exchange_weak()</code> 和 <code>compare_exchange_strong()</code>。使用者给定一个期望值，原子变量将它和自身的值比较，如果相等，就存入另一既定的值；否则，更新期望值所属的变量，向它赋予原子变量的值。比较-交换函数返回布尔类型，如果完成了保存动作（前提是两值相等），则操作成功，函数返回 <code>ture</code>；反之操作失败，函数返回 <code>false</code>。</p><p>对于 <code>compare_exchange_weak()</code>，即使原子变量的值等于期望值，保存动作还是有可能失败，在这种情形下，原子变量维持原值不变，返回false。原子化的比较-交换必须由一条指令单独完成，而某些处理器没有这种指令，无从保证该操作按原子化方式完成。要实现比较-交换，负责的线程则须改为连续运行一系列指令，但在这些计算机上，只要出现线程数量多于处理器数量的情形，线程就有可能执行到中途因系统调度而切出，导致操作失败。这种计算机最有可能引发上述的保存失败，我们称之为佯败（spurious failure）。其败因不是变量值本身存在问题，而是函数执行时机不对。因为 <code>compare_exchange_weak</code>() 可能佯败，所以它往往必须配合循环使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> expected=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">extern</span> atomic&lt;<span class="hljs-type">bool</span>&gt; b; <span class="hljs-comment">//由其他源文件的代码设定变量的值</span><br><span class="hljs-keyword">while</span>(!b.<span class="hljs-built_in">compare_exchange_weak</span>(expected,<span class="hljs-literal">true</span>) &amp;&amp; !expected);<br></code></pre></td></tr></table></figure><p><strong>weak和strong版本的区别</strong></p><ul><li>weak版本可能会发生佯败，即虽然变量值和预期值相等，但是由于执行时机问题，导致返回false</li><li>strong版本只有和预期值不一样的时候才会返回false。</li></ul><p>strong版本自身内部含有一个循环，性能较差，对于某些经过简单计算就能得出的保存值，用weak版本性能更好，对于需要耗时才能得出的值，用strong版本可以避免重复计算。</p><h3 id="std-atomic-1"><a href="#std-atomic-1" class="headerlink" title="std::atomic&lt;T*&gt;"></a><code>std::atomic&lt;T*&gt;</code></h3><p>接口、特性都类似 <code>std::atomic&lt;bool&gt;</code> 。提供的新操作是算术形式的指针运算。成员函数 <code>fetch_add()</code> 和 <code>fetch_sub()</code> 给出了最基本的操作，分别就对象中存储的地址进行原子化加减，返回原来的地址。另外，该原子类型还具有包装成重载运算符的+&#x3D;和−&#x3D;，以及++和−−的前后缀版本，用起来十分方便。</p><h3 id="标准整数原子类型"><a href="#标准整数原子类型" class="headerlink" title="标准整数原子类型"></a>标准整数原子类型</h3><p>在 <code>std::atomic&lt;int&gt;</code> 和 <code>std::atomic&lt;unsigned long long&gt;</code> 这样的整数原子类型上，我们可以执行的操作颇为齐全：既包括常用的原子操作（load()、store()、exchange()、compare_exchange_weak()和compare_exchange_strong()），也包括原子运算（fetch_add()、fetch_sub()、fetch_and()、fetch_or()、fetch_xor()），以及这些运算的复合赋值形式（+&#x3D;、−&#x3D;、&amp;&#x3D;、|&#x3D;和^&#x3D;），还有前后缀形式的自增和自减（++x、x++、−−x和x−−）。</p><h3 id="泛化的-std-atomic-类模板"><a href="#泛化的-std-atomic-类模板" class="headerlink" title="泛化的 std::atomic&lt;&gt; 类模板"></a>泛化的 <code>std::atomic&lt;&gt;</code> 类模板</h3><p>对于某个自定义类型UDT，要满足一定条件才能具现化出 <code>std::atomic&lt;UDT&gt;</code> ：</p><ul><li>必须具备平实拷贝赋值操作符（trivial copy-assignment operator）</li><li>它不得含有任何虚函数，也不可以从虚基类派生得出</li><li>必须由编译器代其隐式生成拷贝赋值操作符；</li><li>若自定义类型具有基类或非静态数据成员，则它们同样必须具备平实拷贝赋值操作符。</li></ul><p>值得注意的是，比较-交换操作所采用的是逐位比较运算，效果等同于直接使用<code>memcmp()</code> 函数。即使UDT自行定义了比较运算符，在这项操作中也会被忽略。若自定义类型含有填充位（padding bit），却不参与普通比较操作，那么即使UDT对象的值相等，比较-交换操作还是会失败。</p><p>类型 <code>std::atomic&lt;T&gt;</code> 的接口与 <code>std::atomic&lt;bool&gt;</code> 相似，可用的操作有限，包括 <code>load()</code>、<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code> 和<code>compare_exchange_strong()</code>，以及接受类型T的实例的赋值、转换成类型T的实例。</p><h3 id="原子操作的非成员函数"><a href="#原子操作的非成员函数" class="headerlink" title="原子操作的非成员函数"></a>原子操作的非成员函数</h3><p>目前为止，我们介绍了不少原子操作，但仅限于原子类型成员函数的形式。不过，还有众多非成员函数，与各原子类型上的所有操作逐一等价。大部分非成员函数依据对应的成员函数命名，只不过冠以前缀“ <code>atomic_</code> ”（如<code>std::atomic_load()</code>），它们还针对各原子类型进行了重载。只要有可能指定内存次序，这些函数就衍化出两个变体：一个带有后缀“<code>_explicit</code>”，接收更多参数以指定内存次序，而另一个则不带后缀也不接收内存次序参数，如<code>std::atomic_store_explicit(&amp;atomic_var,new_value,std::memory_order_release)</code>与 <code>std::atomic_store(&amp;atomic_var,new_value)</code>。成员函数的调用会隐式地操作原子对象，但所有非成员函数的第一个参数都是指针，指向所要操作的目标原子对象。</p><p>C++标准库还提供了非成员函数，按原子化形式访问 <code>std::shared_ptr&lt;&gt;</code> 的实例。标准库给出了共享指针的原子操作（载入、存储、交换和比较-交换），它们与标准原子类型上的操作一样，都是对应的同名函数的重载，而且第一个参数都属于 <code>std:shared_ptr&lt;&gt;*</code> 类型。</p><h3 id="原子操作的内存顺序"><a href="#原子操作的内存顺序" class="headerlink" title="原子操作的内存顺序"></a>原子操作的内存顺序</h3><p>原子类型上的操作服从 6 种内存次序：memory_order_relaxed、memory_order_consume、memory_order_acquire、memory_order_release、memory_order_acq_rel和memory_order_seq_cst。其中，memory_order_seq_cst是可选的最严格的内存次序，各种原子类型的所有操作都默认遵从该次序。</p><p>虽然内存次序共有6种，但它们只代表3种模式：</p><ul><li>先后一致次序（memory_order_seq_cst）</li><li>获取-释放次序（memory_order_consume、memory_order_acquire、memory_order_release和memory_order_acq_rel）</li><li>宽松次序（memory_order_relaxed）</li></ul><h4 id="先后一致次序"><a href="#先后一致次序" class="headerlink" title="先后一致次序"></a>先后一致次序</h4>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[PRO]内存池</title>
    <link href="/2025/02/15/PRO-%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    <url>/2025/02/15/PRO-%E5%86%85%E5%AD%98%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h2><h3 id="什么是内存池"><a href="#什么是内存池" class="headerlink" title="什么是内存池"></a>什么是内存池</h3><p>内存池是一种预分配内存并进行重复利用的技术。减少动态内存的分配与释放，提升程序运行效率。本质上是申请一块较大的内存，之后在应用层对这块内存进行管理，减少系统调用的开销。</p><p><strong>优点</strong></p><ul><li>减少动态内存分配的开销</li><li>避免内存碎片</li><li>降低系统调用频率</li><li>稳定分配时间</li></ul><p><strong>缺点</strong></p><ul><li>初始内存占用较大</li><li>复杂</li><li>不适合大型对象</li></ul><p><strong>应用场景</strong></p><ul><li>高频小对象分配<ul><li>游戏开发：粒子、子弹、npc等</li><li>网络编程</li></ul></li><li>实时系统：内存池分配内存时间稳定，适合实时控制系统</li><li>高性能计算</li></ul><h2 id="2-前置知识"><a href="#2-前置知识" class="headerlink" title="2 前置知识"></a>2 前置知识</h2><h3 id="2-1-std-allocator"><a href="#2-1-std-allocator" class="headerlink" title="2.1 std::allocator"></a>2.1 <code>std::allocator</code></h3><h3 id="2-2-自旋锁"><a href="#2-2-自旋锁" class="headerlink" title="2.2 自旋锁"></a>2.2 自旋锁</h3><p>自旋锁是一种轻量级的锁机制，用于实现线程同步。他不会进入阻塞状态，而是不断尝试获取锁，避免了上下文切换的开销。</p><table><thead><tr><th>自旋锁</th><th>互斥锁</th></tr></thead><tbody><tr><td>忙等</td><td>阻塞</td></tr><tr><td>适合持锁时间很短</td><td>适合持锁时间长</td></tr><tr><td>无需上下文切换，性能高</td><td>需要上下文切换，开销大</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内存池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MySql]Mysql</title>
    <link href="/2025/01/29/MySql-Mysql/"/>
    <url>/2025/01/29/MySql-Mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><h2 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h2><p><strong>数据库</strong>：存储数据的仓库，其中数据是有组织的存储起来的。</p><p><strong>数据库管理系统</strong>：操纵和管理数据库的软件</p><p><strong>SQL</strong>：操纵关系型数据库的编程语言。</p><h2 id="1-2-MySQL数据库的安装"><a href="#1-2-MySQL数据库的安装" class="headerlink" title="1.2 MySQL数据库的安装"></a>1.2 MySQL数据库的安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a><strong>windows</strong></h3><p>直接去官网下载安装包，按照默认安装即可。</p><p><strong>启动和停止</strong></p><ul><li>windows+r 输入services.msc找到mysql80。</li><li>命令行输入<ul><li>net start mysql80</li><li>net stop mysql80</li></ul></li></ul><p><strong>客户端连接</strong></p><ul><li>mysql提供的客户端命令行工具</li><li>系统自带的命令行连接<ul><li>命令：<code>mysql [-h 127.0.0.1] [-P 3306] -u root -p</code></li><li>这种方式需要配置环境变量</li></ul></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h2 id="1-3-MySQL数据模型"><a href="#1-3-MySQL数据模型" class="headerlink" title="1.3 MySQL数据模型"></a>1.3 MySQL数据模型</h2><p><img src="/../images/MySql-Mysql/image-20250129163345252.png" alt="image-20250129163345252"></p><p>如图所示，我们的客户端通过SQL将要执行的操作发送给DBMS，然后由其帮助我们去操作、创建数据库。</p><p><strong>关系型数据库</strong>：建立在关系模型基础上，由多张相互连接的二维表组成的数据库</p><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2 SQL"></a>2 SQL</h1><h2 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h2><ul><li>可以单行或者多行书写，以分号结尾</li><li>可以使用空格&#x2F;缩进增加可读性</li><li>不区分大小写，关键字建议用大写</li><li>注释<ul><li>单行注释：<code>-- 注释内容</code>&#x2F;<code># 注释内容</code></li><li>多行注释：<code>/*注释内容*/</code></li></ul></li></ul><h2 id="2-2-SQL分类"><a href="#2-2-SQL分类" class="headerlink" title="2.2 SQL分类"></a>2.2 SQL分类</h2><p><img src="/../images/MySql-Mysql/image-20250129164541224.png" alt="image-20250129164541224"></p><h2 id="2-3-DDL"><a href="#2-3-DDL" class="headerlink" title="2.3 DDL"></a>2.3 DDL</h2><h3 id="2-3-1-数据库操作"><a href="#2-3-1-数据库操作" class="headerlink" title="2.3.1 数据库操作"></a>2.3.1 数据库操作</h3><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ul><li>查询所有数据库: <code>SHOW DATABASES;</code></li><li>查询当前数据库: <code>SELECT DATABASE();</code></li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 数据库名 [<span class="hljs-keyword">DEFAULT</span> CHARSET 字符集] [<span class="hljs-keyword">COLLATE</span> 排序规则];<br></code></pre></td></tr></table></figure><ul><li>if not exists：如果不存在则创建；存在不进行任何操作</li><li>default charset:指定字符集</li><li>collate：指定排序规则</li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE [IF <span class="hljs-keyword">EXISTS</span>] 数据库名;<br></code></pre></td></tr></table></figure><ul><li>if exists：如果存在则删除</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE 数据库名;<br></code></pre></td></tr></table></figure><h3 id="2-3-2-表操作"><a href="#2-3-2-表操作" class="headerlink" title="2.3.2 表操作"></a>2.3.2 表操作</h3><h4 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h4><ul><li>查看当前数据库所有表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES;<br></code></pre></td></tr></table></figure><p>必须先使用USE进入一个具体的数据库。</p><ul><li>查询表结构</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DESC</span> 表名;<br></code></pre></td></tr></table></figure><ul><li>查询指定表的建表语句</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段<span class="hljs-number">1</span> 字段<span class="hljs-number">1</span>类型 [COMMENT 字段<span class="hljs-number">1</span>注释],<br>...<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[COMMENT 表注释];<br></code></pre></td></tr></table></figure><p><strong>例子</strong></p><p><img src="/../images/MySql-Mysql/image-20250129170018326.png" alt="image-20250129170018326"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> tb_user(<br>id <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>    name <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age <span class="hljs-type">int</span> comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    gender <span class="hljs-type">varchar</span>(<span class="hljs-number">1</span>) comment <span class="hljs-string">&#x27;性别&#x27;</span><br>    ) comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p>用decs命令来查看表结构</p><p><img src="/../images/MySql-Mysql/image-20250129170540291.png"></p><p>用show create table命令来查看建表语句</p><p><img src="/../images/MySql-Mysql/image-20250129170724563.png" alt="image-20250129170724563"></p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>主要分为三类</p><ul><li>数值类型</li><li>字符串类型</li><li>日期时间类型</li></ul><p><strong>数值类型</strong></p><p><img src="/../images/MySql-Mysql/image-20250129171019459.png" alt="image-20250129171019459"></p><p>例子：</p><ul><li>age TINYINT UNSIGNED</li><li>score double(4,1) # 4代表整体长度，1代表小数位数</li></ul><p><strong>字符串类型</strong></p><p><img src="/../images/MySql-Mysql/image-20250129171353079.png" alt="image-20250129171353079"></p><p>char和varchar都需要指明最大长度：</p><ul><li>对于char(10):存储几个字符都占用10个空间（用空格补齐）</li><li>对于varchar(10)：存储几个字符就占用几个字符的空间</li></ul><p>char的性能高，varchar性能较差。</p><p><strong>日期时间类型</strong></p><p><img src="/../images/MySql-Mysql/image-20250129171646683.png" alt="image-20250129171646683"></p><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><ul><li>添加字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> 字段名 类型 [COMMENT 注释] [约束];<br></code></pre></td></tr></table></figure><ul><li><p>修改字段</p><ul><li>修改字段类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 MODIFY 字段名 新数据类型;<br></code></pre></td></tr></table></figure><ul><li>修改字段名和字段类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型 [COMMENT 注释] [约束]<br></code></pre></td></tr></table></figure></li><li><p>删除字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> 字段名;<br></code></pre></td></tr></table></figure></li><li><p>修改表名</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 RENAME <span class="hljs-keyword">TO</span> 新表名;<br></code></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><ul><li>删除表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> [IF <span class="hljs-keyword">EXISTS</span>] 表名;<br></code></pre></td></tr></table></figure><ul><li>删除指定表，并重新创建该表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br></code></pre></td></tr></table></figure><h2 id="2-4-DML"><a href="#2-4-DML" class="headerlink" title="2.4 DML"></a>2.4 DML</h2><p>对数据库中表的数据记录进行增删改操作。</p><ul><li>添加数据(INSERT)</li><li>修改数据(UPDATE)</li><li>删除数据(DELETE)</li></ul><h3 id="2-4-1-添加数据"><a href="#2-4-1-添加数据" class="headerlink" title="2.4.1 添加数据"></a>2.4.1 添加数据</h3><ul><li>给指定字段添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...);<br></code></pre></td></tr></table></figure><ul><li>给全部字段添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...);<br></code></pre></td></tr></table></figure><ul><li>批量添加数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名(字段名<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...),(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...),...;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 表名 <span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...),(值<span class="hljs-number">1</span>,值<span class="hljs-number">2</span>,...),...;<br></code></pre></td></tr></table></figure><h3 id="2-4-2-修改数据"><a href="#2-4-2-修改数据" class="headerlink" title="2.4.2 修改数据"></a>2.4.2 修改数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名 <span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span><span class="hljs-operator">=</span>值<span class="hljs-number">1</span>,字段名<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span>,...[ <span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><h3 id="2-4-3-删除数据"><a href="#2-4-3-删除数据" class="headerlink" title="2.4.3 删除数据"></a>2.4.3 删除数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名 [<span class="hljs-keyword">WHERE</span> 条件];<br></code></pre></td></tr></table></figure><h2 id="2-5-DQL"><a href="#2-5-DQL" class="headerlink" title="2.5 DQL"></a>2.5 DQL</h2><p>数据查询语言，用来查询数据库中表的记录。</p><p>关键字：SELECT</p><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <br>字段列表<br><span class="hljs-keyword">FROM</span> <br>表名列表<br><span class="hljs-keyword">WHERE</span><br>条件列表<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span><br>分组字段列表<br><span class="hljs-keyword">HAVING</span><br>分组后条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span><br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><h3 id="2-5-1-基本查询"><a href="#2-5-1-基本查询" class="headerlink" title="2.5.1 基本查询"></a>2.5.1 基本查询</h3><ul><li>查询多个字段</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,字段<span class="hljs-number">2</span>,... <span class="hljs-keyword">FROM</span> 表名;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ul><li>设置别名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> [<span class="hljs-keyword">AS</span> 别名<span class="hljs-number">1</span>], 字段<span class="hljs-number">2</span> [<span class="hljs-keyword">AS</span> 别名<span class="hljs-number">2</span>],... <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><ul><li>去除重复记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><h3 id="2-5-2-条件查询"><a href="#2-5-2-条件查询" class="headerlink" title="2.5.2 条件查询"></a>2.5.2 条件查询</h3><ul><li>基本语法</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件列表;<br></code></pre></td></tr></table></figure><ul><li>条件</li></ul><p><img src="/../images/MySql-Mysql/image-20250131193638225.png" alt="image-20250131193638225"></p><p><img src="/../images/MySql-Mysql/image-20250131193646484.png" alt="image-20250131193646484"></p><h3 id="2-5-3-聚合函数"><a href="#2-5-3-聚合函数" class="headerlink" title="2.5.3 聚合函数"></a>2.5.3 聚合函数</h3><p>将一列数据作为一个整体，进行纵向计算。</p><p><strong>常见聚合函数</strong></p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数(字段列表) <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>null值不参与计算。</p><h3 id="2-5-4-分组查询"><a href="#2-5-4-分组查询" class="headerlink" title="2.5.4 分组查询"></a>2.5.4 分组查询</h3><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 [<span class="hljs-keyword">WHERE</span> 条件] <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段名 [<span class="hljs-keyword">HAVING</span> 分组后过滤条件];<br></code></pre></td></tr></table></figure><p><strong>where与having区别</strong></p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p><strong>注意</strong></p><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h3 id="2-5-5-排序查询"><a href="#2-5-5-排序查询" class="headerlink" title="2.5.5 排序查询"></a>2.5.5 排序查询</h3><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> 排序方式<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> 排序方式<span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><strong>排序方式</strong></p><ul><li>ASC：升序（默认值）</li><li>DESC：降序</li></ul><h3 id="2-5-6-分页查询"><a href="#2-5-6-分页查询" class="headerlink" title="2.5.6 分页查询"></a>2.5.6 分页查询</h3><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 LIMIT 起始索引,查询记录数;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>起始索引从0开始，起始索引&#x3D;（查询页码-1）* 每页记录数。</li><li>分页查询是数据库的方言，不同的数据库有不同的实现，mysql是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10.</li></ul><h3 id="2-5-7-DQL执行顺序"><a href="#2-5-7-DQL执行顺序" class="headerlink" title="2.5.7 DQL执行顺序"></a>2.5.7 DQL执行顺序</h3><p><img src="/../images/MySql-Mysql/image-20250131201032788.png" alt="image-20250131201032788"></p><h2 id="2-6-DCL"><a href="#2-6-DCL" class="headerlink" title="2.6 DCL"></a>2.6 DCL</h2><p>用来管理数据库用户、控制数据库的访问权限。</p><h3 id="2-6-1-管理用户"><a href="#2-6-1-管理用户" class="headerlink" title="2.6.1 管理用户"></a>2.6.1 管理用户</h3><ul><li>查询用户</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE mysql;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><ul><li>创建用户</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>修改用户密码</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>删除用户</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="2-6-2-权限控制"><a href="#2-6-2-权限控制" class="headerlink" title="2.6.2 权限控制"></a>2.6.2 权限控制</h3><p><strong>常用权限</strong></p><p><img src="/../images/MySql-Mysql/image-20250131201930250.png" alt="image-20250131201930250"></p><ul><li>查询权限</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>授予权限</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> 权限列表 <span class="hljs-keyword">ON</span> 数据库名.表名 <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>撤销权限</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> 权限列表 <span class="hljs-keyword">ON</span> 数据库名.表名 <span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="3-函数"><a href="#3-函数" class="headerlink" title="3 函数"></a>3 函数</h1><h2 id="3-1-字符串函数"><a href="#3-1-字符串函数" class="headerlink" title="3.1 字符串函数"></a>3.1 字符串函数</h2><p><img src="/../images/MySql-Mysql/image-20250201121439266.png" alt="image-20250201121439266"></p><h2 id="3-2-数值函数"><a href="#3-2-数值函数" class="headerlink" title="3.2 数值函数"></a>3.2 数值函数</h2><p><img src="/../images/MySql-Mysql/image-20250201121923898.png" alt="image-20250201121923898"></p><h2 id="3-3-日期函数"><a href="#3-3-日期函数" class="headerlink" title="3.3 日期函数"></a>3.3 日期函数</h2><p><img src="/../images/MySql-Mysql/image-20250201122243626.png" alt="image-20250201122243626"></p><h2 id="3-4-流程函数"><a href="#3-4-流程函数" class="headerlink" title="3.4 流程函数"></a>3.4 流程函数</h2><p><img src="/../images/MySql-Mysql/image-20250201122608008.png" alt="image-20250201122608008"></p><h1 id="4-约束"><a href="#4-约束" class="headerlink" title="4 约束"></a>4 约束</h1><p><strong>概念</strong>：作用于表中字段上的规则，用于限制存储在表中的数据</p><p><strong>目的</strong>：保证数据库中数据的正确、有效和完整</p><p><strong>分类</strong></p><p><img src="/../images/MySql-Mysql/image-20250201124712615.png" alt="image-20250201124712615"></p><p><strong>案例</strong></p><p><img src="/../images/MySql-Mysql/image-20250201125133223.png" alt="image-20250201125133223"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">user</span>(<br>    id     <span class="hljs-type">int</span>           <span class="hljs-keyword">primary</span> key auto_increment     comment <span class="hljs-string">&#x27;编号&#x27;</span>,<br>    name   <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)   <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">unique</span>                comment <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age    <span class="hljs-type">int</span> unsigned  <span class="hljs-keyword">check</span>(age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">120</span>)  comment <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    status <span class="hljs-type">char</span>(<span class="hljs-number">1</span>)       <span class="hljs-keyword">default</span> <span class="hljs-string">&#x27;1&#x27;</span>                    comment <span class="hljs-string">&#x27;状态&#x27;</span>,<br>    gender <span class="hljs-type">char</span>(<span class="hljs-number">1</span>)                                      comment <span class="hljs-string">&#x27;性别&#x27;</span><br>)comment <span class="hljs-string">&#x27;用户表&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h2 id="4-1-外键约束"><a href="#4-1-外键约束" class="headerlink" title="4.1 外键约束"></a>4.1 外键约束</h2><p><strong>概念</strong>：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。</p><p><img src="/../images/MySql-Mysql/image-20250201130252646.png" alt="image-20250201130252646"></p><p><strong>语法</strong></p><ul><li>添加外键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段名 数据类型<br>...<br>[<span class="hljs-keyword">CONSTRAINT</span>] [外键名称] <span class="hljs-keyword">FOREIGN</span> KEY(外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名)<br>);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY(外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名);<br></code></pre></td></tr></table></figure><ul><li>删除外键</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN</span> KEY 外键名称;<br></code></pre></td></tr></table></figure><p><strong>删除&#x2F;更新行为</strong></p><p><img src="/../images/MySql-Mysql/image-20250201130815062.png" alt="image-20250201130815062"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> 外键名称 <span class="hljs-keyword">FOREIGN</span> KEY(外键字段) <span class="hljs-keyword">REFERENCES</span> 主表名(主表字段名) <span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> CASCADE <span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> CASCADE;<br></code></pre></td></tr></table></figure><h1 id="5-多表查询"><a href="#5-多表查询" class="headerlink" title="5 多表查询"></a>5 多表查询</h1><h2 id="5-1-多表关系"><a href="#5-1-多表关系" class="headerlink" title="5.1 多表关系"></a>5.1 多表关系</h2><h3 id="5-1-1-一对多"><a href="#5-1-1-一对多" class="headerlink" title="5.1.1 一对多"></a>5.1.1 一对多</h3><p>例如部门与员工的关系，一个部门对应多个员工，一个员工对应一个部门。</p><p>实现：在多的一方建立外键，指向一的一方的主键。</p><h3 id="5-1-2-多对多"><a href="#5-1-2-多对多" class="headerlink" title="5.1.2 多对多"></a>5.1.2 多对多</h3><p>例如学生和课程之间的关系，一个学生可以选修多门课程，一门课程也可以被多个学生选修。</p><p>实现：建立一张中间表，至少包含两个外键，分别关联双方的主键。</p><h3 id="5-1-3-一对一"><a href="#5-1-3-一对一" class="headerlink" title="5.1.3 一对一"></a>5.1.3 一对一</h3><p>例如用户与用户详情之间的关系。多用于单表拆分，将一张表的基础字段放在一张表中，其他详情放在另外一张表中，以提升操作效率。</p><p>实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的（unique）</p><h2 id="5-2-多表查询概述"><a href="#5-2-多表查询概述" class="headerlink" title="5.2 多表查询概述"></a>5.2 多表查询概述</h2><p><strong>概述</strong>：从多张表中查询数据</p><p><strong>笛卡尔积</strong>：两个集合A和B的所有组合情况（多表查询时，需要消除无效的笛卡尔积）。</p><h2 id="5-3-连接查询"><a href="#5-3-连接查询" class="headerlink" title="5.3 连接查询"></a>5.3 连接查询</h2><h3 id="5-3-1-内连接"><a href="#5-3-1-内连接" class="headerlink" title="5.3.1 内连接"></a>5.3.1 内连接</h3><p>查询A、B交集部分的数据。</p><p><strong>语法</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 隐式内连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>,表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 条件;<br><br><span class="hljs-comment">-- 显式内连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure><h3 id="5-3-2-外连接"><a href="#5-3-2-外连接" class="headerlink" title="5.3.2 外连接"></a>5.3.2 外连接</h3><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>查询左表所有数据，以及两表交集部分的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件;<br></code></pre></td></tr></table></figure><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>查询右表所有数据，以及两表交集部分的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 条件;<br></code></pre></td></tr></table></figure><h3 id="5-3-3-自连接"><a href="#5-3-3-自连接" class="headerlink" title="5.3.3 自连接"></a>5.3.3 自连接</h3><p>当前表与自身的连接查询，自连接必须使用表别名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A 别名A <span class="hljs-keyword">JOIN</span> 表A 别名B <span class="hljs-keyword">ON</span> 条件;<br></code></pre></td></tr></table></figure><h2 id="5-4-联合查询"><a href="#5-4-联合查询" class="headerlink" title="5.4 联合查询"></a>5.4 联合查询</h2><p>关键字：union，union all</p><p>把多次查询的结果合并起来，形成一个新的查询结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表A...<br><span class="hljs-keyword">UNION</span> [<span class="hljs-keyword">ALL</span>]<br><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表B...;<br></code></pre></td></tr></table></figure><ul><li>UNION会对结果去重</li><li>UNION ALL直接将两次查询的结果拼接到一起</li><li>多张表的列数必须保持一致，字段类型也需要保持一致</li></ul><h2 id="5-5-子查询"><a href="#5-5-子查询" class="headerlink" title="5.5 子查询"></a>5.5 子查询</h2><p>概念：在sql语句中嵌套select语句，成为嵌套查询，也叫子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t1 <span class="hljs-keyword">WHERE</span> column1 <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> column1 <span class="hljs-keyword">FROM</span> t2);<br></code></pre></td></tr></table></figure><h3 id="5-5-1-标量子查询"><a href="#5-5-1-标量子查询" class="headerlink" title="5.5.1 标量子查询"></a>5.5.1 标量子查询</h3><p>子查询放回的结果是单个值。 </p><p><strong>常用的操作符</strong>：&#x3D;,&lt;&gt;,&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;</p><p><strong>案例</strong></p><p>查询销售部的所有员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- a 先查询销售部的部门id</span><br><span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>;<br><span class="hljs-comment">-- b 再查询部门id=销售部部门id的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;销售部&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="5-5-2-列子查询"><a href="#5-5-2-列子查询" class="headerlink" title="5.5.2 列子查询"></a>5.5.2 列子查询</h3><p>子查询返回的结果是一列。</p><p><strong>常用的操作符</strong>：IN, NOT IN, ANY, SOME, ALL</p><p><img src="/../images/MySql-Mysql/image-20250201141909930.png" alt="image-20250201141909930"></p><h3 id="5-5-3-行子查询"><a href="#5-5-3-行子查询" class="headerlink" title="5.5.3 行子查询"></a>5.5.3 行子查询</h3><p>子查询返回的结果是一行。</p><p><strong>常用的操作符</strong>：&#x3D;, &lt;&gt;, IN, NOT IN</p><p><strong>案例</strong></p><p>查询与张无忌工资以及直属领导相同的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- a 查询张无忌的工资及直属领导id</span><br><span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张无忌&#x27;</span>;<br><span class="hljs-comment">-- 结果 12500, 1</span><br><span class="hljs-comment">-- b 查询与之相同的员工信息</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> salary <span class="hljs-operator">=</span> <span class="hljs-number">12500</span> <span class="hljs-keyword">and</span> managerid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;1&#x27;</span>;<br><span class="hljs-comment">-- 可以进一步简写为</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (salary, mangerid) <span class="hljs-operator">=</span> (<span class="hljs-number">12500</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-comment">-- 进一步用子查询</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (salary, mangerid) <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> salary, managerid <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;张无忌&#x27;</span>;);<br></code></pre></td></tr></table></figure><h3 id="5-5-4-表子查询"><a href="#5-5-4-表子查询" class="headerlink" title="5.5.4 表子查询"></a>5.5.4 表子查询</h3><p>子查询返回的结果是多行多列。</p><p><strong>常用的操作</strong>：IN</p><p>主要是用到from之后，将临时结果作为表从中查询。</p><p><strong>案例</strong></p><p>查询与“鹿杖客”，“宋远桥”的职位和薪资相同的员工信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> (job, salary) <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> job, salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;鹿杖客&#x27;</span> <span class="hljs-keyword">or</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;宋远桥&#x27;</span>);<br></code></pre></td></tr></table></figure><p>查询入职日期是’2006-01-01’之后的员工信息，及部门信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> entrydate <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;2006-01-01&#x27;</span>) e <span class="hljs-keyword">left</span> <span class="hljs-keyword">outer</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><h2 id="5-6-多表查询案例"><a href="#5-6-多表查询案例" class="headerlink" title="5.6 多表查询案例"></a>5.6 多表查询案例</h2><ul><li>查询员工的姓名、年龄、职位、部门信息。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.name, e.age, e.job, d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><ul><li>查询年龄小于30的员工姓名、年龄、职位、部门信息。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.name, e.age, e.job, d.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&lt;</span> <span class="hljs-number">30</span>;<br></code></pre></td></tr></table></figure><ul><li>查询拥有员工的部门ID、部门名称。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> d.id, d.name <span class="hljs-keyword">from</span> emp e, dept d <span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id;<br></code></pre></td></tr></table></figure><ul><li>查询所有年龄大于40岁的员工，及其归属的部门名称；如果员工没有分配部门，也需要展示出来。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.name, d.name <span class="hljs-keyword">from</span> emp e <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> dept d <span class="hljs-keyword">on</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">where</span> e.age <span class="hljs-operator">&gt;</span> <span class="hljs-number">40</span>;<br></code></pre></td></tr></table></figure><ul><li>查询所有员工的工资等级。</li></ul><p><img src="/../images/MySql-Mysql/image-20250201145602955.png" alt="工资等级表"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.name, sg.grade <span class="hljs-keyword">from</span> emp e, salarygrade sg <span class="hljs-keyword">where</span> e.salary <span class="hljs-operator">&gt;=</span> losal <span class="hljs-keyword">and</span> e.salary <span class="hljs-operator">&lt;=</span> hisal;<br><br><span class="hljs-keyword">select</span> e.name, sg.grade <span class="hljs-keyword">from</span> emp e, salarygrade sg <span class="hljs-keyword">where</span> e.salary <span class="hljs-keyword">between</span> sg.losal <span class="hljs-keyword">and</span> sg.hisal;<br></code></pre></td></tr></table></figure><ul><li>查询研发部所有员工的信息及工资等级。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, sg.grade <span class="hljs-keyword">from</span> emp e, salarygrade sg <span class="hljs-keyword">where</span> e.salary <span class="hljs-keyword">between</span> sg.losal <span class="hljs-keyword">and</span> sg.hisal <span class="hljs-keyword">and</span> e.dept_id <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> dept <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>);<br><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span>, sg.grade <span class="hljs-string">&#x27;工资等级&#x27;</span><br><span class="hljs-keyword">from</span> emp e, salgrade sg, dept d<br><span class="hljs-keyword">where</span> e.salary <span class="hljs-keyword">between</span> sg.losal <span class="hljs-keyword">and</span> sg.hisal<br>  <span class="hljs-keyword">and</span> e.dept_id <span class="hljs-operator">=</span> d.id<br>  <span class="hljs-keyword">and</span> d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>查询研发部员工的平均工资。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(e.salary) <span class="hljs-string">&#x27;平均薪资&#x27;</span><br><span class="hljs-keyword">from</span> emp e, dept d<br><span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> d.id <span class="hljs-keyword">and</span><br>      d.name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;研发部&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>查询工资比灭绝高的员工信息。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp e<br><span class="hljs-keyword">where</span> e.salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> salary <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;灭绝&#x27;</span>);<br></code></pre></td></tr></table></figure><ul><li>查询比平均薪资高的员工信息。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp e<br><span class="hljs-keyword">where</span> e.salary <span class="hljs-operator">&gt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> emp);<br></code></pre></td></tr></table></figure><ul><li>查询低于本部门平均工资的员工信息。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> e.name, e.salary, e.dept_id, t.dept_id, t.avg_sal<br><span class="hljs-keyword">from</span> emp e,<br>     (<span class="hljs-keyword">select</span> dept_id, <span class="hljs-built_in">avg</span>(salary) avg_sal <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> dept_id) t<br><span class="hljs-keyword">where</span> e.dept_id <span class="hljs-operator">=</span> t.dept_id<br>  <span class="hljs-keyword">and</span> e.salary <span class="hljs-operator">&lt;</span> t.avg_sal;<br><br><span class="hljs-keyword">select</span> e.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> emp e<br><span class="hljs-keyword">where</span> e.salary <span class="hljs-operator">&lt;</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">avg</span>(salary) <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> emp.dept_id <span class="hljs-operator">=</span> e.dept_id);<br></code></pre></td></tr></table></figure><ul><li>查询所有的部门信息，并统计部门的员工人数。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询所有的部门信息，并统计部门的员工人数。</span><br><span class="hljs-keyword">select</span> d.name, <span class="hljs-built_in">count</span>(e.name) <span class="hljs-string">&#x27;人数&#x27;</span><br><span class="hljs-keyword">from</span> dept d<br>         <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> emp e <span class="hljs-keyword">on</span> d.id <span class="hljs-operator">=</span> e.dept_id<br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> d.name;<br></code></pre></td></tr></table></figure><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6 事务"></a>6 事务</h1><h2 id="6-1-事务简介"><a href="#6-1-事务简介" class="headerlink" title="6.1 事务简介"></a>6.1 事务简介</h2><p>事务是一组操作的集合，是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，要么同时成功，要么同时失败。</p><p>默认mysql的事务是自动提交的，当执行一条sql语句，mysql会立即隐式的提交事务。</p><h2 id="6-2-事务操作"><a href="#6-2-事务操作" class="headerlink" title="6.2 事务操作"></a>6.2 事务操作</h2><ul><li>查看&#x2F;设置事务提交方式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@autocommit</span>;<br><br><span class="hljs-keyword">SET</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">SET</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><ul><li>提交事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><ul><li>回滚事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure><ul><li>开启事务</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION <br><span class="hljs-comment">-- 或</span><br><span class="hljs-keyword">BEGIN</span>;<br></code></pre></td></tr></table></figure><h2 id="6-3-事务四大特性ACID"><a href="#6-3-事务四大特性ACID" class="headerlink" title="6.3 事务四大特性ACID"></a>6.3 事务四大特性ACID</h2><ul><li>原子性（atuomicity）：事务是不可分割的最小操作单元。</li><li>一致性（consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（isolation）：保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（durability）：事务一旦提交或者回滚，对数据的改变就是永久的</li></ul><h2 id="6-4-并发事务问题"><a href="#6-4-并发事务问题" class="headerlink" title="6.4 并发事务问题"></a>6.4 并发事务问题</h2><p><img src="/../images/MySql-Mysql/image-20250201211459327.png" alt="image-20250201211459327"></p><h2 id="6-5-事务隔离级别"><a href="#6-5-事务隔离级别" class="headerlink" title="6.5 事务隔离级别"></a>6.5 事务隔离级别</h2><p><img src="/../images/MySql-Mysql/image-20250201211735100.png" alt="image-20250201211735100"></p><p>从上到下，隔离级别越来越高，性能越来越差。</p><ul><li>查看事务隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@TRANSACTION_ISOLATION</span>;<br></code></pre></td></tr></table></figure><ul><li>设置事务隔离级别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span>] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED<span class="hljs-operator">|</span>READ COMMITTED<span class="hljs-operator">|</span>REPEATABLE READ<span class="hljs-operator">|</span>SERIALIZABLE&#125;;<br></code></pre></td></tr></table></figure><p>SESSION|GLOBAL字段指明是设置当前会话的隔离级别还是全局的隔离级别。</p><h1 id="7-存储引擎"><a href="#7-存储引擎" class="headerlink" title="7 存储引擎"></a>7 存储引擎</h1><h2 id="7-1-mysql体系结构"><a href="#7-1-mysql体系结构" class="headerlink" title="7.1 mysql体系结构"></a>7.1 mysql体系结构</h2><p><img src="/../images/MySql-Mysql/image-20250202202859742.png" alt="image-20250202202859742"></p><ul><li>连接层：最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li>服务层：第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。</li><li>引擎层：存储引擎真正的负责了MvSQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</li><li>存储层：主要是将数据存储在文件系统之上，并完成与存储引擎的交互，</li></ul><h2 id="7-2-存储引擎简介"><a href="#7-2-存储引擎简介" class="headerlink" title="7.2 存储引擎简介"></a>7.2 存储引擎简介</h2><p>存储引擎是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的。</p><ul><li>在创建表时，指定存储引擎</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>字段列表<br>)ENGINE <span class="hljs-operator">=</span> INNODB;<br></code></pre></td></tr></table></figure><ul><li>查看当前数据库支持的存储引擎</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> ENGINES;<br></code></pre></td></tr></table></figure><h2 id="7-3-存储引擎特点"><a href="#7-3-存储引擎特点" class="headerlink" title="7.3 存储引擎特点"></a>7.3 存储引擎特点</h2><h3 id="7-3-1-InnoDB"><a href="#7-3-1-InnoDB" class="headerlink" title="7.3.1 InnoDB"></a>7.3.1 InnoDB</h3><p>兼顾高可靠性和高性能的通用存储引擎，在mysql5.5之后，作为默认存储引擎。</p><ul><li>DML操作遵循ACID模型，支持<strong>事务</strong>。</li><li><strong>行级锁</strong>，提高并发事务访问。</li><li>支持<strong>外键</strong>FOREIGN KEY约束，保证数据的完整性和正确性；</li></ul><p><strong>文件</strong>：</p><ul><li>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样的一个表空间文件，存储该表的表结构（frm，sdi），数据和索引。</li><li>参数：innodb_file_per_table指定是否每张表都对应一个表文件。</li></ul><p><strong>逻辑存储结构</strong></p><p><img src="/../images/MySql-Mysql/image-20250202204450953.png" alt="image-20250202204450953"></p><h3 id="7-3-2-MyISAM"><a href="#7-3-2-MyISAM" class="headerlink" title="7.3.2 MyISAM"></a>7.3.2 MyISAM</h3><p>早期的默认存储引擎。</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p><strong>文件</strong></p><ul><li>xxx.sdi：存储表结构信息</li><li>xxx.MYD：存储数据</li><li>xxx.MYI：存储索引</li></ul><h3 id="7-3-3-Memory"><a href="#7-3-3-Memory" class="headerlink" title="7.3.3 Memory"></a>7.3.3 Memory</h3><p>存储在内存中，只能作为临时表或缓存使用</p><ul><li>内存存放，访问速度快</li><li>hash索引（默认）</li></ul><p><strong>文件</strong></p><ul><li>xxx.sdi：存储表结构信息</li></ul><p><img src="/../images/MySql-Mysql/image-20250202204822801.png" alt="image-20250202204822801"></p><h2 id="7-4-存储引擎选择"><a href="#7-4-存储引擎选择" class="headerlink" title="7.4 存储引擎选择"></a>7.4 存储引擎选择</h2><ul><li>InnoDB：是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li></ul><h1 id="8-索引"><a href="#8-索引" class="headerlink" title="8 索引"></a>8 索引</h1><h2 id="8-1-索引概述"><a href="#8-1-索引概述" class="headerlink" title="8.1 索引概述"></a>8.1 索引概述</h2><p>索引（index）是帮助mysql高效获取数据的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特性查找算法的数据结构，这些数据结构以某种方式指向数据，帮助快速查找数据。</p><p><img src="/../images/MySql-Mysql/image-20250205153457238.png" alt="image-20250205153457238"></p><h2 id="8-2-索引结构"><a href="#8-2-索引结构" class="headerlink" title="8.2 索引结构"></a>8.2 索引结构</h2><p><strong>索引结构</strong></p><p>因存储引擎不同而所有区别</p><p><img src="/../images/MySql-Mysql/image-20250205153615648.png" alt="image-20250205153615648"></p><p><img src="/../images/MySql-Mysql/image-20250205153700915.png" alt="image-20250205153700915"></p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><img src="/../images/MySql-Mysql/image-20250205155204239.png" alt="image-20250205155204239"></p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><ul><li>只能由于对等比较，不支持范围查询</li><li>无法利用索引完成排序</li><li>效率高，通常只需要一次检索，通常要优于B+树索引</li></ul><h3 id="为什么采用b-树"><a href="#为什么采用b-树" class="headerlink" title="为什么采用b+树"></a>为什么采用b+树</h3><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>相对于b树，非叶子节点只存放索引，能够存放的索引更多，高度更低，效率更高</li><li>相对于hash，支持范围查询及排序操作</li></ul><h2 id="8-3-索引分类"><a href="#8-3-索引分类" class="headerlink" title="8.3 索引分类"></a>8.3 索引分类</h2><p><img src="/../images/MySql-Mysql/image-20250205155915157.png" alt="image-20250205155915157"></p><p><img src="/../images/MySql-Mysql/image-20250205160036466.png" alt="image-20250205160036466"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一索引作为聚集索引</li><li>如果不存在主键，也没有合适的唯一索引，innodb会自动生成一个rowid作为隐藏的聚集索引</li></ul><p><img src="/../images/MySql-Mysql/image-20250205160313810.png" alt="image-20250205160313810"></p><p><strong>回表查询</strong></p><p>先根据二级索引找到对应的主键值，再根据主键值去聚集索引中拿到对应的行数据。</p><h2 id="8-4-索引语法"><a href="#8-4-索引语法" class="headerlink" title="8.4 索引语法"></a>8.4 索引语法</h2><ul><li>创建索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span><span class="hljs-operator">|</span>FULLTEXT] INDEX index_name <span class="hljs-keyword">ON</span> table_name (index_col_name,...);<br></code></pre></td></tr></table></figure><p>一个索引可以关联多个字段，如果只关联一个字段，则是单列索引，否则就是组合索引（联合索引）。</p><ul><li>查看索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure><ul><li>删除索引</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure><h2 id="8-5-SQL性能分析"><a href="#8-5-SQL性能分析" class="headerlink" title="8.5 SQL性能分析"></a>8.5 SQL性能分析</h2><h3 id="8-5-1-SQL执行频率"><a href="#8-5-1-SQL执行频率" class="headerlink" title="8.5.1 SQL执行频率"></a>8.5.1 SQL执行频率</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] STATUE <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>; # <span class="hljs-number">7</span>个下划线<br></code></pre></td></tr></table></figure><p><img src="/../images/MySql-Mysql/image-20250205161725617.png" alt="image-20250205161725617"></p><h3 id="8-5-2-慢查询日志"><a href="#8-5-2-慢查询日志" class="headerlink" title="8.5.2 慢查询日志"></a>8.5.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time, 单位：秒，默认10s）的所有sql语句的日志。</p><p>mysql的慢查询日志默认没有开启，需要在mysql的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息</p><p><img src="/../images/MySql-Mysql/image-20250205203414889.png" alt="image-20250205203414889"></p><h3 id="8-5-3-profile详情"><a href="#8-5-3-profile详情" class="headerlink" title="8.5.3 profile详情"></a>8.5.3 profile详情</h3><p>show profiles能够在做sql优化时帮助我们了解时间耗费情况。通过have_profiling参数，能够查看当前数据库是否支持profile操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@have_profiling</span>;<br></code></pre></td></tr></table></figure><p>默认profiling是关闭的，可以通过set语句在session&#x2F;global下开启profiling</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 查看每一条sql的耗时基本情况</span><br><span class="hljs-keyword">show</span> profiles;<br><br><span class="hljs-comment">-- 查看指定query_id的sql语句各个阶段的耗时情况</span><br><span class="hljs-keyword">show</span> profile <span class="hljs-keyword">for</span> query query_id;<br><span class="hljs-comment">-- 查看指定query_id的sql语句的cpu使用情况</span><br><span class="hljs-keyword">show</span> profile cpu <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure><h3 id="8-5-4-explain执行计划"><a href="#8-5-4-explain执行计划" class="headerlink" title="8.5.4 explain执行计划"></a>8.5.4 explain执行计划</h3><p>explain或者desc命令获取mysql如何执行select语句的信息，包括在select语句执行过程中表如何连接和连接的顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 直接在select语句前面加上explain或者desc</span><br>EXPLAIN <span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">id</th><th align="left">select_type</th><th align="left">table</th><th align="left">partitions</th><th align="left">type</th><th align="left">possible_keys</th><th align="left">key</th><th align="left">key_len</th><th align="left">ref</th><th align="left">rows</th><th align="left">filtered</th><th align="left">Extra</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIMPLE</td><td align="left">account</td><td align="left">null</td><td align="left">ALL</td><td align="left">null</td><td align="left">null</td><td align="left">null</td><td align="left">null</td><td align="left">2</td><td align="left">50</td><td align="left">Using where</td></tr></tbody></table><ul><li>id：select查询的序列号，表示查询中执行select子句或者是操作表的顺序（id相同，执行顺序从上到下，id不同，值越大，越先执行）。</li><li>select_type：表示查询类型，常见的取值有simple（简单表，不使用表连接或者子查询）、primary（主查询，外层的查询）、union（union中的第二个或者后面的查询语句）、subquery（子查询）等。</li><li><strong>type</strong>：表示连接类型，性能由好到差的连接类型为NULL（不涉及表）、system（系统表）、const（唯一索引）、eq_ref、ref（非唯一性索引）、range、index（用了索引，但是仍然对整棵树进行扫描）、all（全表扫描）。</li><li><strong>possible_keys</strong>：显示可能应用在这张表上的索引。</li><li><strong>key</strong>：实际用到的索引</li><li><strong>key_len</strong>：使用到的索引的字节数，该值为索引字段的最大可能长度。</li><li>rows：mysql认为必须要执行查询的行数，是一个估计值</li><li>filtered：结果的行数占需读取行数的百分比</li></ul><h2 id="8-6-索引使用"><a href="#8-6-索引使用" class="headerlink" title="8.6 索引使用"></a>8.6 索引使用</h2><ul><li>最左前缀法则</li></ul><p>如果索引了多列，要遵守最左前缀法则，即查询从索引的最左列开始，并且不跳过索引中的列。如果不包含最左边的列，索引全部失效；如果跳过了部分列，索引会部分失效（后面的字段的索引失效）。</p><ul><li>范围查询</li></ul><p>联合索引中，出现范围查询（&gt;,&lt;)，范围查询右侧的列索引失效。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_user <span class="hljs-keyword">where</span> profession<span class="hljs-operator">=</span><span class="hljs-string">&#x27;软件工程&#x27;</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">30</span> <span class="hljs-keyword">and</span> status<span class="hljs-operator">=</span><span class="hljs-string">&#x27;0&#x27;</span>;<br></code></pre></td></tr></table></figure><p>对于上面的语句，status索引失效。</p><p><strong>规避方式</strong>就是在条件允许的情况下，尽量采用&gt;&#x3D;,&lt;&#x3D;。</p><ul><li>索引列运算</li></ul><p>不要在索引列上进行运算操作，否则索引会失效。</p><ul><li>字符串类型加引号</li></ul><p>不加引号，索引会失效</p><ul><li>模糊查询</li></ul><p>如果仅仅是尾部模糊匹配，索引不会失效，如果是头部模糊匹配，索引失效。</p><ul><li>or连接的条件</li></ul><p>用or分开的条件，如果一个有索引，一个没有索引，那么涉及的索引都不会生效。</p><p><strong>规避方式</strong>就是对涉及到的列都建立索引。</p><ul><li>数据分布影响</li></ul><p>如果mysql评估使用此索引比全表扫描还慢，就不使用索引。</p><ul><li>sql提示</li></ul><p>在sql语句中加入一些人为的提示来达到优化操作的目的。</p><p><img src="/../images/MySql-Mysql/image-20250205212130871.png" alt="image-20250205212130871"></p><p>use index是一个建议，force index是强制。</p><ul><li>覆盖索引</li></ul><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到），减少select*</p><p>extra信息：</p><p><img src="/../images/MySql-Mysql/image-20250205212600517.png" alt="image-20250205212600517"></p><ul><li>前缀索引</li></ul><p>当字段类型为字符串时，有时候索引很长，导致大量的磁盘io，影响查询效率。此时可以只将字符串的一部分前缀建立索引，提高索引效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name <span class="hljs-keyword">ON</span> table_name(<span class="hljs-keyword">column</span>(n));<br></code></pre></td></tr></table></figure><p>根据索引的选择性来决定前缀长度，选择性是指不重复的索引值和数据表的记录总数的比值。</p><p>计算选择性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> email) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;<br><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-keyword">distinct</span> <span class="hljs-built_in">substring</span>(email,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>)) <span class="hljs-operator">/</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> tb_user;<br></code></pre></td></tr></table></figure><p><img src="/../images/MySql-Mysql/image-20250205213709424.png" alt="image-20250205213709424"></p><ul><li>单列索引和联合索引</li></ul><p>如果存在多个查询条件，建议建立联合索引。如果覆盖索引，不需要回表查询。</p><h2 id="8-7-索引设计原则"><a href="#8-7-索引设计原则" class="headerlink" title="8.7 索引设计原则"></a>8.7 索引设计原则</h2><p><img src="/../images/MySql-Mysql/image-20250205214206757.png" alt="image-20250205214206757"></p><h1 id="9-SQL优化"><a href="#9-SQL优化" class="headerlink" title="9 SQL优化"></a>9 SQL优化</h1><h2 id="9-1-插入数据"><a href="#9-1-插入数据" class="headerlink" title="9.1 插入数据"></a>9.1 插入数据</h2><ul><li>批量插入</li></ul><p>采用批量插入优化插入多条数据操作，不建议超过1000条以上的数据。对于几万条数据，可以分为多条插入批量操作。</p><ul><li>手动提交事务</li><li>主键顺序插入</li><li>大批量插入数据</li></ul><p>使用insert插入性能较低，可以使用load指令进行插入</p><p><img src="/../images/MySql-Mysql/image-20250206113524201.png" alt="image-20250206113524201"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 客户端连接服务器时，加上参数 --local-infile</span><br>mysql <span class="hljs-comment">--local-infile -u root -p</span><br><span class="hljs-comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关</span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">-- 执行load指令将准备好的数据，加载到表结构中</span><br>load data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> <span class="hljs-string">&#x27;tb_user&#x27;</span> fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="9-2-主键优化"><a href="#9-2-主键优化" class="headerlink" title="9.2 主键优化"></a>9.2 主键优化</h2><ul><li>数据组织方式</li></ul><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（index organized table，IOT）。</p><ul><li>页分裂</li></ul><p>页可以为空，也可以填充一半，也可以填充100%，每个页包含了2-N行数据，根据主键排列。</p><ul><li>页合并</li></ul><p><img src="/../images/MySql-Mysql/image-20250206114941929.png" alt="image-20250206114941929"></p><ul><li>主键顺序插入</li></ul><p><img src="/../images/MySql-Mysql/image-20250206114618274.png" alt="image-20250206114618274"></p><p>对于顺序插入，当一页满了之后，直接将新的行数据插入到新分配的页内即可，不会发生页分裂情况。</p><ul><li>主键乱序插入</li></ul><p><img src="/../images/MySql-Mysql/image-20250206114701480.png" alt="image-20250206114701480"></p><p><img src="/../images/MySql-Mysql/image-20250206114727804.png" alt="image-20250206114727804"></p><p><img src="/../images/MySql-Mysql/image-20250206114738690.png" alt="image-20250206114738690"></p><p>对于主键乱序插入，当新的行数据来了之后，需要根据顺序插入，此时前面的页如果满了，就会发生页分裂，将页一半的数据复制到新页中，然后插入数据，再调整链表指针。</p><ul><li><p>主键设计原则</p><ul><li><p>尽量降低主键长度</p><p>因为对于二级索引中存放的数据，就是主键，主键如果过长，会导致二级索引占用的空间变大。</p></li><li><p>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p></li><li><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p></li><li><p>避免对主键的修改</p></li></ul></li></ul><h2 id="9-3-order-by优化"><a href="#9-3-order-by优化" class="headerlink" title="9.3 order by优化"></a>9.3 order by优化</h2><p><img src="/../images/MySql-Mysql/image-20250206121348047.png" alt="image-20250206121348047"></p><p><img src="/../images/MySql-Mysql/image-20250206121907392.png" alt="image-20250206121907392"></p><h2 id="9-4-group-by优化"><a href="#9-4-group-by优化" class="headerlink" title="9.4 group by优化"></a>9.4 group by优化</h2><ul><li>分组操作可以通过索引来优化</li><li>需要满足最左前缀法则</li></ul><h2 id="9-5-limit优化"><a href="#9-5-limit优化" class="headerlink" title="9.5 limit优化"></a>9.5 limit优化</h2><p>对于limit，大数据量的时候，越往后的页，花费时间越长。因此此时mysql需要排序前面的数据，最后只返回最后的一页数据。</p><p>优化思路：通过创建覆盖索引加子查询的方式进行优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> t.<span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku t, (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2000000</span>, <span class="hljs-number">10</span>) a <span class="hljs-keyword">where</span> t.id <span class="hljs-operator">=</span> a.id;<br></code></pre></td></tr></table></figure><h2 id="9-6-count优化"><a href="#9-6-count优化" class="headerlink" title="9.6 count优化"></a>9.6 count优化</h2><p><img src="/../images/MySql-Mysql/image-20250206122752072.png" alt="image-20250206122752072"></p><p>优化思路：自己计数（通过redis等）。</p><ul><li><p>count的几种用法：count是一个聚合函数，对于返回的结果集，一行行地判断，如果不是null，累计值就+1。</p><ul><li><p>count(*)</p><p><img src="/../images/MySql-Mysql/image-20250206123320304.png" alt="image-20250206123320304"></p></li><li><p>count(主键)</p><p><img src="/../images/MySql-Mysql/image-20250206123336547.png" alt="image-20250206123336547"></p></li><li><p>count(字段)</p><p><img src="/../images/MySql-Mysql/image-20250206123236087.png" alt="image-20250206123236087"></p></li><li><p>count(1)</p><p><img src="/../images/MySql-Mysql/image-20250206123257547.png" alt="image-20250206123257547"></p></li><li><p>按照效率排序</p><p>count(字段)&lt;count(主键)&lt;count(1)约等于count(*)。主要考虑是否取值，是否判断等因素。</p></li></ul></li></ul><h2 id="9-7-update优化"><a href="#9-7-update优化" class="headerlink" title="9.7 update优化"></a>9.7 update优化</h2><p> InnoDB的行锁是针对索引加的锁，不是针对记录的，并且该索引不能失效，否则就会从行锁升级为表锁，导致并发性能降低。</p><h1 id="10-视图"><a href="#10-视图" class="headerlink" title="10 视图"></a>10 视图</h1><p>视图（view）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列的数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><ul><li>创建</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] <span class="hljs-keyword">VIEW</span> 视图名称(列名列表) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span>语句 [<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span><span class="hljs-operator">|</span><span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><ul><li>查询</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看创建视图语句</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名称;<br><br><span class="hljs-comment">-- 查看视图数据 可以像操作表一样操作视图</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 视图名称;<br></code></pre></td></tr></table></figure><ul><li>修改</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] <span class="hljs-keyword">VIEW</span> 视图名称(列名列表) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span>语句 [<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span><span class="hljs-operator">|</span><span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION];<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span> 视图名称(列名列表) <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span>语句 [<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span><span class="hljs-operator">|</span><span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> [IF <span class="hljs-keyword">EXISTS</span>] 视图名称 [,视图名称]...;<br></code></pre></td></tr></table></figure><ul><li>检查选项<ul><li>使用with check option创建视图时，mysql会检查正在更改的行，以使其符合视图定义。mysql允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保证一致性。cascaded和local指明了检查的范围。默认为cascaded。</li><li>cascaded：会级联检查每个依赖的视图的条件是否满足。</li><li>local：会级联检查依赖视图的条件是否满足，如果依赖的视图没有设置检查选项，则不检查。</li></ul></li><li>视图的更新</li></ul><p>只有视图中的行于基表中的行<strong>存在一对一</strong>的关系时，视图才可以更新，如果视图包含一下任何一项，视图不可更新：</p><p><img src="/../images/MySql-Mysql/image-20250206155521991.png" alt="image-20250206155521991"></p><ul><li>作用</li></ul><ol><li>简单：简化对数据的理解，简化操作。某些复杂查询可以被定义为视图，从而简化后续的查询。</li><li>安全：数据库可以授权，但是不能授权到特定行和特定列上，通过视图，用户只能查询和修改他们所能见到的数据</li><li>数据独立：屏蔽真实表结构带来的变化</li></ol><h1 id="11-存储过程"><a href="#11-存储过程" class="headerlink" title="11 存储过程"></a>11 存储过程</h1><p>存储过程是事先经过编译并存储在数据库中的一段sql语句的集合，调用存储过程可以简化开发人员的工作，减少数据库和应用服务器之间的数据传输，可以提高数据处理效率。</p><p>思想上，存储过程就是数据库sql语言层面的代码封装与重用。</p><ul><li>封装，复用</li><li>可以接受参数，可以返回数据</li><li>减少网络交互，效率提升</li></ul><h2 id="11-1-基本语法"><a href="#11-1-基本语法" class="headerlink" title="11.1 基本语法"></a>11.1 基本语法</h2><ul><li>创建</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称([参数列表])<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">-- SQL语句</span><br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><ul><li>调用</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> 名称([参数]);<br></code></pre></td></tr></table></figure><ul><li>查看</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询指定数据库的存储过程及状态信息</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="hljs-keyword">WHERE</span> ROUTINE_SCHEMA<span class="hljs-operator">=</span><span class="hljs-string">&#x27;XXX&#x27;</span>; <span class="hljs-comment">-- XXX数据库名称</span><br><br><span class="hljs-comment">-- 查询某个存储过程的定义</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称;<br></code></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> [IF <span class="hljs-keyword">EXISTS</span>] 存储过程名称;<br></code></pre></td></tr></table></figure><h2 id="11-2-变量"><a href="#11-2-变量" class="headerlink" title="11.2 变量"></a>11.2 变量</h2><h3 id="11-2-1-系统变量"><a href="#11-2-1-系统变量" class="headerlink" title="11.2.1 系统变量"></a>11.2.1 系统变量</h3><p>mysql服务器提供，不是用户定义的，属于服务器层面，分为</p><ul><li>全局变量（GLOBAL）：针对所有会话有效。</li><li>会话变量（SESSION）：针对当前会话有效。</li></ul><p><strong>查看系统变量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> [SESSION<span class="hljs-operator">|</span><span class="hljs-keyword">GLOBAL</span>] VARIABLES;<br><span class="hljs-keyword">SHOW</span> [SESSION<span class="hljs-operator">|</span><span class="hljs-keyword">GLOBAL</span>] VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;...&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> @@[SESSION<span class="hljs-operator">|</span>GLOBAL.]系统变量名;<br></code></pre></td></tr></table></figure><p><strong>设置系统变量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> [SESSION<span class="hljs-operator">|</span><span class="hljs-keyword">GLOBAL</span>] 系统变量名<span class="hljs-operator">=</span>值;<br><span class="hljs-keyword">SET</span> @@[SESSION<span class="hljs-operator">|</span>GLOBAL.]系统变量名<span class="hljs-operator">=</span>值;<br></code></pre></td></tr></table></figure><p>mysql服务器重启之后，全局变量会重置。如果想永久生效，需要修改配置文件。</p><h3 id="11-2-2-用户定义变量"><a href="#11-2-2-用户定义变量" class="headerlink" title="11.2.2 用户定义变量"></a>11.2.2 用户定义变量</h3><p>用户根据业务需求自己定义的变量，不用提前声明，在用的时候直接用”@变量名“使用就可以，其作用域为当前连接。</p><p><strong>赋值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-variable">@var_name</span> <span class="hljs-operator">=</span> expr [, <span class="hljs-variable">@var_name</span> <span class="hljs-operator">=</span> expr]...;<br><span class="hljs-keyword">SET</span> <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr [, <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr]...;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr [, <span class="hljs-variable">@var_name</span> :<span class="hljs-operator">=</span> expr]...;<br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> <span class="hljs-variable">@var_name</span> <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-variable">@var_name</span>;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>用户定义变量不用提前声明，如果使用的时候还没有赋值，也不会报错，只不过变量的值为null</p><h3 id="11-2-3-局部变量"><a href="#11-2-3-局部变量" class="headerlink" title="11.2.3 局部变量"></a>11.2.3 局部变量</h3>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++并发编程实战Chapter6</title>
    <link href="/2025/01/29/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter6/"/>
    <url>/2025/01/29/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter6/</url>
    
    <content type="html"><![CDATA[<h1 id="设计基于锁的并发数据结构"><a href="#设计基于锁的并发数据结构" class="headerlink" title="设计基于锁的并发数据结构"></a>设计基于锁的并发数据结构</h1><h2 id="并发设计的内涵"><a href="#并发设计的内涵" class="headerlink" title="并发设计的内涵"></a>并发设计的内涵</h2><p><strong>线程安全</strong></p><p>多线程执行的操作无论异同，每个线程所见的数据结构都是自恰的；数据不会丢失或破坏，所有不变量终将成立，恶性条件竞争也不会出现。</p><p><strong>真正的并发</strong></p><p>保护的范围越小，需要的串行化操作就越少，并发程度就可能越高。</p><h2 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h2><h3 id="基于锁实现线程安全的栈容器"><a href="#基于锁实现线程安全的栈容器" class="headerlink" title="基于锁实现线程安全的栈容器"></a>基于锁实现线程安全的栈容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">empty_stack</span> : std::exception &#123;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">what</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadSafeStack</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">ThreadSafeStack</span>(<span class="hljs-type">const</span> ThreadSafeStack&amp; other) &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(other.mtx_)</span></span>;<br>        data_ = other.data_;<br>    &#125;<br>    ThreadSafeStack&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> ThreadSafeStack&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>        data_.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(new_value));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>        <span class="hljs-keyword">if</span> (data_.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">empty_stack</span>();<br>        value = std::<span class="hljs-built_in">move</span>(data_.<span class="hljs-built_in">top</span>());<br>        data_.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>        <span class="hljs-keyword">if</span> (data_.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">throw</span> <span class="hljs-built_in">empty_stack</span>();<br>        <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(std::<span class="hljs-built_in">move</span>(data_.<span class="hljs-built_in">top</span>());<br>        data_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-built_in">empty</span>() <span class="hljs-type">const</span> &#123;<br>        std::lock_guard&lt;std::mutex&gt; <span class="hljs-built_in">lk</span>(mtx_);<br>        <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> std::mutex mtx_;<br>    std::stack&lt;T&gt; data_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>每个成员函数都在内部互斥m之上加锁，因此这保障了基本的线程安全。这种方式保证了任何时刻都仅有唯一线程访问数据。</li><li>在empty()和每个pop()重载之间，都潜藏着数据竞争的隐患。然而，pop()函数不仅可以加锁，其还可以明文判别内部的栈容器是否为空，所以这不属于恶性数据竞争。</li><li>这段代码有可能引起死锁，原因是我们在持锁期间执行用户代码：栈容器所含的数据中，有用户自定义的复制构造函数、移动构造函数、拷贝赋值操作符和移动赋值操作符，用户也有可能自行重载new操作符。假使栈容器要插入或移除数据，在操作过程中数据自身调用了上述函数，则可能再进一步调用栈容器的成员函数，因而需要获取锁，但相关的互斥却已被锁住，最后导致死锁。向栈容器添加&#x2F;移除数据，却不涉及复制行为或内存分配，这是不切实际的空想。合理的解决方式是对栈容器的使用者提出要求，由他们负责保证避免以上死锁场景。</li><li>需要使用者保证，必须当对象构造完成之后，别的线程才能访问数据；只有当所有线程都停止访问，才可以销毁对象。</li><li>该实现仅容许一次只有一个线程访问数据。性能有限。</li><li>该栈容器并未提供任何等待&#x2F;添加数据的操作，因此，假如栈容器满载数据而线程又等着添加数据，它就必须定期反复调用empty()，或通过调用pop()而捕获empty_stack异常，从而查验栈容器是否为空。万一真的出现这种情况，本例的栈容器实现就绝非最佳选择，因为等待的线程只有耗费宝贵的算力查验数据，或者栈容器使用者不得不另行编写代码，以在外部实现“等待-通知”的功能（如利用条件变量），令内部锁操作变得多余且浪费。</li></ul><h3 id="采用锁和条件变量实现线程安全的队列容器"><a href="#采用锁和条件变量实现线程安全的队列容器" class="headerlink" title="采用锁和条件变量实现线程安全的队列容器"></a>采用锁和条件变量实现线程安全的队列容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadsafe_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> std::mutex mut;<br>    std::queue&lt;T&gt; data_queue;<br>    std::condition_variable data_cond;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">threadsafe_queue</span>()<br>    &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>        data_queue.<span class="hljs-built_in">push</span>(std::<span class="hljs-built_in">move</span>(new_value));<br>        data_cond.<span class="hljs-built_in">notify_one</span>();  <span class="hljs-comment">//  ⇽---  ①</span><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T&amp; value)</span>  <span class="hljs-comment">//  ⇽---  ②</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>        data_cond.<span class="hljs-built_in">wait</span>(lk,[<span class="hljs-keyword">this</span>]&#123;<span class="hljs-keyword">return</span> !data_queue.<span class="hljs-built_in">empty</span>();&#125;);<br>        value=std::<span class="hljs-built_in">move</span>(data_queue.<span class="hljs-built_in">front</span>());<br>        data_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span>  <span class="hljs-comment">//  ⇽---  ③</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>        data_cond.<span class="hljs-built_in">wait</span>(lk,[<span class="hljs-keyword">this</span>]&#123;<span class="hljs-keyword">return</span> !data_queue.<span class="hljs-built_in">empty</span>();&#125;);  <span class="hljs-comment">//  ⇽---  ④</span><br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">res</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;<br>        data_queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T&amp; value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>        <span class="hljs-keyword">if</span>(data_queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        value=std::<span class="hljs-built_in">move</span>(data_queue.<span class="hljs-built_in">front</span>());<br>        data_queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>        <span class="hljs-keyword">if</span>(data_queue.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();  <span class="hljs-comment">//  ⇽---  ⑤</span><br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">res</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            std::make_shared&lt;T&gt;(std::move(data_queue.front())))</span></span>;<br>        data_queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>        <span class="hljs-keyword">return</span> data_queue.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>假定在数据压入队列的过程中，有多个线程同时在等待，那么data_cond.notify_one()的调用只会唤醒其中一个。然而，若该觉醒的线程在执行wait_and_pop()时抛出异常（譬如新指针std::shared_ptr&lt;&gt;在构建时就有可能产生异常④），就不会有任何其他线程被唤醒。<ul><li>如果我们不能接受这种行为方式，则将data_cond.notify_one()改为data_cond.notify_all()。这样就会唤醒全体线程，但要大大增加开销：它们绝大多数还是会发现队列依然为空，只好重新休眠。</li><li>第二种处理方式是，倘若有异常抛出，则在wait_and_pop()中再次调用notify_one()，从而再唤醒另一线程，让它去获取存储的值。</li><li>第三种处理方式是，将std::shared_ptr&lt;&gt;的初始化语句移动到push()的调用处，令队列容器改为存储std::shared_ptr&lt;&gt;，而不再直接存储数据的值。从内部std::queue&lt;&gt;复制std::shared_ptr&lt;&gt;实例的操作不会抛出异常，所以wait_and_pop()也是异常安全的。</li></ul></li></ul><h3 id="采用精细粒度的锁和条件变量实现线程安全的队列容器"><a href="#采用精细粒度的锁和条件变量实现线程安全的队列容器" class="headerlink" title="采用精细粒度的锁和条件变量实现线程安全的队列容器"></a>采用精细粒度的锁和条件变量实现线程安全的队列容器</h3><p>用单向链表充当队列的数据结构。队列含有一个“头指针head”，它指向头节点，每个节点再依次指向后继节点。队列弹出数据的方法是更改head指针：将指向目标改为其后继节点，并返回原来的第一项数据。</p><p>新数据从队列末端加入，其实现方式是，队列另外维护一个“尾指针tail”，指向尾节点。假如有新节点加入，则将尾节点的next指针指向新节点，并更新tail指针，令其指向新节点。如果队列为空，则将head指针和tail指针都设置为NULL。</p><p><img src="/../images/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter6/image-20250220113406835.png" alt="image-20250220113406835"></p><p><strong>单线程版本</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">queue</span>() : <span class="hljs-built_in">tail</span>(<span class="hljs-literal">nullptr</span>)<br>    &#123;&#125;<br>    <span class="hljs-built_in">queue</span>(<span class="hljs-type">const</span> queue&amp; other) = <span class="hljs-keyword">delete</span>;<br>    queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> queue&amp; other) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>        &#125;<br>        std::shared_ptr&lt;T&gt; <span class="hljs-type">const</span> res = std::<span class="hljs-built_in">make_shared</span>(std::<span class="hljs-built_in">move</span>(head-&gt;data));<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> old_head = std::<span class="hljs-built_in">move</span>(head);<br>        head = std::<span class="hljs-built_in">move</span>(old_head-&gt;next);<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>            tail = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span> </span>&#123;<br>        <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> node(std::move(new_value)))</span></span>;<br>        node* <span class="hljs-type">const</span> new_tail = p.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-keyword">if</span> (tail) &#123;<br>            tail-&gt;next = std::<span class="hljs-built_in">move</span>(p);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            head = std::<span class="hljs-built_in">move</span>(p);<br>        &#125;<br>        tail = new_tail;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>        T data;<br>        std::unique_ptr&lt;node&gt; next;<br>        <span class="hljs-built_in">node</span>(T data_):<br>            <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">move</span>(data_))<br>        &#123;&#125;<br>    &#125;;<br>    std::unique_ptr&lt;node&gt; head;<br>    node* tail;<br>&#125;;<br></code></pre></td></tr></table></figure><p>多线程下存在的问题：</p><ul><li>push可以同时改动head指针和tail指针，所以该函数需要将两个互斥锁住。</li><li>push和try_pop有可能并发访问同一个节点的next指针：当队列仅含有一个节点的时候，即head&#x3D;&#x3D;tail。这会导致锁定同一个互斥。</li></ul><p><strong>通过分离数据实现并发</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadsafe_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>        std::shared_ptr&lt;T&gt; data;<br>        std::unique_ptr&lt;node&gt; next;<br>    &#125;;<br>    std::mutex head_mutex;<br>    std::unique_ptr&lt;node&gt; head;<br>    std::mutex tail_mutex;<br>    node* tail;<br>    <span class="hljs-function">node* <span class="hljs-title">get_tail</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">tail_lock</span><span class="hljs-params">(tail_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">pop_head</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(head_mutex)</span></span>; <br><br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">get</span>()==<span class="hljs-built_in">get_tail</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        std::unique_ptr&lt;node&gt; old_head=std::<span class="hljs-built_in">move</span>(head);<br>        head=std::<span class="hljs-built_in">move</span>(old_head-&gt;next);<br>        <span class="hljs-keyword">return</span> old_head;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">threadsafe_queue</span>():<br>        <span class="hljs-built_in">head</span>(<span class="hljs-keyword">new</span> node),<span class="hljs-built_in">tail</span>(head.<span class="hljs-built_in">get</span>())<br>    &#123;&#125;<br>    <span class="hljs-built_in">threadsafe_queue</span>(<span class="hljs-type">const</span> threadsafe_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    threadsafe_queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> threadsafe_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::unique_ptr&lt;node&gt; old_head=<span class="hljs-built_in">pop_head</span>();<br>        <span class="hljs-keyword">return</span> old_head?old_head-&gt;data:std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">new_data</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;<br>        <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> node)</span></span>;<br>        node* <span class="hljs-type">const</span> new_tail=p.<span class="hljs-built_in">get</span>();<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">tail_lock</span><span class="hljs-params">(tail_mutex)</span></span>;<br>        tail-&gt;data=new_data;<br>        tail-&gt;next=std::<span class="hljs-built_in">move</span>(p);<br>        tail=new_tail;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>对于push而言，对tail指针的全部访问都需要加锁</li><li>对于try_pop而言，需要对head指针加锁，此外，还需要在内部访问tail指针一次，所以需要在对应的互斥上加锁。</li><li>在try_pop中，对tail的访问加锁是必要的保护。如果不加锁，try_pop和push可能会由不同的线程调用，导致对tail的访问出现竞争行为。</li><li>get_tail的调用在head_mutex保护范围中，这很重要。反之，先对tail加锁，获取到tail指针，再对head加锁，但此时可能无法顺利加锁，此时别的线程可能获取到锁进行try_pop，等到当前线程对head加锁的时候，head和tail都可能发生了改变，所以之前返回的tail指针可能不在是尾指针，甚至已经不是队列中的节点了。</li><li>并发性分析<ul><li>push在没有持锁的状态下，为新节点和新数据完成了内存分配。</li><li>try_pop只在互斥tail_mutex上短暂持锁，因此try_pop和push几乎可以并发执行。</li><li>队列节点通过智能指针的析构函数删除，在head_mutex的保护范围以外执行，如此可以提高try_pop的并发度，因为删除节点、返回数据之类耗时的操作在互斥外执行。</li></ul></li></ul><p><strong>等待数据弹出</strong></p><p>进一步实现wait_and_pop等功能。</p><p>接口设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadsafe_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>        std::shared_ptr&lt;T&gt; data;<br>        std::unique_ptr&lt;node&gt; next;<br>    &#125;;<br>    std::mutex head_mutex;<br>    std::unique_ptr&lt;node&gt; head;<br>    std::mutex tail_mutex;<br>    node* tail;<br>    std::condition_variable data_cond;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">threadsafe_queue</span>():<br>        <span class="hljs-built_in">head</span>(<span class="hljs-keyword">new</span> node),<span class="hljs-built_in">tail</span>(head.<span class="hljs-built_in">get</span>())<br>    &#123;&#125;<br>    <span class="hljs-built_in">threadsafe_queue</span>(<span class="hljs-type">const</span> threadsafe_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    threadsafe_queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> threadsafe_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T&amp; value)</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T&amp; value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>向队列中压入新节点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> threadsafe_queue&lt;T&gt;::<span class="hljs-built_in">push</span>(T new_value)<br>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">new_data</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        std::make_shared&lt;T&gt;(std::move(new_value)))</span></span>;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> node)</span></span>;<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">tail_lock</span><span class="hljs-params">(tail_mutex)</span></span>;<br>        tail-&gt;data=new_data;<br>        node* <span class="hljs-type">const</span> new_tail=p.<span class="hljs-built_in">get</span>();<br>        tail-&gt;next=std::<span class="hljs-built_in">move</span>(p);<br>        tail=new_tail;<br>    &#125;<br>    data_cond.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>wait_and_pop实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadsafe_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">node* <span class="hljs-title">get_tail</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">tail_lock</span><span class="hljs-params">(tail_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">pop_head</span><span class="hljs-params">()</span>   <span class="hljs-comment">// ⇽---  ①</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::unique_ptr&lt;node&gt; old_head=std::<span class="hljs-built_in">move</span>(head);<br>        head=std::<span class="hljs-built_in">move</span>(old_head-&gt;next);<br>        <span class="hljs-keyword">return</span> old_head;<br>    &#125;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">wait_for_data</span><span class="hljs-params">()</span>  <span class="hljs-comment">//  ⇽---  ②</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(head_mutex)</span></span>;<br>        data_cond.<span class="hljs-built_in">wait</span>(head_lock,[&amp;]&#123;<span class="hljs-keyword">return</span> head.<span class="hljs-built_in">get</span>()!=<span class="hljs-built_in">get_tail</span>();&#125;);<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(head_lock);  <span class="hljs-comment">//  ⇽---  ③</span><br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">wait_pop_head</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(wait_for_data())</span></span>;  <span class="hljs-comment">//  ⇽---  ④</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">wait_pop_head</span><span class="hljs-params">(T&amp; value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(wait_for_data())</span></span>;  <span class="hljs-comment">//  ⇽---  ⑤</span><br>        value=std::<span class="hljs-built_in">move</span>(*head-&gt;data);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::unique_ptr&lt;node&gt; <span class="hljs-type">const</span> old_head=<span class="hljs-built_in">wait_pop_head</span>();<br>        <span class="hljs-keyword">return</span> old_head-&gt;data;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T&amp; value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::unique_ptr&lt;node&gt; <span class="hljs-type">const</span> old_head=<span class="hljs-built_in">wait_pop_head</span>(value);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>try_pop和empty实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadsafe_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">try_pop_head</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">get</span>()==<span class="hljs-built_in">get_tail</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;node&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">try_pop_head</span><span class="hljs-params">(T&amp; value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span>(head.<span class="hljs-built_in">get</span>()==<span class="hljs-built_in">get_tail</span>())<br>        &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;node&gt;();<br>        &#125;<br>        value=std::<span class="hljs-built_in">move</span>(*head-&gt;data);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::unique_ptr&lt;node&gt; old_head=<span class="hljs-built_in">try_pop_head</span>();<br>        <span class="hljs-keyword">return</span> old_head?old_head-&gt;data:std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T&amp; value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::unique_ptr&lt;node&gt; <span class="hljs-type">const</span> old_head=<span class="hljs-built_in">try_pop_head</span>(value);<br>        <span class="hljs-keyword">return</span> old_head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">head_lock</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> (head.<span class="hljs-built_in">get</span>()==<span class="hljs-built_in">get_tail</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadsafe_queue</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>    &#123;<br>        std::shared_ptr&lt;T&gt; data;<br>        std::unique_ptr&lt;node&gt; next;<br>    &#125;;<br>    std::mutex head_mutex;<br>    std::unique_ptr&lt;node&gt; head;<br>    std::mutex tail_mutex;<br>    node* tail;<br>    std::condition_variable data_cond;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">threadsafe_queue</span>():<br>        <span class="hljs-built_in">head</span>(<span class="hljs-keyword">new</span> node),<span class="hljs-built_in">tail</span>(head.<span class="hljs-built_in">get</span>())<br>    &#123;&#125;<br><br>    <span class="hljs-built_in">threadsafe_queue</span>(<span class="hljs-type">const</span> threadsafe_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br>    threadsafe_queue&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> threadsafe_queue&amp; other)=<span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> old_head = <span class="hljs-built_in">try_pop_head</span>(); <br>        <span class="hljs-keyword">return</span> old_head ? old_head-&gt;data : std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> old_head = <span class="hljs-built_in">try_pop_head</span>(value);<br>        <span class="hljs-keyword">return</span> old_head.<span class="hljs-built_in">get</span>() != <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> old_head = <span class="hljs-built_in">wait_pop_head</span>();<br>        <span class="hljs-keyword">return</span> old_head ? old_head-&gt;data : std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> old_head = <span class="hljs-built_in">wait_pop_head</span>(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> new_data = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(std::<span class="hljs-built_in">move</span>(new_value));<br>        <span class="hljs-keyword">auto</span> p = std::<span class="hljs-built_in">make_unique</span>&lt;node&gt;();<br>        &#123;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(tail_mutex)</span></span>;<br>            tail-&gt;data = new_data;<br>            <span class="hljs-keyword">auto</span> new_tail = p.<span class="hljs-built_in">get</span>();<br>            tail-&gt;next = std::<span class="hljs-built_in">move</span>(p);<br>            tail = new_tail;<br>        &#125;<br>        <span class="hljs-comment">// 这里先解锁，再通知，可以避免唤醒之后，因为互斥没有解锁又重新阻塞。</span><br>        data_cond.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">get</span>() == <span class="hljs-built_in">get_tail</span>();<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">node* <span class="hljs-title">get_tail</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(tail_mutex)</span></span>;<br>        <span class="hljs-keyword">return</span> tail;<br>    &#125;<br><br>    <span class="hljs-comment">// 必须持有head_mutex</span><br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">pop_head</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> old_head = std::<span class="hljs-built_in">move</span>(head);<br>        head = std::<span class="hljs-built_in">move</span>(old_head-&gt;next);<br>        <span class="hljs-keyword">return</span> old_head; <br>    &#125;<br><br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">wait_for_data</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(head_mutex)</span></span>;<br>        data_cond.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>]&#123;<br>            <span class="hljs-keyword">return</span> head.<span class="hljs-built_in">get</span>() != <span class="hljs-built_in">get_tail</span>();<br>        &#125;);<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(lk);<br>    &#125;<br><br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">wait_pop_head</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> lk = <span class="hljs-built_in">wait_for_data</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br><br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">wait_pop_head</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> lk = <span class="hljs-built_in">wait_for_data</span>();<br>        <span class="hljs-comment">// 这里如果抛出异常 也不会污染队列</span><br>        value = std::<span class="hljs-built_in">move</span>(*head-&gt;data);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>(); <br>    &#125;<br><br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">try_pop_head</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span> (head.<span class="hljs-built_in">get</span>() == <span class="hljs-built_in">get_tail</span>()) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;node&gt;();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>();<br>    &#125;<br><br>    <span class="hljs-function">std::unique_ptr&lt;node&gt; <span class="hljs-title">try_pop_head</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(head_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span> (head.<span class="hljs-built_in">get</span>() == <span class="hljs-built_in">get_tail</span>()) &#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">unique_ptr</span>&lt;node&gt;();<br>        &#125;<br>        <span class="hljs-comment">// 同wait_pop_head</span><br>        value = std::<span class="hljs-built_in">move</span>(*head-&gt;data);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pop_head</span>(); <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>附上一个简单的测试代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><br><span class="hljs-comment">// 单线程测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">single_thread_test</span><span class="hljs-params">()</span> </span>&#123;<br>    threadsafe_queue&lt;<span class="hljs-type">int</span>&gt; queue;<br><br>    <span class="hljs-comment">// 测试初始状态</span><br>    <span class="hljs-built_in">assert</span>(queue.<span class="hljs-built_in">empty</span>());<br><br>    <span class="hljs-comment">// 测试push和try_pop</span><br>    queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">42</span>);<br>    <span class="hljs-built_in">assert</span>(!queue.<span class="hljs-built_in">empty</span>());<br>    <br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-type">bool</span> success = queue.<span class="hljs-built_in">try_pop</span>(val);<br>    <span class="hljs-built_in">assert</span>(success);<br>    <span class="hljs-built_in">assert</span>(val == <span class="hljs-number">42</span>);<br>    <span class="hljs-built_in">assert</span>(queue.<span class="hljs-built_in">empty</span>());<br><br>    <span class="hljs-comment">// 测试wait_and_pop</span><br>    <span class="hljs-function">std::thread <span class="hljs-title">consumer</span><span class="hljs-params">([&amp;]&#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> popped_val;</span></span><br><span class="hljs-params"><span class="hljs-function">        queue.wait_and_pop(popped_val);</span></span><br><span class="hljs-params"><span class="hljs-function">        assert(popped_val == <span class="hljs-number">100</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">10</span>));<br>    queue.<span class="hljs-built_in">push</span>(<span class="hljs-number">100</span>);<br>    consumer.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-built_in">assert</span>(queue.<span class="hljs-built_in">empty</span>());<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Single thread tests passed!\n&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 多线程测试</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">multi_thread_test</span><span class="hljs-params">()</span> </span>&#123;<br>    threadsafe_queue&lt;<span class="hljs-type">int</span>&gt; queue;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM_ITEMS = <span class="hljs-number">10000</span>;<br>    <span class="hljs-function">std::atomic&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">counter</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>    std::vector&lt;std::thread&gt; threads;<br><br>    <span class="hljs-comment">// 生产者线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>([&amp;] &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; NUM_ITEMS; ++j) &#123;<br>                queue.<span class="hljs-built_in">push</span>(j);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 消费者线程</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>        threads.<span class="hljs-built_in">emplace_back</span>([&amp;] &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; NUM_ITEMS; ++j) &#123;<br>                <span class="hljs-type">int</span> val;<br>                queue.<span class="hljs-built_in">wait_and_pop</span>(val);<br>                counter += val;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 等待所有线程完成</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : threads) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 验证结果（等差数列求和公式）</span><br>    <span class="hljs-type">int</span> expected = <span class="hljs-number">2</span> * (NUM_ITEMS<span class="hljs-number">-1</span>)*NUM_ITEMS/<span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">assert</span>(counter.<span class="hljs-built_in">load</span>() == expected);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Multi-thread tests passed!\n&quot;</span>;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">single_thread_test</span>();<br>    <span class="hljs-built_in">multi_thread_test</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个队列是无限队列。只要存在空闲内存，即便已存入的数据没有被移除，各个线程还是能持续往队列添加新数据。与之对应的是有限队列，其最大长度在创建之际就已固定。一旦有限队列容量已满，再试图向其压入数据就会失败，或者发生阻塞，直到有数据弹出而产生容纳空间为止。</p><h3 id="采用锁编写线程安全的查找表"><a href="#采用锁编写线程安全的查找表" class="headerlink" title="采用锁编写线程安全的查找表"></a>采用锁编写线程安全的查找表</h3><p>查找表的使用方式不同于栈容器或队列容器。栈容器和队列容器的几乎每项操作都会进行改动，或增加元素，或删减元素，查找表却鲜有改动。</p><p>从并发的角度考虑，<code>std::map&lt;&gt;</code> 接口中的最大问题是迭代器。有一种思路是通过迭代器访问容器内部，即便有其他线程访问（并改动）容器数据，迭代器所提供的访问依然安全。这虽然可行，但颇为棘手。要令迭代器正确运行，我们就必须面对诸多问题，这些问题处理起来相当复杂，例如一个线程要删除某个元素，而它却正被迭代器引用。考虑到 <code>std::map&lt;&gt;</code> 严重依赖迭代器（标准库中的其他关联容器亦然），所以我们自己设计接口。</p><p>查找表基本接口：</p><ul><li>增加配对的键&#x2F;值对</li><li>根据给定的键改变关联的值。</li><li>移除某个键及其关联的值。</li><li>根据给定的键获取关联值（若该键存在）。</li><li>一些针对容器自身的整体操作也十分有用，如检查容器是否为空、以“快照”方式复制所有键或全体键&#x2F;值对。</li></ul><p>为了实现更高的并发度，我们不能简单地对标准库提供的容器进行一层封装，这样并发度不高。考虑关联容器的几种实现方式：</p><ul><li>红黑树</li><li>有序数组</li><li>散列表</li></ul><p>红黑树每次查找或改动都要从根节点开始访问，必须逐层加锁解锁，提升不大；有序数组因为无法预知查找的目标的位置，所以必须对整个数组加锁，效率更差。所以我们选择散列表。</p><p>假定散列表具有固定数量的桶，每个键都属于一个桶，键本身的值和散列函数决定键具体属于哪个桶。这让我们可以安全地为每个桶使用独立的锁，从而增加并发度。问题是，我们需要一个针对键的散列函数。我们可以使用C++标准库提供的函数模板 <code>std::hash&lt;&gt;</code>。该函数已经具备针对基础类型的特化版本，如 <code>int</code> 和 <code>std::string</code> ，用户也可以方便地对其他类型的键进行特化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Value, <span class="hljs-keyword">typename</span> Hash = std::hash&lt;Key&gt;&gt;<br><span class="hljs-keyword">class</span> threadsafe_lookup_table &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">class</span> bucket_type &#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-keyword">using</span> bucket_value = std::pair&lt;Key, Value&gt;;<br>        <span class="hljs-keyword">using</span> bucket_data = std::list&lt;bucket_value&gt;;<br>        <span class="hljs-keyword">using</span> bucket_iterator = <span class="hljs-keyword">typename</span> bucket_data::iterator;<br>        bucket_data data;<br>        <span class="hljs-keyword">mutable</span> std::shared_mutex mtx;<br><br>        <span class="hljs-function">bucket_iterator <span class="hljs-title">find_entry_for</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find_if</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), [&amp;key](<span class="hljs-type">const</span> bucket_value&amp; item)&#123;<br>                <span class="hljs-keyword">return</span> item.first == key;<br>            &#125;);<br>        &#125;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function">Value <span class="hljs-title">value_for</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> Value&amp; default_value)</span> <span class="hljs-type">const</span> </span>&#123;<br>            <span class="hljs-function">std::shared_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx)</span></span>;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> found_entry = <span class="hljs-built_in">find_entry_for</span>(key);<br>            <span class="hljs-keyword">return</span> found_entry == data.<span class="hljs-built_in">end</span>() ? default_value : found_entry-&gt;second;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_or_update_mapping</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> Value&amp; value)</span> </span>&#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx)</span></span>;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> found_entry = <span class="hljs-built_in">find_entry_for</span>(key);<br>            <span class="hljs-keyword">if</span> (found_entry == data.<span class="hljs-built_in">end</span>()) &#123;<br>                data.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">bucket_value</span>(key, value));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                found_entry-&gt;second = value;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_mapping</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> </span>&#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx)</span></span>;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> found_entry = <span class="hljs-built_in">find_entry_for</span>(key);<br>            <span class="hljs-keyword">if</span> (found_entry != data.<span class="hljs-built_in">end</span>()) &#123;<br>                data.<span class="hljs-built_in">erase</span>(found_entry);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    std::vector&lt;std::unique_ptr&lt;bucket_type&gt;&gt; buckets;<br>    Hash hasher;<br><br>    <span class="hljs-function">bucket_type&amp; <span class="hljs-title">get_bucket</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> bucket_idx = <span class="hljs-built_in">hasher</span>(key) % buckets.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">return</span> *buckets[bucket_idx];<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> key_type = Key;<br>    <span class="hljs-keyword">using</span> mapped_type = Value;<br>    <span class="hljs-keyword">using</span> hash_type = Hash;<br>    <span class="hljs-built_in">threadsafe_lookup_table</span>(<span class="hljs-type">unsigned</span> num_buckets = <span class="hljs-number">19</span>, <span class="hljs-type">const</span> Hash&amp; hasher_ = <span class="hljs-built_in">Hash</span>())<br>        : <span class="hljs-built_in">buckets</span>(num_buckets), <span class="hljs-built_in">hasher</span>(hasher_) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; num_buckets; ++i) &#123;<br>            buckets[i].<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> bucket_type);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">threadsafe_lookup_table</span>(<span class="hljs-type">const</span> threadsafe_lookup_table&amp;) = <span class="hljs-keyword">delete</span>;<br>    threadsafe_lookup_table&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> threadsafe_lookup_table&amp;) = <span class="hljs-keyword">delete</span>;<br>    <br>    <span class="hljs-function">Value <span class="hljs-title">value_for</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> Value&amp; default_value = Value())</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_bucket</span>(key).<span class="hljs-built_in">value_for</span>(key, default_value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_or_update_mapping</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key, <span class="hljs-type">const</span> Value&amp; value)</span> </span>&#123;<br>        <span class="hljs-built_in">get_bucket</span>(key).<span class="hljs-built_in">add_or_update_mapping</span>(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_mapping</span><span class="hljs-params">(<span class="hljs-type">const</span> Key&amp; key)</span> </span>&#123;<br>        <span class="hljs-built_in">get_bucket</span>(key).<span class="hljs-built_in">remove_mapping</span>(key);<br>    &#125;<br><br>    <span class="hljs-function">std::map&lt;Key, Value&gt; <span class="hljs-title">get_map</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::vector&lt;std::unique_lock&lt;std::shared_mutex&gt;&gt; lks;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; bucket : buckets) &#123;<br>            lks.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">unique_lock</span>&lt;std::shared_mutex&gt;(bucket.mtx));<br>        &#125;<br>        std::map&lt;Key, Value&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; bucket : buckets) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = bucket.data.<span class="hljs-built_in">begin</span>(); it != bucket.data.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>                res.<span class="hljs-built_in">insert</span>(*it);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>因为桶的数量是固定的，因此对buckets的访问无需加锁。对于每个桶的访问，都由共享锁妥善的处理进行了保护。</li><li>异常安全：<ul><li>value_for不涉及改动，即使抛出异常，也不污染数据结构。</li><li>remove_mapping通过erase改动链表，该调用肯定不会抛出异常。</li><li>add_or_update_mapping如果执行add操作，进行push_back，该操作是异常安全的，即使抛出异常，也不会污染链表。如果执行update操作，进行赋值操作，该操作不是异常安全的，可能会使关联的值处于混合状态。可以将异常安全交给使用者处理。</li></ul></li></ul><h3 id="采用多种锁编写线程安全的链表"><a href="#采用多种锁编写线程安全的链表" class="headerlink" title="采用多种锁编写线程安全的链表"></a>采用多种锁编写线程安全的链表</h3><p>前面提到在多线程情况下，我们需要避免支持迭代器。为了提供迭代功能，可以考虑用成员函数的形式来实现，例如for_each。但是可能会导致死锁，因为如果for_each的存在要有意义，则其必须在持有内部锁的时候运行用户代码，而且还必须向用户传递每一项数据，而且数据应该按值传递。我们只有要求使用者来确保其提供的用户代码不会试图获取锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">threadsafe_list</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>        std::mutex mtx;<br>        std::shared_ptr&lt;T&gt; data;<br>        std::unique_ptr&lt;node&gt; next;<br>        <span class="hljs-built_in">node</span>() :<br>            <span class="hljs-built_in">next</span>()<br>        &#123; &#125;<br>        <span class="hljs-built_in">node</span>(<span class="hljs-type">const</span> T&amp; value):<br>            <span class="hljs-built_in">data</span>(std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(value)),<br>            <span class="hljs-built_in">next</span>()<br>        &#123; &#125;<br>    &#125;;<br>    node head;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">threadsafe_list</span>() = <span class="hljs-keyword">default</span>;<br>    ~<span class="hljs-built_in">threadsafe_list</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-built_in">threadsafe_list</span>(<span class="hljs-type">const</span> node&amp;) = <span class="hljs-keyword">delete</span>;<br>    threadsafe_list&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> threadsafe_list&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; value)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> new_node = std::<span class="hljs-built_in">make_unique</span>&lt;node&gt;(value);<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(head.mtx)</span></span>;<br>        new_node-&gt;next = std::<span class="hljs-built_in">move</span>(head.next);<br>        head.next = std::<span class="hljs-built_in">move</span>(new_node);<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Function&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">for_each</span><span class="hljs-params">(Function f)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur_node = &amp;head;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(head.mtx)</span></span>;<br>        <span class="hljs-keyword">while</span> (node* <span class="hljs-type">const</span> next = cur_node-&gt;next.<span class="hljs-built_in">get</span>()) &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">next_lk</span><span class="hljs-params">(next-&gt;mtx)</span></span>;<br>            lk.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-built_in">f</span>(*next-&gt;data);<br>            cur_node = next;<br>            lk = std::<span class="hljs-built_in">move</span>(next_lk);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Predicate&gt;<br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">find_first_if</span><span class="hljs-params">(Predicate p)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur_node = &amp;head;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(head.mtx)</span></span>;<br>        <span class="hljs-keyword">while</span> (node* <span class="hljs-type">const</span> next = cur_node-&gt;next.<span class="hljs-built_in">get</span>()) &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">next_lk</span><span class="hljs-params">(next-&gt;mtx)</span></span>;<br>            lk.<span class="hljs-built_in">unlock</span>();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">p</span>(*next-&gt;data)) &#123;<br>                <span class="hljs-keyword">return</span> next-&gt;data;<br>            &#125;<br>            cur_node = next;<br>            lk = std::<span class="hljs-built_in">move</span>(next_lk);<br>        &#125;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;T&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Predicate&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_if</span><span class="hljs-params">(Predicate p)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cur_node = &amp;head;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(head.mtx)</span></span>;<br>        <span class="hljs-keyword">while</span> (node* <span class="hljs-type">const</span> next = cur_node-&gt;next.<span class="hljs-built_in">get</span>()) &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">next_lk</span><span class="hljs-params">(next-&gt;mtx)</span></span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">p</span>(*next-&gt;data)) &#123;<br>                <span class="hljs-keyword">auto</span> old_next = std::<span class="hljs-built_in">move</span>(cur_node-&gt;next);<br>                cur_node-&gt;next = std::<span class="hljs-built_in">move</span>(next-&gt;next);<br>                next_lk.<span class="hljs-built_in">unlock</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                lk.<span class="hljs-built_in">unlock</span>();<br>                cur_node = next;<br>                lk = std::<span class="hljs-built_in">move</span>(next_lk);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上实现的核心思想是，按照链表中节点的前后顺序加锁，没有任何一个线程能够超越他人的处理节点，若一个线程需在某节点上耗费特别长的时间，那么其他线程在到达该节点时就不得不等待。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++并发编程实战Chapter4</title>
    <link href="/2025/01/26/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter4/"/>
    <url>/2025/01/26/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter4/</url>
    
    <content type="html"><![CDATA[<h1 id="4-并发操作的同步"><a href="#4-并发操作的同步" class="headerlink" title="4 并发操作的同步"></a>4 并发操作的同步</h1><h2 id="4-1-等待事件或等待其他条件"><a href="#4-1-等待事件或等待其他条件" class="headerlink" title="4.1 等待事件或等待其他条件"></a>4.1 等待事件或等待其他条件</h2><p>线程A需要等待线程B完成任务，有几种方式</p><ul><li>在共享数据内部维护一个标志（互斥保护），线程B完成后，设置该标志。</li></ul><p>​这种方法中线程A必须不断轮询检查标志。存在资源浪费。</p><ul><li>让线程A调用 <code>std::this_thread::sleep_for()</code> 函数，在各次检验之间短暂休眠。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> flag;<br>std::mutex m;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_for_flag</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-keyword">while</span>(!flag)<br>    &#123;<br>        lk.<span class="hljs-built_in">unlock</span>();   <br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));  <br>        lk.<span class="hljs-built_in">lock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​上述代码虽然效率有所提升，但是休眠时间的长短很难确定。如果时间过短，线程仍会频繁检查；时间过长，会导致延迟，任务已经完成但线程A还在休眠。对于实时应用，游戏等，不能接受。</p><ul><li>使用C++标准库的工具（优先采用）</li></ul><p>​最基本的方式是条件变量。当条件成立时，就通过该条件变量，通知所有等待的线程，将他们唤醒继续处理。</p><h3 id="4-1-1-凭借条件变量等待条件成立"><a href="#4-1-1-凭借条件变量等待条件成立" class="headerlink" title="4.1.1 凭借条件变量等待条件成立"></a>4.1.1 凭借条件变量等待条件成立</h3><p>C++标准库提供了条件变量的两种实现：std::condition_variable 和std::condition_variable_any。它们都在标准库的头文件<condition_variable>内声明。两者都需配合互斥，方能提供妥当的同步操作。std::condition_variable仅限于与std::mutex一起使用；然而，只要某一类型符合成为互斥的最低标准，足以充当互斥，std::condition_variable_any即可与之配合使用，因此它的后缀是“_any”。由于std::condition_variable_any更加通用，它可能产生额外开销，涉及其性能、自身的体积或系统资源等，因此std::condition_variable应予优先采用，除非有必要令程序更灵活。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mut;<br>std::queue&lt;data_chunk&gt; data_queue; <br>std::condition_variable data_cond;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">data_preparation_thread</span><span class="hljs-params">()</span>            <span class="hljs-comment">// 由线程B运行</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">more_data_to_prepare</span>())<br>    &#123;<br>        data_chunk <span class="hljs-type">const</span> data=<span class="hljs-built_in">prepare_data</span>();<br>        &#123;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;<br>            data_queue.<span class="hljs-built_in">push</span>(data); <br>        &#125;<br>        data_cond.<span class="hljs-built_in">notify_one</span>();   <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">data_processing_thread</span><span class="hljs-params">()</span>           <span class="hljs-comment">// 由线程A运行</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mut)</span></span>;   <br>        data_cond.<span class="hljs-built_in">wait</span>(<br>            lk,[]&#123;<span class="hljs-keyword">return</span> !data_queue.<span class="hljs-built_in">empty</span>();&#125;);   ⑤<br>        data_chunk data=data_queue.<span class="hljs-built_in">front</span>();<br>        data_queue.<span class="hljs-built_in">pop</span>();<br>        lk.<span class="hljs-built_in">unlock</span>();   <br>        <span class="hljs-built_in">process</span>(data);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">is_last_chunk</span>(data))<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>线程B解锁互斥后再通知线程A，这样线程A唤醒后无需等待互斥解锁，不会再次被阻塞</li><li>线程A在条件变量上调用wait，传入锁对象和一个lambda函数，用于表达需要等待成立的条件。只有条件成立，wait才会返回；否则，wait解锁互斥量，并阻塞线程。</li><li>线程B准备好数据后，通知线程A，A被唤醒后，首先获取互斥量，然后检查条件是否成立。</li><li>如果线程A重新获得互斥，并且查验条件，而这一行为却不是直接响应线程乙的通知，则称之为伪唤醒（spurious wake）。按照C++标准的规定，这种伪唤醒出现的数量和频率都不确定。因此，需要考虑检验函数是否有副作用。</li></ul><h3 id="4-1-2-利用条件变量构建线程安全的队列"><a href="#4-1-2-利用条件变量构建线程安全的队列" class="headerlink" title="4.1.2 利用条件变量构建线程安全的队列"></a>4.1.2 利用条件变量构建线程安全的队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadSafeQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadSafeQueue</span>() &#123; &#125; <br>    <span class="hljs-built_in">ThreadSafeQueue</span>(<span class="hljs-type">const</span> ThreadSafeQueue&amp; other) &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(other.mtx_)</span></span>;<br>        data_ = other.data_; <br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>        <span class="hljs-keyword">return</span> data_.<span class="hljs-built_in">empty</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T new_value)</span> </span>&#123;<br>        &#123;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>            data_.<span class="hljs-built_in">push</span>(new_value);<br>        &#125;    <br>        cond_.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">try_pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>        <span class="hljs-keyword">if</span> (data_.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        value = data_.<span class="hljs-built_in">front</span>();<br>        data_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">try_pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>        <span class="hljs-keyword">if</span> (data_.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;();<br>        <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(data_.<span class="hljs-built_in">front</span>());<br>        data_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_and_pop</span><span class="hljs-params">(T&amp; value)</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>        cond_.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>]&#123;<br>            <span class="hljs-keyword">return</span> !data_.<span class="hljs-built_in">empty</span>();<br>        &#125;);<br>        value = data_.<span class="hljs-built_in">front</span>();<br>        data_.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function">std::shared_ptr&lt;T&gt; <span class="hljs-title">wait_and_pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(mtx_)</span></span>;<br>        cond_.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>]&#123;<br>            <span class="hljs-keyword">return</span> !data_.<span class="hljs-built_in">empty</span>();<br>        &#125;);<br>        <span class="hljs-keyword">auto</span> res = std::<span class="hljs-built_in">make_shared</span>&lt;T&gt;(data_.<span class="hljs-built_in">front</span>());<br>        data_.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">mutable</span> std::mutex mtx_;<br>    std::condition_variable cond_;<br>    std::queue&lt;T&gt; data_;<br>&#125;;<br><br>ThreadSafeQueue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadFuncA</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; std::endl;<br>        q.<span class="hljs-built_in">push</span>(i);<br>        std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">milliseconds</span>(<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadFuncB</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        <span class="hljs-keyword">auto</span> value = q.<span class="hljs-built_in">wait_and_pop</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;, value = &quot;</span> &lt;&lt; *value &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">A</span><span class="hljs-params">(ThreadFuncA)</span></span>;<br>    <span class="hljs-built_in">ThreadFuncB</span>();<br>    A.<span class="hljs-built_in">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>因为互斥量会因为锁操作而变化，为了支持const对象，其必须用mutable修饰。</li></ul><h2 id="4-2-使用future等待一次性事件发生"><a href="#4-2-使用future等待一次性事件发生" class="headerlink" title="4.2 使用future等待一次性事件发生"></a>4.2 使用future等待一次性事件发生</h2><h3 id="4-2-1-从后台任务返回值"><a href="#4-2-1-从后台任务返回值" class="headerlink" title="4.2.1 从后台任务返回值"></a>4.2.1 从后台任务返回值</h3><p>如果并不急需线程运算的值，就可以使用 <code>std::async()</code> （函数模板，声明位于头文件  <code>&lt;future&gt;</code> 中）按异步方式启动任务。我们从 <code>std::async()</code> 函数处获得 <code>std::future</code> 对象（而非 <code>std::thread</code> 对象），运行的函数一旦完成，其返回值就由该对象最后持有。若要用到这个值，只需在 <code>future</code> 对象上调用<code>get()</code>，当前线程就会阻塞，以便 <code>future</code> 准备妥当并返回该值。</p><p>下面是一个最简单的例子，用 <code>std::future</code> 取得异步任务的函数返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_the_answer_to_ltuae</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_other_stuff</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; the_answer=std::<span class="hljs-built_in">async</span>(find_the_answer_to_ltuae);<br>    <span class="hljs-built_in">do_other_stuff</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;The answer is &quot;</span>&lt;&lt;the_answer.<span class="hljs-built_in">get</span>()&lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::async()</code> 可以接收附加参数，进而传递给任务函数作为参数，同 <code>std::thread</code> 的构造函数一致。</p><p>可以给 <code>std::async()</code> 补充一个参数，以指定采用哪种运行方式。参数的类型是 <code>std::launch</code>，其值可以是 <code>std::launch::deferred</code> 或 <code>std::launch::async</code> 。前者指定在当前线程上延后调用任务函数，等到在future上调用了 <code>wait()</code> 或 <code>get()</code> ，任务函数才会执行；后者指定必须另外开启专属的线程，在其上运行任务函数。该参数的值还可以是 <code>std::launch::deferred | std::launch::async</code> ，表示由 <code>std::async()</code> 的实现自行选择运行方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f6=std::<span class="hljs-built_in">async</span>(std::launch::async,<span class="hljs-built_in">Y</span>(),<span class="hljs-number">1.2</span>);    ⇽---  ①运行新线程<br><br><span class="hljs-keyword">auto</span> f7=std::<span class="hljs-built_in">async</span>(std::launch::deferred,baz,std::<span class="hljs-built_in">ref</span>(x));    ⇽---  ②在<span class="hljs-built_in">wait</span>()或<span class="hljs-built_in">get</span>()内部运行任务函数<br><span class="hljs-keyword">auto</span> f8=std::<span class="hljs-built_in">async</span>(    ⇽---  <br>   std::launch::deferred | std::launch::async,<br>   baz,std::<span class="hljs-built_in">ref</span>(x));<br><span class="hljs-keyword">auto</span> f9=std::<span class="hljs-built_in">async</span>(baz,std::<span class="hljs-built_in">ref</span>(x));     ⇽---  ③交由实现自行选择运行方式<br>f<span class="hljs-number">7.</span><span class="hljs-built_in">wait</span>();    ⇽---  ④前面②处的任务函数调用被延后，到这里才运行<br></code></pre></td></tr></table></figure><h3 id="4-2-2-关联future实例和任务"><a href="#4-2-2-关联future实例和任务" class="headerlink" title="4.2.2 关联future实例和任务"></a>4.2.2 关联future实例和任务</h3><p><code>std::packaged_task&lt;&gt;</code> 连结了future对象与函数（或可调用对象）。<code>std::packaged_task&lt;&gt;</code> 对象在执行任务时，会调用关联的函数（或可调用对象），把返回值保存为future的内部数据，并令future准备就绪。</p><p><code>std::packaged_task&lt;&gt;</code> 是类模板，其模板参数是函数签名。传入的函数必须与之相符（不必严格匹配，只要能够互相转换即可）。</p><p>类模板 <code>std::packaged_task&lt;&gt;</code> 具有成员函数 <code>get_future()</code> ，它返回<code>std::future&lt;&gt;</code> 实例，该future的特化类型取决于函数签名所指定的返回值。</p><p><code>std::packaged_task&lt;&gt;</code> 还具备函数调用操作符，它的参数取决于函数签名的参数列表。</p><p><code>std::packaged_task</code> 对象是可调用对象，我们可以直接调用，还可以将其包装在 <code>std::function</code> 对象内，当作线程函数传递给 <code>std::thread</code> 对象，也可以传递给需要可调用对象的函数。</p><p><strong>在线程间传递任务</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br>std::mutex m;<br>std::deque&lt;std::packaged_task&lt;<span class="hljs-type">void</span>()&gt;&gt; tasks;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">gui_shutdown_message_received</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_and_process_gui_message</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">gui_thread</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">gui_shutdown_message_received</span>()) <br>    &#123;<br>        <span class="hljs-built_in">get_and_process_gui_message</span>();<br>        std::packaged_task&lt;<span class="hljs-built_in">void</span>()&gt; task;<br>        &#123;<br>            <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;<br>            <span class="hljs-keyword">if</span>(tasks.<span class="hljs-built_in">empty</span>())   <br>                <span class="hljs-keyword">continue</span>;<br>            task=std::<span class="hljs-built_in">move</span>(tasks.<span class="hljs-built_in">front</span>());  <br>            tasks.<span class="hljs-built_in">pop_front</span>();<br>        &#125;<br>        <span class="hljs-built_in">task</span>();    <br>    &#125;<br>&#125;<br><span class="hljs-function">std::thread <span class="hljs-title">gui_bg_thread</span><span class="hljs-params">(gui_thread)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Func&gt;</span><br><span class="hljs-function">std::future&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">post_task_for_gui_thread</span><span class="hljs-params">(Func f)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">void</span><span class="hljs-params">()</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(f)</span></span>;   <br>    std::future&lt;<span class="hljs-type">void</span>&gt; res=task.<span class="hljs-built_in">get_future</span>();   <br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m)</span></span>;<br>    tasks.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(task));   <br>    <span class="hljs-keyword">return</span> res; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-3-创建-std-promise"><a href="#4-2-3-创建-std-promise" class="headerlink" title="4.2.3 创建 std::promise"></a>4.2.3 创建 <code>std::promise</code></h3><p><code>std::promise&lt;T&gt;</code> 给出了一种异步求值的方法（类型为T），某个<code>std::future&lt;T&gt;</code> 对象与结果关联，能延后读出需要求取的值。配对的std::promise和std::future可实现下面的工作机制：等待数据的线程在future上阻塞，而提供数据的线程利用相配的promise设定关联的值，使future准备就绪。</p><p>若需从给定的std::promise实例获取关联的std::future对象，调用前者的成员函数get_future()即可，这与std::packaged_task一样。promise的值通过成员函数set_value()设置，只要设置好，future即准备就绪，凭借它就能获取该值。如果std::promise在被销毁时仍未曾设置值，保存的数据则由异常代替。</p><h3 id="4-2-4-将异常保存到future中"><a href="#4-2-4-将异常保存到future中" class="headerlink" title="4.2.4 将异常保存到future中"></a>4.2.4 将异常保存到future中</h3><p><strong><code>std::async()</code></strong></p><p>若经由 <code>std::async()</code> 调用的函数抛出异常，会被保存到future中，代替本该设定的值，future进入就绪状态。等到其成员函数get被调用，异常被重新抛出。</p><p><strong><code>std::packaged_task</code></strong></p><p>同上。</p><p><strong><code>std::promise</code></strong></p><p>通过成员函数的显示调用实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> std::promise&lt;<span class="hljs-type">double</span>&gt; some_promise;<br><span class="hljs-keyword">try</span><br>&#123;<br>    some_promise.<span class="hljs-built_in">set_value</span>(<span class="hljs-built_in">calculate_value</span>());<br>&#125;<br><span class="hljs-built_in">catch</span>(...)<br>&#123;<br>    some_promise.<span class="hljs-built_in">set_exception</span>(std::<span class="hljs-built_in">current_exception</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>还有一种方式，通过直接销毁与future关联的promise对象或packaged_task对象。</p><h3 id="4-2-5-多个线程一起等待"><a href="#4-2-5-多个线程一起等待" class="headerlink" title="4.2.5 多个线程一起等待"></a>4.2.5 多个线程一起等待</h3><p>若我们在多个线程上访问同一个std::future对象，而不采取额外的同步措施，将引发数据竞争并导致未定义行为。</p><p>std::future仅能移动构造和移动赋值，所以归属权可在多个实例之间转移，但在相同时刻，只会有唯一一个future实例指向特定的异步结果；</p><p>std::shared_future的实例则能复制出副本，因此我们可以持有该类的多个对象，它们全指向同一异步任务的状态数据。</p><p><img src="/../images/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter4/image-20250129152205506.png"></p><p>向每个线程传递std::shared_future对象的副本，它们为各线程独自所有，并被视作局部变量。因此，这些副本就作为各线程的内部数据，由标准库正确地同步，可以安全地访问。</p><p>std::shared_future的实例依据std::future的实例构造而得，前者所指向的异步状态由后者决定。因为std::future对象独占异步状态，其归属权不为其他任何对象所共有，所以若要按默认方式构造std::shared_future对象，则须用std::move向其默认构造函数传递归属权，这使std::future变成空状态（empty state）。</p><p>std::future具有成员函数share()，直接创建新的std::shared_future对象，并向它转移归属权。</p><h2 id="4-3-限时等待"><a href="#4-3-限时等待" class="headerlink" title="4.3 限时等待"></a>4.3 限时等待</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++并发编程实战Chapter3</title>
    <link href="/2025/01/26/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter3/"/>
    <url>/2025/01/26/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter3/</url>
    
    <content type="html"><![CDATA[<h1 id="3-在线程间共享数据"><a href="#3-在线程间共享数据" class="headerlink" title="3 在线程间共享数据"></a>3 在线程间共享数据</h1><h2 id="3-1-线程间共享数据的问题"><a href="#3-1-线程间共享数据的问题" class="headerlink" title="3.1 线程间共享数据的问题"></a>3.1 线程间共享数据的问题</h2><div class="note note-primary">            <p>归根结底，多线程共享数据的问题多由数据改动引发。如果所有共享数据都是只读数据，就不会有问题。</p>          </div><p><strong>不变量(invariant)</strong></p><p>它是一个针对某一特定数据的断言，该断言总是成立的，例如“这个变量的值即为链表元素的数目”。数据更新往往会破坏这些不变量。</p><p>改动线程间的共享数据，可能导致不变量被破坏。例如对于双向链表，不变量就是如果A节点的next指针指向B节点，那么B节点的prev指针应该指向A节点。如果我们删除双向链表中的某个节点N，我们需要修改N节点前驱节点A的next指针和N节点后继节点的prev指针。当我们只修改了一个指针的时候，不变量即被破坏。</p><h3 id="3-1-1-条件竞争"><a href="#3-1-1-条件竞争" class="headerlink" title="3.1.1 条件竞争"></a>3.1.1 条件竞争</h3><p>在并发编程中，操作由两个或多个线程负责，它们争先让线程执行各自的操作，而结果取决于它们执行的相对次序，所有这种情况都是条件竞争。</p><ul><li>良性条件竞争：例如，两个线程向队列添加数据项以待处理，只要维持住系统的不变量，先添加哪个数据项通常并不重要。</li><li>恶行条件竞争：当条件竞争导致不变量被破坏时，才会产生问题，正如前面举例的双向链表。</li></ul><h3 id="3-1-2-防止恶性条件竞争"><a href="#3-1-2-防止恶性条件竞争" class="headerlink" title="3.1.2 防止恶性条件竞争"></a>3.1.2 防止恶性条件竞争</h3><p>几种防止恶性条件竞争的方法：</p><ol><li>采取保护措施包装数据结构，确保不变量被破坏时，中间状态只对执行改动的线程可见。在其他访问同一数据结构的线程的视角中，这种改动要么尚未开始，要么已经完成。</li><li>修改数据结构的设计及其不变量，由一连串不可拆分的改动完成数据变更，每个改动都维持不变量不被破坏。这通常被称为无锁编程，难以正确编写。</li><li>将修改数据结构当作事务（transaction）来处理，类似于数据库在一个事务内完成更新：把需要执行的数据读写操作视为一个完整序列，先用事务日志存储记录，再把序列当成单一步骤提交运行。若别的线程改动了数据而令提交无法完整执行，则事务重新开始。这称为软件事务内存（Software Transactional Memory，STM）。</li></ol><h2 id="3-2-用互斥保护共享数据"><a href="#3-2-用互斥保护共享数据" class="headerlink" title="3.2 用互斥保护共享数据"></a>3.2 用互斥保护共享数据</h2><p>标记访问该数据结构的所有代码，令各线程在其上相互排斥（mutually exclusive），只要有线程正在运行标记的代码，任何别的线程意图访问同一份数据，则必须等待，直到该线程完事。</p><p>C++线程库保证了，一旦有线程锁住了某个互斥，若其他线程试图再给它加锁，则须等待，直至最初成功加锁的线程把该互斥解锁。</p><h3 id="3-2-1"><a href="#3-2-1" class="headerlink" title="3.2.1"></a>3.2.1</h3><p>在C++中，通过构造std::mutex的实例来创建互斥，调用成员函数lock()对其加锁，调用unlock()解锁。</p><p>但更好的做法是运用RAII的手法，C++标准库提供了类模板std::lock_guard&lt;&gt;，针对互斥类融合实现了RAII手法：在构造时给互斥加锁，在析构时解锁，从而保证互斥总被正确解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br>std::list&lt;<span class="hljs-type">int</span>&gt; some_list;<br>std::mutex some_mutex;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_list</span><span class="hljs-params">(<span class="hljs-type">int</span> new_value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(some_mutex)</span></span>; <br>    some_list.<span class="hljs-built_in">push_back</span>(new_value);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">list_contains</span><span class="hljs-params">(<span class="hljs-type">int</span> value_to_find)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">guard</span><span class="hljs-params">(some_mutex)</span></span>;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find</span>(some_list.<span class="hljs-built_in">begin</span>(),some_list.<span class="hljs-built_in">end</span>(),value_to_find)<br>        != some_list.<span class="hljs-built_in">end</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>C++17引入了一个新特性，名为类模板参数推导（class template argument deduction），对于std::lock_guard&lt;&gt;这种简单的类模板，模板参数列表可以忽略。</p><p><strong>注意</strong></p><p>如果成员函数返回指针或引用，指向受保护的共享数据，那么即便成员函数全都按良好、有序的方式锁定互斥，仍然无济于事，因为保护已被打破，出现了大漏洞。只要存在任何能访问该指针和引用的代码，它就可以访问受保护的共享数据（也可以修改），而无须锁定互斥。所以，若利用互斥保护共享数据，则需谨慎设计程序接口，从而确保互斥已先行锁定，再对受保护的共享数据进行访问，并保证不留后门。</p><h3 id="3-2-2-组织和编排代码以保护共享数据"><a href="#3-2-2-组织和编排代码以保护共享数据" class="headerlink" title="3.2.2 组织和编排代码以保护共享数据"></a>3.2.2 组织和编排代码以保护共享数据</h3><p>有几种情况会导致保护失效：</p><ul><li>成员函数向调用者返回指向共享数据的指针或引用</li><li>若成员函数在自身内部调用了别的函数，我们也需要考虑向这些函数传递指针或引用是否安全。如果该函数将共享数据的地址存起来，等到脱离保护之后再去访问，可能会导致不良后果。</li></ul><p>本质上，上述问题是由于未能把所有访问共享数据的代码都标记为互斥。</p><div class="note note-primary">            <p>不得向锁所在的作用域之外传递指针和引用，指向受保护的共享数据，无论是通过函数返回值将它们保存到对外可见的内存，还是将它们作为参数传递给使用者提供的函数。</p>          </div><h3 id="3-2-3-发现接口固有的条件竞争"><a href="#3-2-3-发现接口固有的条件竞争" class="headerlink" title="3.2.3 发现接口固有的条件竞争"></a>3.2.3 发现接口固有的条件竞争</h3><p>考虑stack容器，在多线程环境下，其empty和size的结果不可信。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; s;<br><span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>()) <br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-type">const</span> value=s.<span class="hljs-built_in">top</span>();<br>    s.<span class="hljs-built_in">pop</span>();  <br>    <span class="hljs-built_in">do_something</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在if判断和访问栈顶元素之间，可能有别的线程弹出栈顶元素，导致栈空，从而引发未定义行为。</li><li>在top和pop之间，也存在条件竞争：两个线程都访问栈顶元素，然后出栈，会导致有一个元素被忽略掉了。</li></ul><p>为了解决第二个条件竞争，比较自然的想法是将top和pop合成为一个操作，但是这可能会导致异常不安全。当栈中存储的对象的拷贝构造函数发生错误的时候，可能无法正确获得其对象，但是该对象已经从栈上被弹出了。</p><p>消除条件竞争的方法：</p><ul><li>传入引用</li></ul><p>借一个外部变量接收栈容器弹出的元素，将指涉它的引用通过参数传入pop()调用。</p><p>问题：</p><p>这种方法要求栈容器存储的型别是可赋值的（assignable）。</p><ul><li>提供不抛出异常的拷贝构造函数，或不抛出异常的移动构造函数</li><li>返回指针，指向弹出的元素</li></ul><p>用智能指针管理是个不错的选择。避免了内存泄漏，并且由c++标准库负责管理内存。</p><h3 id="3-2-4-死锁"><a href="#3-2-4-死锁" class="headerlink" title="3.2.4 死锁"></a>3.2.4 死锁</h3><p>C++标准库提供了std::lock()函数。它可以同时锁住多个互斥，而没有发生死锁的风险。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">some_big_object</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(some_big_object&amp; lhs, some_big_object&amp; rhs)</span></span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    some_big_object some_detail;<br>    std::mutex m;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>(some_big_object <span class="hljs-type">const</span>&amp; sd):<span class="hljs-built_in">some_detail</span>(sd)&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(X&amp; lhs, X&amp; rhs)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(&amp;lhs==&amp;rhs)<br>            <span class="hljs-keyword">return</span>;<br>        std::<span class="hljs-built_in">lock</span>(lhs.m,rhs.m);   <br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_a</span><span class="hljs-params">(lhs.m, std::adopt_lock)</span></span>; <br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock_b</span><span class="hljs-params">(rhs.m, std::adopt_lock)</span></span>;<br>        <span class="hljs-built_in">swap</span>(lhs.some_detail,rhs.some_detail);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>std::lock</code> 锁定两个互斥，其语义是“全员共同成败”（all-or-nothing，或全部成功锁定，或没获取任何锁并抛出异常）。</p><p><code>std::adopt_lock</code> 指明互斥已经锁定，<code>std::lock_guard</code> 应该接收所有权，而不是试图加锁。</p><p>必须先判断交换对象是否是同一个对象，因为对某个 <code>std::mutex</code> 对象重复加锁将导致未定义行为（<code>std::recursive_mutex</code> 可以重复加锁）。</p><p>针对以上场景，C++17还进一步提供了新的RAII类模板std::scoped_lock&lt;&gt;。std:: scoped_lock&lt;&gt;和std::lock_guard&lt;&gt;完全等价，只不过前者是可变参数模板（variadic template），接收各种互斥型别作为模板参数列表，还以多个互斥对象作为构造函数的参数列表。下列代码中，传入构造函数的两个互斥都被加锁，机制与std::lock()函数相同，因此，当构造函数完成时，它们就都被锁定，而后，在析构函数内一起被解锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(X&amp; lhs, X&amp; rhs)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(&amp;lhs==&amp;rhs)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-function">std::scoped_lock <span class="hljs-title">guard</span><span class="hljs-params">(lhs.m,rhs.m)</span></span>;  <br>        <span class="hljs-built_in">swap</span>(lhs.some_detail,rhs.some_detail);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-5-防范死锁的补充原则"><a href="#3-2-5-防范死锁的补充原则" class="headerlink" title="3.2.5 防范死锁的补充原则"></a>3.2.5 防范死锁的补充原则</h3><p>没有涉及锁，也可能发生死锁现象。假定有两个线程，各自关联了std::thread实例，若它们同时在对方的std::thread实例上调用join()，就能制造出死锁现象却不涉及锁操作。</p><p>防范死锁的准则最终可归纳成一个思想：只要另一线程有可能正在等待当前线程，那么当前线程千万不能反过来等待它。</p><h4 id="1-避免嵌套锁"><a href="#1-避免嵌套锁" class="headerlink" title="1 避免嵌套锁"></a>1 避免嵌套锁</h4><p>假如已经持有锁，不要试图获取第二个锁。这样不会因为锁导致死锁，但是仍然有可能出现死锁现象（线程互相等待）。</p><p>如果一定要获取多个锁，最好采用 <code>std::lock</code> 或者 <code>std::scoped_lock</code>.</p><h4 id="2-一旦持锁，就须避免由用户提供的程序接口"><a href="#2-一旦持锁，就须避免由用户提供的程序接口" class="headerlink" title="2 一旦持锁，就须避免由用户提供的程序接口"></a>2 一旦持锁，就须避免由用户提供的程序接口</h4><p>因为我们不知道用户提供的接口会做什么，它可能要获取锁导致死锁。</p><h4 id="3-依从固定顺序获取锁"><a href="#3-依从固定顺序获取锁" class="headerlink" title="3 依从固定顺序获取锁"></a>3 依从固定顺序获取锁</h4><h4 id="4-按层级加锁"><a href="#4-按层级加锁" class="headerlink" title="4 按层级加锁"></a>4 按层级加锁</h4><p>可以实现一个 <code> hierarchical_mutex</code> 来按照层级加锁，只能按照层级从高到低的方向加锁。只要实现了 <code>lock(),unlock(),try_lock()</code> 三个成员函数，就可以和 <code>std::lock_guard</code> 配合使用。<code>try_lock()</code> : 若另一线程已在目标互斥上持有锁，则函数立即返回false，完全不等待。</p><p>为了存储当前层级编号，<code>hierarchical_mutex</code> 的实现使用了线程专属的局部变量（用 <code>thread_local</code> 修饰）。所有互斥的实例都能读取该变量，但它的值因不同线程而异。这使代码可以独立检测各线程的行为，各互斥都能判断是否允许当前线程对其加锁。</p><h4 id="5-将准则推广到锁操作以外"><a href="#5-将准则推广到锁操作以外" class="headerlink" title="5 将准则推广到锁操作以外"></a>5 将准则推广到锁操作以外</h4><p>对于线程互相等待的情况，也可以用上述的方法来解决。并且还可以让同一个函数启动全部线程，且汇合工作也由之负责。</p><h3 id="3-2-6-运用-std-unique-lock-灵活加锁"><a href="#3-2-6-运用-std-unique-lock-灵活加锁" class="headerlink" title="3.2.6 运用 std::unique_lock 灵活加锁"></a>3.2.6 运用 <code>std::unique_lock</code> 灵活加锁</h3><p>类模板 <code>std::unique_lock&lt;&gt;</code> 放宽了不变量的成立条件，它相较 <code>std::lock_guard&lt;&gt;</code> 更灵活一些。<code>std::unique_lock</code> 对象不一定始终占有与之关联的互斥。</p><p>其构造函数接收第二个参数：</p><ul><li>我们可以传入 <code>std::adopt_lock</code> 实例，借此指明 <code>std::unique_lock</code> 对象管理互斥上的锁</li><li>也可以传入 <code>std::defer_lock</code> 实例，从而使互斥在完成构造时处于无锁状态，等以后有需要时才在 <code>std::unique_lock</code> 对象（不是互斥对象）上调用 <code>lock()</code> 而获取锁，或把 <code>std::unique_lock</code> 对象交给 <code>std::lock()</code> 函数加锁。</li></ul><p><code>std::unique_lock</code> 占用更多的空间，也比 <code>std::lock_guard</code> 略慢。</p><h3 id="3-2-7-在不同作用域之间转移互斥归属权"><a href="#3-2-7-在不同作用域之间转移互斥归属权" class="headerlink" title="3.2.7 在不同作用域之间转移互斥归属权"></a>3.2.7 在不同作用域之间转移互斥归属权</h3><p><code>std::unique_lock</code> 实例不占有与之关联的互斥，所以随着其实例的转移，互斥的归属权可以在多个 <code>std::unique_lock</code> 实例之间转移。</p><p><code>std::unique_lock</code> 属于可移动却不可复制的型别。</p><p>转移有一种用途：准许函数锁定互斥，然后把互斥的归属权转移给函数调用者，好让他在同一个锁的保护下执行其他操作。</p><p><code>std::unique_lock</code> 类十分灵活，允许它的实例在被销毁前解锁。其成员函数<code>unlock()</code> 负责解锁操作，这与互斥一致。</p><h3 id="3-2-8-按适合的粒度加锁"><a href="#3-2-8-按适合的粒度加锁" class="headerlink" title="3.2.8 按适合的粒度加锁"></a>3.2.8 按适合的粒度加锁</h3><h2 id="3-3-保护共享数据的其他工具"><a href="#3-3-保护共享数据的其他工具" class="headerlink" title="3.3 保护共享数据的其他工具"></a>3.3 保护共享数据的其他工具</h2><h3 id="3-3-1-在初始化过程中保护共享数据"><a href="#3-3-1-在初始化过程中保护共享数据" class="headerlink" title="3.3.1 在初始化过程中保护共享数据"></a>3.3.1 在初始化过程中保护共享数据</h3><p>假设我们需要某个共享数据，而它创建起来开销不菲。因为创建它可能需要建立数据库连接或分配大量内存，所以等到必要时才真正着手创建。这种方式称为延迟初始化（lazy initialization），常见于单线程代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::shared_ptr&lt;some_resource&gt; resource_ptr;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!resource_ptr)<br>    &#123;<br>        resource_ptr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> some_resource);<br>    &#125;<br>    resource_ptr-&gt;<span class="hljs-built_in">do_something</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>若将上述代码转为多线程形式，假设数据本身线程安全。那么仅需要对指针进行保护。最简单的方式如下所示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::shared_ptr&lt;some_resource&gt; resource_ptr;<br>std::mutex resource_mutex;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(resource_mutex)</span></span>; <span class="hljs-comment">// 此处，全部线程都被迫循序运行</span><br>    <span class="hljs-keyword">if</span>(!resource_ptr)<br>    &#123;<br>        resource_ptr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> some_resource);  <br>    &#125;<br>    lk.<span class="hljs-built_in">unlock</span>();<br>    resource_ptr-&gt;<span class="hljs-built_in">do_something</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式的问题是，所有线程都必须依次运行，并且每次都要进行加锁操作，增加了不必要的开销。</p><p>为了改进上述方法，提出了双重检验锁定模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">undefined_behaviour_with_double_checked_locking</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(!resource_ptr)    ⇽---  ①<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(resource_mutex)</span></span>;<br>        <span class="hljs-keyword">if</span>(!resource_ptr)    ⇽---  ②<br>        &#123;<br>            resource_ptr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> some_resource);    ⇽---  ③<br>        &#125;<br>    &#125;<br>    resource_ptr-&gt;<span class="hljs-built_in">do_something</span>();    ⇽---  ④<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，这种方法可能引发恶性条件竞争。当前线程在锁保护范围外读取指针①，而对方线程却可能先获取锁，顺利进入锁保护范围内执行写操作③，因此读写操作没有同步，产生了条件竞争，既涉及指针本身，还涉及其指向的对象。尽管当前线程能够看见其他线程写入指针，却有可能无视新实例some_resource的创建，结果do_something()的调用就会对不正确的值进行操作④。</p><p>C++标准库中提供了std::once_flag类和std:: call_once()函数，以专门处理该情况。所有线程共同调用std::call_once()函数，从而确保在该调用返回时， 指针初始化由其中某线程安全且唯一地完成（通过适合的同步机制）。必要的同步数据则由std::once_flag实例存储，每个std::once_flag实例对应一次不同的初始化。相比显式使用互斥，std::call_once()函数的额外开销往往更低，特别是在初始化已经完成的情况下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::shared_ptr&lt;some_resource&gt; resource_ptr;<br>std::once_flag resource_flag;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_resource</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    resource_ptr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> some_resource);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">call_once</span>(resource_flag,init_resource);<br>    resource_ptr-&gt;<span class="hljs-built_in">do_something</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>在类中延迟初始化成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    connection_info connection_details;<br>    connection_handle connection;<br>    std::once_flag connection_init_flag;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open_connection</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        connection=connection_manager.<span class="hljs-built_in">open</span>(connection_details);<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>(connection_info <span class="hljs-type">const</span>&amp; connection_details_):<br>       <span class="hljs-built_in">connection_details</span>(connection_details_)<br>    &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send_data</span><span class="hljs-params">(data_packet <span class="hljs-type">const</span>&amp; data)</span>    ⇽---  ①</span><br><span class="hljs-function">    </span>&#123;<br>        std::<span class="hljs-built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="hljs-keyword">this</span>);    ⇽---  ②<br>        connection.<span class="hljs-built_in">send_data</span>(data);<br>    &#125;<br>    <span class="hljs-function">data_packet <span class="hljs-title">receive_data</span><span class="hljs-params">()</span>    ⇽---  ③</span><br><span class="hljs-function">    </span>&#123;<br>        std::<span class="hljs-built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="hljs-keyword">this</span>);    ⇽---  ②<br>        <span class="hljs-keyword">return</span> connection.<span class="hljs-built_in">receive_data</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>std::once_flag的实例既不可复制也不可移动，这与std::mutex类似。</p><p>C++11规定静态局部变量的初始化只会在某一线程上单独发生，在初始化完成之前，其他线程不会越过静态数据的声明而继续运行。某些类的代码只需用到唯一一个全局实例，这种情形可用以下方法代替std::call_once()：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_class</span>;<br><span class="hljs-function">my_class&amp; <span class="hljs-title">get_my_class_instance</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> my_class instance;  <br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-2-保护甚少更新的数据结构"><a href="#3-3-2-保护甚少更新的数据结构" class="headerlink" title="3.3.2 保护甚少更新的数据结构"></a>3.3.2 保护甚少更新的数据结构</h3><p>考虑一个存储着DNS条目的缓存表，它将域名解释成对应的IP地址。给定的DNS条目通常在很长时间内都不会变化——在许多情况下，DNS条目保持多年不变。尽管，随着用户访问不同网站，缓存表会不时加入新条目，但在很大程度上，数据在整个生命期内将保持不变。为了判断数据是否有效，必须定期查验缓存表；只要细节有所改动，就需要进行更新。</p><p>若采用std::mutex保护数据结构，则过于严苛，原因是即便没发生改动，它照样会禁止并发访问。我们需在这里采用新类型的互斥。由于新的互斥具有两种不同的使用方式，因此通常被称为读写互斥：允许单独一个“写线程”进行完全排他的访问，也允许多个“读线程”共享数据或并发访问。</p><ul><li>C++17标准库提供了两种新的互斥：std::shared_mutex和std::shared_timed_mutex。</li><li>C++14标准库只有std::shared_timed_mutex</li><li>C++11标准库都没有。</li></ul><p>可以用 <code>std::shared_mutex</code> 来进行这种同步操作。</p><p>对于写操作：用 <code>std::lock_guard</code> 或者 <code>std::unique_lock</code> 来进行锁定，保证访问的排他性。</p><p>对于读操作：用 <code>std::shared_lock</code> 实现共享访问。</p><p>共享锁仅有一个限制，即假设它已被某些线程所持有，若别的线程试图获取排他锁，就会发生阻塞，直到那些线程全都释放该共享锁。反之，如果任一线程持有排他锁，那么其他线程全都无法获取共享锁或排他锁，直到持锁线程将排他锁释放为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;shared_mutex&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dns_entry</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">dns_cache</span><br>&#123;<br>    std::map&lt;std::string,dns_entry&gt; entries;<br>    <span class="hljs-keyword">mutable</span> std::shared_mutex entry_mutex;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">dns_entry <span class="hljs-title">find_entry</span><span class="hljs-params">(std::string <span class="hljs-type">const</span>&amp; domain)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::shared_lock&lt;std::shared_mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(entry_mutex)</span></span>; <br>        std::map&lt;std::string,dns_entry&gt;::const_iterator <span class="hljs-type">const</span> it=<br>            entries.<span class="hljs-built_in">find</span>(domain);<br>        <span class="hljs-keyword">return</span> (it==entries.<span class="hljs-built_in">end</span>())?<span class="hljs-built_in">dns_entry</span>():it-&gt;second;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update_or_add_entry</span><span class="hljs-params">(std::string <span class="hljs-type">const</span>&amp; domain,</span></span><br><span class="hljs-params"><span class="hljs-function">                             dns_entry <span class="hljs-type">const</span>&amp; dns_details)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::lock_guard&lt;std::shared_mutex&gt;<span class="hljs-built_in">lk</span>(entry_mutex);<br>        entries[domain]=dns_details;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-递归加锁"><a href="#3-3-3-递归加锁" class="headerlink" title="3.3.3 递归加锁"></a>3.3.3 递归加锁</h3><p>假如线程已经持有某个std::mutex实例，试图再次对其重新加锁就会出错，将导致未定义行为。</p><p>但在某些场景中，确有需要让线程在同一互斥上多次重复加锁，而无须解锁。C++标准库为此提供了std::recursive_mutex，其工作方式与std::mutex相似，不同之处是，其允许同一线程对某互斥的同一实例多次加锁。我们必须先释放全部的锁，才可以让另一个线程锁住该互斥。例如，若我们对它调用了3次lock()，就必须调用3次unlock()。</p><p>若要设计一个类以支持多线程并发访问，它就需包含互斥来保护数据成员，递归互斥常常用于这种情形。每个公有函数都需先锁住互斥，然后才进行操作，最后解锁互斥。但有时在某些操作过程中，公有函数需要调用另一公有函数。在这种情况下，后者将同样试图锁住互斥，如果采用std::mutex便会导致未定义行为。有一种“快刀斩乱麻”的解决方法：用递归互斥代替普通互斥。这容许第二个公有函数成功地对递归互斥加锁，因此函数可以顺利地执行下去。</p><p>上述方法不推荐。当以上类型持有锁的时候，其不变量往往会被破坏。通常可以采取更好的方法：根据这两个公有函数的共同部分，提取出一个新的私有函数，新函数由这两个公有函数调用，而它假定互斥已经被锁住，遂无须重复加锁。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++并发编程实战Chapter2</title>
    <link href="/2025/01/24/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter2/"/>
    <url>/2025/01/24/C-C-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98Chapter2/</url>
    
    <content type="html"><![CDATA[<h1 id="2-线程管控"><a href="#2-线程管控" class="headerlink" title="2 线程管控"></a>2 线程管控</h1><h2 id="2-1-线程的基本管控"><a href="#2-1-线程的基本管控" class="headerlink" title="2.1 线程的基本管控"></a>2.1 线程的基本管控</h2><p>每个C++程序都含有至少一个线程，即运行main()的线程，它由C++运行时（C++ runtime）系统启动。随后，程序就可以发起更多线程，它们以别的函数作为入口（entry point）。这些新线程连同起始线程并发运行。当main()返回时，程序就会退出；同样，当入口函数返回时，对应的线程随之终结。</p><h3 id="2-1-1-发起线程"><a href="#2-1-1-发起线程" class="headerlink" title="2.1.1 发起线程"></a>2.1.1 发起线程</h3><p>线程通过构建 <code>std::thread</code> 对象启动，任何可调用类型都可以作为参数传递给该对象的构造函数。</p><p>如果在 <code>std::thread</code> 对象销毁的时候还没有决定汇合还是分离线程，那么析构函数会终止掉整个程序（需要注意，线程是否结束和该线程对象是否销毁没有关系，线程可能在决定汇合或者分离很久之前就已经结束运行，也可能在分离之后很久才结束运行）。</p><p><strong>保证线程访问的外部数据有效</strong></p><p>如果程序选择分离线程，且线程持有指针或者引用指向主线程的局部变量，如果此时主线程退出，子线程还在继续运行，会导致悬空指针or悬空引用问题。</p><p>解决方式：</p><ul><li>令线程函数完全自含（self-contained），将数据复制到新线程内部，而不是共享数据。</li><li>汇合新线程</li><li>也可以使用智能指针传递参数，这样可以确保局部变量在使用期间不会被销毁掉。</li></ul><h3 id="2-1-2-等待线程完成"><a href="#2-1-2-等待线程完成" class="headerlink" title="2.1.2 等待线程完成"></a>2.1.2 等待线程完成</h3><p>若需等待线程完成，可以在与之关联的std::thread实例上，通过调用成员函数join()实现。</p><p>只要调用了join()，隶属于该线程的任何存储空间即会因此清除，std::thread对象遂不再关联到已结束的线程。事实上，它与任何线程均无关联。<strong>对于某个给定的线程，join()仅能调用一次；只要std::thread对象曾经调用过join()，线程就不再可汇合（joinable），成员函数joinable()将返回false。</strong></p><h3 id="2-1-3-在出现异常的情况下等待"><a href="#2-1-3-在出现异常的情况下等待" class="headerlink" title="2.1.3 在出现异常的情况下等待"></a>2.1.3 在出现异常的情况下等待</h3><p>这个问题的本质其实是，如果要汇合线程，需要保证所有可能的退出路径都汇合线程。比较理想的做法是采用RAII思想，设计一个thread_guard类，在其析构函数中调用join.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_guard</span><br>&#123;<br>    std::thread&amp; t;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread_guard</span><span class="hljs-params">(std::thread&amp; t_)</span>:</span><br><span class="hljs-function">        t(t_)</span><br><span class="hljs-function">    &#123;</span>&#125;<br>    ~<span class="hljs-built_in">thread_guard</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(t.<span class="hljs-built_in">joinable</span>())   <br>        &#123;<br>            t.<span class="hljs-built_in">join</span>(); <br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">thread_guard</span>(thread_guard <span class="hljs-type">const</span>&amp;)=<span class="hljs-keyword">delete</span>;  <br>    thread_guard&amp; <span class="hljs-keyword">operator</span>=(thread_guard <span class="hljs-type">const</span>&amp;)=<span class="hljs-keyword">delete</span>;<br>&#125;;   <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">func</span>;    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> some_local_state=<span class="hljs-number">0</span>;<br>    <span class="hljs-function">func <span class="hljs-title">my_func</span><span class="hljs-params">(some_local_state)</span></span>;<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(my_func)</span></span>;<br>    <span class="hljs-function">thread_guard <span class="hljs-title">g</span><span class="hljs-params">(t)</span></span>;<br>    <span class="hljs-built_in">do_something_in_current_thread</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，在 <code>f</code> 退出之前，会按照构建的逆序，销毁局部对象，因此会首先销毁thread_guard对象。</p><h3 id="2-1-4-在后台运行线程"><a href="#2-1-4-在后台运行线程" class="headerlink" title="2.1.4 在后台运行线程"></a>2.1.4 在后台运行线程</h3><p>调用std::thread对象的成员函数detach()，会令线程在后台运行，遂无法与之直接通信。假若线程被分离，就无法等待它完结，也不可能获得与它关联的std::thread对象，因而无法汇合该线程。</p><p>然而分离的线程确实仍在后台运行，其归属权和控制权都转移给C++运行时库（runtime library，又名运行库），由此保证，一旦线程退出，与之关联的资源都会被正确回收。</p><p>UNIX操作系统中，有些进程叫作守护进程（daemon process），它们在后台运行且没有对外的用户界面；沿袭这一概念，分离出去的线程常常被称为守护线程（daemon thread）。这种线程往往长时间运行。几乎在应用程序的整个生存期内，它们都一直运行，以执行后台任务，如文件系统监控、从对象缓存中清除无用数据项、优化数据结构等。</p><p>不能凭空调用detach方法，必须确保该对象存在与其关联的线程。<strong>只有当t.joinable()返回true时，我们才能调用t.detach()。</strong></p><h2 id="2-2-向线程函数传递参数"><a href="#2-2-向线程函数传递参数" class="headerlink" title="2.2 向线程函数传递参数"></a>2.2 向线程函数传递参数</h2><p>若需向新线程上的函数或可调用对象传递参数，方法相当简单，直接向std::thread的构造函数增添更多参数即可。</p><p>线程具有内部存储空间，参数会按照默认方式先复制到该处，新创建的执行线程才能直接访问它们。然后，这些副本被当成临时变量，以右值形式传给新线程上的函数或可调用对象。即便函数的相关参数按设想应该是引用，上述过程依然会发生。</p><p>如果线程函数的参数是一个非常量引用，代码会无法通过编译，解决办法是用 <code>std::ref</code>.</p><p>对于移动操作来说，资源所有权会先转移到线程的内部存储空间，然后再转移给线程函数。</p><h2 id="2-3-移交线程归属权"><a href="#2-3-移交线程归属权" class="headerlink" title="2.3 移交线程归属权"></a>2.3 移交线程归属权</h2><p><code>std::thread</code> 拥有其所关联的线程，支持移动语义。</p><p>我们可以修改上面 <code>thread_guard</code> 类的代码得到 <code>scoped_thread</code> 类，该类掌管线程，防止出现 <code>thread_guard</code> 对象的生命期超出其管控的线程，导致不良后果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">scoped_thread</span><br>&#123;<br>    std::thread t;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">scoped_thread</span><span class="hljs-params">(std::thread t_)</span>: </span><br><span class="hljs-function">        t(std::move(t_))</span><br><span class="hljs-function">    &#123;</span><br>        <span class="hljs-keyword">if</span>(!t.<span class="hljs-built_in">joinable</span>())  <br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No thread&quot;</span>);<br>    &#125;<br>    ~<span class="hljs-built_in">scoped_thread</span>()<br>    &#123;<br>        t.<span class="hljs-built_in">join</span>();   <br>    &#125;<br>    <span class="hljs-built_in">scoped_thread</span>(scoped_thread <span class="hljs-type">const</span>&amp;)=<span class="hljs-keyword">delete</span>;<br>    scoped_thread&amp; <span class="hljs-keyword">operator</span>=(scoped_thread <span class="hljs-type">const</span>&amp;)=<span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-4-在运行时选择线程数量"><a href="#2-4-在运行时选择线程数量" class="headerlink" title="2.4 在运行时选择线程数量"></a>2.4 在运行时选择线程数量</h2><p>C++标准库的std::thread::hardware_concurrency()函数，它的返回值是一个指标，表示程序在各次运行中可真正并发的线程数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; thread::<span class="hljs-built_in">hardware_concurrency</span>() &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 在我的电脑上 返回值是16</span><br></code></pre></td></tr></table></figure><h2 id="2-5-识别线程"><a href="#2-5-识别线程" class="headerlink" title="2.5 识别线程"></a>2.5 识别线程</h2><p>线程ID所属型别是std::thread::id，它有两种获取方法：</p><ul><li>在与线程关联的std::thread对象上调用成员函数get_id()，即可得到该线程的ID。如果std::thread对象没有关联任何执行线程，调用get_id()则会返回一个std::thread::id对象，它按默认构造方式生成，表示“线程不存在”。</li><li>当前线程的ID可以通过调用std::this_thread::get_id()获得，函数定义位于头文件 <code>&lt;thread</code> 内。</li></ul><p>C++标准库容许我们随意判断两个线程ID是否相同，没有任何限制；std::thread::id型别具备全套完整的比较运算符，比较运算符就所有不相等的值确立了全序（total order）关系。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 21</title>
    <link href="/2024/11/22/OS-Three-Easy-Pieces-Chapter-21/"/>
    <url>/2024/11/22/OS-Three-Easy-Pieces-Chapter-21/</url>
    
    <content type="html"><![CDATA[<h1 id="Beyond-Physical-Memory-Mechanisms"><a href="#Beyond-Physical-Memory-Mechanisms" class="headerlink" title="Beyond Physical Memory: Mechanisms"></a>Beyond Physical Memory: Mechanisms</h1><p>如果某个进程的虚拟地址空间太大，或者整个系统所有进程的所有虚拟地址空间之和无法一次性放到物理内存中，操作系统通常需要将一些当前不常用的地址空间换出到硬盘中。</p><h2 id="1-Swap-Space"><a href="#1-Swap-Space" class="headerlink" title="1 Swap Space"></a>1 Swap Space</h2><p>磁盘中需要有一个交换区，用于和内存交换内存页。OS需要记录每个换出页的磁盘地址。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-21/image-20241122152725104.png"></p><h2 id="2-The-Present-Bit"><a href="#2-The-Present-Bit" class="headerlink" title="2 The Present Bit"></a>2 The Present Bit</h2><p>常规的地址转换过程：</p><p>进程提供虚拟内存地址</p><ul><li>TLB hit：取得物理页号</li><li>TLB miss<ul><li>查找页表，取得物理页号</li><li>更新TLB</li><li>重新执行指令</li></ul></li></ul><p>为了支持swap，页表项中需要增加一个<strong>present bit</strong>，用来指出当前页是否在内存中。</p><p>如果尝试访问某个当前不在内存中的内存页，会触发<strong>page fault</strong>异常，之后操作系统执行page-fault handler来处理。</p><h2 id="3-The-Page-Fault"><a href="#3-The-Page-Fault" class="headerlink" title="3 The Page Fault"></a>3 The Page Fault</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 20</title>
    <link href="/2024/11/22/OS-Three-Easy-Pieces-Chapter-20/"/>
    <url>/2024/11/22/OS-Three-Easy-Pieces-Chapter-20/</url>
    
    <content type="html"><![CDATA[<h1 id="Paging-Smaller-Tables"><a href="#Paging-Smaller-Tables" class="headerlink" title="Paging: Smaller Tables"></a>Paging: Smaller Tables</h1><p>基本的页式内存存在的一个问题就是页表占据的空间太大了。</p><h2 id="1-Simple-Solution-Bigger-Pages"><a href="#1-Simple-Solution-Bigger-Pages" class="headerlink" title="1 Simple Solution: Bigger Pages"></a>1 Simple Solution: Bigger Pages</h2><p>最简单的方法就是使用更大的页，这样可以减少页表项的个数，从而减少页表的大小。但是这种方法会导致内部内存碎片。</p><h2 id="2-Hybrid-Approach-Paging-and-Segments"><a href="#2-Hybrid-Approach-Paging-and-Segments" class="headerlink" title="2 Hybrid Approach: Paging and Segments"></a>2 Hybrid Approach: Paging and Segments</h2><p>段页式内存，结合段式内存和页式内存。每个段由一对base&#x2F;bound寄存器管理。base寄存器指出该段页表的物理地址，bound寄存器指出该页表的结束地址。这样，当一个段只有很少的页的时候，页表只有几个页表项，节省了空间。但是，因为每个段的页表还是线性的，如果某个段的内存很稀疏，我们仍然需要为所有中间的没有使用的页分配页表项。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-20/image-20241122143620252-1732257380904-1.png"></p><h2 id="3-Multi-level-Page-Tables"><a href="#3-Multi-level-Page-Tables" class="headerlink" title="3 Multi-level Page Tables"></a>3 Multi-level Page Tables</h2><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-20/image-20241122144339431.png"></p><p>传统页表最本质的问题是，我们很难在内存中找出一大块连续的内存用来存放页表项，并且这些页表项中有很多是无效的。多级页表最本质的思想就是页表按页来管理，如果页表中某页的所有页表项都是无效的，那么可以不分配页表的该页。这样就可以节省很多空间，如上图所示。</p><p>多级页表以时间换取空间。每次TLB miss的时候，为了完成地址转换，我们需要额外的内存访问去获取相应的页表项。而且，多级页表增加了复杂性。</p><h2 id="4-Inverted-Page-Tables"><a href="#4-Inverted-Page-Tables" class="headerlink" title="4 Inverted Page Tables"></a>4 Inverted Page Tables</h2><p>我们也可以反转页表，即通过物理页号去找对应的进程的虚拟页号。这样，整个系统只需要一个页表即可。为了完成地址转换，如果需要线性扫描整个页表，时间开销太大了，可以使用哈希表来管理。</p><h2 id="5-Swapping-the-Page-Tables-to-Disk"><a href="#5-Swapping-the-Page-Tables-to-Disk" class="headerlink" title="5 Swapping the Page Tables to Disk"></a>5 Swapping the Page Tables to Disk</h2><p>页表仍然有可能太大导致无法一次性放入内存中，有些系统将页表放在内核虚拟内存中，允许操作系统将页表换出到磁盘中。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 19</title>
    <link href="/2024/11/15/OS-Three-Easy-Pieces-Chapter-19/"/>
    <url>/2024/11/15/OS-Three-Easy-Pieces-Chapter-19/</url>
    
    <content type="html"><![CDATA[<h1 id="Paging-Faster-Translations-TLBs"><a href="#Paging-Faster-Translations-TLBs" class="headerlink" title="Paging: Faster Translations (TLBs)"></a>Paging: Faster Translations (TLBs)</h1><p>为了加速内存访问，OS需要硬件的帮助：<strong>translation-lookaside buffer（TLB）</strong>。TLB其实就是经常访问的PTE的硬件缓存。在每次访存之前，硬件首先去TLB中查看指定的PTE是否存在，如果存在，就不需要去内存中查找对应的PTE了。</p><h2 id="1-TLB-Basic-Algorithm"><a href="#1-TLB-Basic-Algorithm" class="headerlink" title="1 TLB Basic Algorithm"></a>1 TLB Basic Algorithm</h2><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-19/image-20241115164628041.png"></p><h2 id="2-Who-Handles-The-TLB-Miss"><a href="#2-Who-Handles-The-TLB-Miss" class="headerlink" title="2 Who Handles The TLB Miss"></a>2 Who Handles The TLB Miss</h2><p><strong>硬件处理</strong></p><p>由硬件负责更新TLB。</p><p><strong>软件处理（OS）</strong></p><p>由OS负责更新TLB。当遇到TLB miss的时候，硬件只需要发出一个异常，然后跳转到对应的异常处理程序进行处理即可。</p><p>注意事项：</p><ul><li>这种异常和系统调用不一样，系统调用返回下一条指令的地址继续执行；而这种异常需要返回当前指令的地址重新执行当前指令。</li><li>OS需要确保TLB miss处理代码不会触发TLB miss。可以直接将处理代码放在物理地址中（未映射，无需地址翻译）或者在TLB中预留一些entries用来存放处理代码的PTE。</li></ul><h2 id="3-TLB-Contents-What’s-In-There"><a href="#3-TLB-Contents-What’s-In-There" class="headerlink" title="3 TLB Contents: What’s In There"></a>3 TLB Contents: What’s In There</h2><p>TLB通常有32，64，128个entries，并且是全相连的（意味着任何一个entry都可能防止在任何位置，由硬件负责并行的查找对应的entry）。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-19/image-20241115170540216.png" alt="A TLB entry"></p><p>需要注意，TLB entry需要包含VPN，因为TLB是全相连的。</p><p>other bits通常包含valid bit，protection bits，address-space identifier，dirty bit等。</p><h2 id="4-TLB-Issue-Context-Switches"><a href="#4-TLB-Issue-Context-Switches" class="headerlink" title="4 TLB Issue: Context Switches"></a>4 TLB Issue: Context Switches</h2><p>需要注意的是，TLB中的内容都是针对某个进程而言的。当发生上下文切换的时候，TLB中的内容就不在有效了。</p><p><strong>TLB flush</strong></p><p>简单的做法是每次上下文切换的时候，都将TLB中的内容flush掉（将valid bit置0）。但是对于频繁切换的系统，可能会带来较大的开销。</p><p><strong>ASID</strong></p><p>另一种做法是在TLB entry中增加一个<strong>address space identifier（ASID）</strong>来指示该entry对应的进程。ASID相当于是PID，但是通常只有较少的位数（PID32位，ASID8位）</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-19/image-20241115171717905.png"></p><h2 id="5-Issue-Replacement-Policy"><a href="#5-Issue-Replacement-Policy" class="headerlink" title="5 Issue: Replacement Policy"></a>5 Issue: Replacement Policy</h2><p>类似于页置换算法。</p><p>典型的有LRU，随机替换算法等。随机替换算法比较简单，并且可以避免一些边界情况。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 18</title>
    <link href="/2024/11/15/OS-Three-Easy-Pieces-Chapter-18/"/>
    <url>/2024/11/15/OS-Three-Easy-Pieces-Chapter-18/</url>
    
    <content type="html"><![CDATA[<h1 id="Paging-Introduction"><a href="#Paging-Introduction" class="headerlink" title="Paging: Introduction"></a>Paging: Introduction</h1><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1 Overview"></a>1 Overview</h2><p>每个进程都有一个自己的页表(Page table)，用来进行虚拟地址到物理地址的转换。</p><p>虚拟地址分为两部分，虚拟页号（Virtual Page Number，VPN）和内页偏移（offset）。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-18/image-20241115161640163.png"></p><p>MMU根据页表，将VPN转换为对应的物理页号（Physical Page Number，PPN），然后将PPN和offset组合，获得实际的物理地址。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-18/image-20241115161808036.png"></p><h2 id="2-Where-Are-Page-Tables-Stored"><a href="#2-Where-Are-Page-Tables-Stored" class="headerlink" title="2  Where Are Page Tables Stored?"></a>2  Where Are Page Tables Stored?</h2><p>对于常见的地址空间（32位，页大小4KB），VPN是20位，offset是12位。这意味着我们需要$2^{20}$个页表项（page table entry），如果每个页表项是4字节，那么每个进程为了进行地址转换，需要4MB的空间。因此，通常，将页表防止在内存中，而不是在某些芯片上的硬件中。</p><h2 id="3-What’s-Actually-In-The-Page-Table"><a href="#3-What’s-Actually-In-The-Page-Table" class="headerlink" title="3 What’s Actually In The Page Table?"></a>3 What’s Actually In The Page Table?</h2><p>页表就是一个负责将VPN转换为PPN的数据结构。最简单的实现方式是数组，OS用VPN作为索引，取得对应的PTE，然后取得对应的PPN。</p><p><strong>valid bit</strong></p><p>该位用来标识一个地址转化是否有效。</p><p><strong>protection bits</strong></p><p>用来标识某页是否可读，可写，可执行等。</p><p><strong>present bit</strong></p><p>用来标识某页是在物理内存中，还是在磁盘中。主要是为了支持交换技术。</p><p><strong>dirty bit</strong></p><p>用来标识某页是否被修改过。</p><p><strong>reference bit（accessed bit）</strong></p><p>用来标识某页是否被访问过。主要是为了支持页替换。</p><h2 id="4-Paging-Also-Too-Slow"><a href="#4-Paging-Also-Too-Slow" class="headerlink" title="4 Paging: Also Too Slow"></a>4 Paging: Also Too Slow</h2><p>注意到，每次访存之前，都必须进行一次额外的访存，找到对应的PTE完成地址转换，然后才能访问实际的内存。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 17</title>
    <link href="/2024/11/15/OS-Three-Easy-Pieces-Chapter-17/"/>
    <url>/2024/11/15/OS-Three-Easy-Pieces-Chapter-17/</url>
    
    <content type="html"><![CDATA[<h1 id="Free-Space-Management"><a href="#Free-Space-Management" class="headerlink" title="Free-Space Management"></a>Free-Space Management</h1><p>对于页式内存来说，空闲页管理很简单，只需要用链表来管理空闲页即可；但是对于像段式内存这种空闲内存单元大小不固定的方式来说，空闲内存管理变得更复杂。对于后者，最大的挑战是<strong>外部碎片问题</strong>。</p><h2 id="1-Low-level-Mechanisms"><a href="#1-Low-level-Mechanisms" class="headerlink" title="1 Low-level Mechanisms"></a>1 Low-level Mechanisms</h2><p><strong>Splitting and Coalescing</strong></p><p>管理空闲内存空间的数据结构在需要时需要进行相应的拆分或者合并。</p><p><strong>Tracking The Size Of Allocated Regions</strong></p><p>像 <code>free(void *ptr)</code> 这样的接口无需大小参数。因此，给定一个指针，应该可以快速确定需要释放的内存的大小。</p><p>为此，很多实现会在内存中存储一个header，在header中存储一些额外的信息。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-17/image-20241115144435344.png"></p><p><strong>Embedding A Free List</strong></p><p>将管理空闲内存的链表结点存储在空闲内存中。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-17/image-20241115150529087.png"></p><p>当申请了一些内存后</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-17/image-20241115150608588.png"></p><p>当申请了一些内存，并释放了一些内存后。可以注意到，此时所有的空闲空间没有被合并，我们可以遍历一遍链表，将相邻的空间合并。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-17/image-20241115150744978.png"></p><h2 id="2-Basic-Strategies"><a href="#2-Basic-Strategies" class="headerlink" title="2 Basic Strategies"></a>2 Basic Strategies</h2><p><strong>Best Fit</strong></p><p>从最小的可行的空闲内存中分配。</p><p><strong>Worst Fit</strong></p><p>从最大的可行的空闲内存中分配。</p><p><strong>First Fit</strong></p><p>从第一个可行的空闲内存中分配。</p><p>一般将空闲内存按照地址排序。</p><p><strong>Next Fit</strong></p><p>类似First fit，但是每次从上一次分配的下一个可行的空闲内存中分配。</p><h2 id="3-Other-Approaches"><a href="#3-Other-Approaches" class="headerlink" title="3 Other Approaches"></a>3 Other Approaches</h2><p>Segregated Lists、Buddy Allocation等。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Lab4 traps</title>
    <link href="/2024/11/12/MIT-6-1810-Lab4-traps/"/>
    <url>/2024/11/12/MIT-6-1810-Lab4-traps/</url>
    
    <content type="html"><![CDATA[<h2 id="1-RISC-V-assembly-easy"><a href="#1-RISC-V-assembly-easy" class="headerlink" title="1 RISC-V assembly (easy)"></a>1 RISC-V assembly (<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">easy</a>)</h2><div class="note note-primary">            <p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p>          </div><p>在RISC-V中，函数的参数存放在寄存器 <code>a0-a7</code> 中，如果超过8个参数，可以用栈来传递。<code>a0-a1</code> 寄存器还用来传递函数的返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">24:4635                lia2,13<br></code></pre></td></tr></table></figure><p> 从上述代码中可以看出，<code>printf</code> 的参数13放在寄存器 <code>a2</code> 中进行传递。</p><div class="note note-primary">            <p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p>          </div><p><code>f</code> 和 <code>g</code> 都被inlined到 <code>main</code> 中了，编译器预计算出了 <code>f(8) + 1</code> 的值，直接将 <code>12</code> 加载到寄存器 <code>a1</code> 中，而没有直接调用函数。</p><div class="note note-primary">            <p>At what address is the function <code>printf</code> located?</p>          </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">30:68c000ef          jal6bc &lt;printf&gt;<br></code></pre></td></tr></table></figure><p>从上述代码中可知，<code>printf</code> 在0x6bc处</p><div class="note note-primary">            <p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p>          </div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">30:68c000ef          jal6bc &lt;printf&gt;<br>34:4501                lia0,0<br></code></pre></td></tr></table></figure><p>当 <code>jal</code> 指令执行完毕后，会将下一条指令的地址放在 <code>ra</code> 中，因此 <code>ra</code> 中的值是0x34</p><div class="note note-primary">            <p>Run the following code.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0x00646c72</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, (<span class="hljs-type">char</span> *) &amp;i);<br></code></pre></td></tr></table></figure><p>What is the output? <a href="https://www.asciitable.com/">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>          </div><p>在小端（little-endian）系统中，最低有效字节存储在最低地址。</p><p><code>i = 0x00646c72</code>，在小端系统中，它会按字节顺序存储为 <code>72 6c 64 00</code>：</p><ul><li><code>0x72</code> 对应字符 <code>&#39;r&#39;</code></li><li><code>0x6c</code> 对应字符 <code>&#39;l&#39;</code></li><li><code>0x64</code> 对应字符 <code>&#39;d&#39;</code></li><li><code>0x00</code> 对应空字符（字符串结尾）</li></ul><p><code>printf(&quot;H%x Wo%s&quot;, 57616, (char *) &amp;i);</code> 中，<code>%x</code> 会将 <code>57616</code> 以十六进制格式输出，而 <code>%s</code> 会将 <code>i</code> 的值按字符字符串输出。</p><p>因此，输出是：</p><ul><li><code>H%x</code> 会输出 <code>H</code> 加上 <code>57616</code> 的十六进制形式，即 <code>e110</code>。</li><li><code>Wo%s</code> 会输出 <code>Wo</code> 加上 <code>i</code> 的内容，即 <code>rld</code>。</li></ul><p>所以在小端系统上，这段代码的输出为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">He110</span> World<br></code></pre></td></tr></table></figure><p>在大端（big-endian）系统上，<code>0x00646c72</code> 将按字节顺序存储为 <code>00 64 6c 72</code>，这会将 <code>i</code> 解释为不同的字符序列，因此我们需要重新设置 <code>i</code> 以确保输出相同。</p><p>为了在大端系统上得到 <code>rld</code> 的字符顺序，我们需要将 <code>i</code> 设为 <code>0x726c6400</code>，这样在大端系统中存储的字节序将是 <code>72 6c 64 00</code>，即 <code>rld</code>。</p><p><code>57616</code> 的值没有依赖字节顺序，它只是一个整数，所以无需更改。</p><div class="note note-primary">            <p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x=%d y=%d&quot;</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>          </div><p>这段代码使用 <code>printf</code> 函数来输出两个占位符 <code>%d</code>，分别用于打印变量 <code>x</code> 和 <code>y</code> 的值。然而，只提供了一个参数 <code>3</code>，没有给出第二个参数。</p><p>由于缺少第二个参数，<code>printf</code> 会在内存中继续读取下一个位置的值来填充 <code>y</code> 的占位符。这种行为是<strong>未定义行为</strong>（undefined behavior），可能导致以下情况之一：</p><ol><li><strong>随机值</strong>：<code>printf</code> 会从栈或寄存器中读取一些未初始化的值，因此 <code>y</code> 可能会显示一个随机值。</li><li><strong>程序崩溃</strong>：在某些系统上，未提供的参数会导致程序崩溃或打印出无效数据。</li></ol><h2 id="2-Backtrace-moderate"><a href="#2-Backtrace-moderate" class="headerlink" title="2 Backtrace (moderate)"></a>2 Backtrace (<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">moderate</a>)</h2><p>本题要求我们实现 <code>backtrace()</code> 函数用来打印函数调用栈，函数调用栈的结构如下所示。可以看到，<code>ra</code> 寄存器的地址存放在 <code>fp - 8</code> 的位置上。在xv6中，内核栈的大小是一页，因此所有的栈帧都在同一页中，我们可以据此来停止 <code>backtrace</code>。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">                 .<br>                 .<br>    +-&gt;          .<br>    |<span class="hljs-string">   +-----------------+   </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string">   previous fp ------+</span><br><span class="hljs-string">    </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> saved registers </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string"> local variables </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string">       ...       </span>|<span class="hljs-string"> &lt;-+</span><br><span class="hljs-string">    </span>|<span class="hljs-string">   +-----------------+   </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>    +------ previous fp   |<span class="hljs-string">   </span>|<br>        |<span class="hljs-string"> saved registers </span>|<span class="hljs-string">   </span>|<br>        |<span class="hljs-string"> local variables </span>|<span class="hljs-string">   </span>|<br>    +-&gt; |<span class="hljs-string">       ...       </span>|<span class="hljs-string">   </span>|<br>    |<span class="hljs-string">   +-----------------+   </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string">   previous fp ------+</span><br><span class="hljs-string">    </span>|<span class="hljs-string">   </span>|<span class="hljs-string"> saved registers </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string"> local variables </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string">       ...       </span>|<span class="hljs-string"> &lt;-+</span><br><span class="hljs-string">    </span>|<span class="hljs-string">   +-----------------+   </span>|<br>    |<span class="hljs-string">   </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>    +------ previous fp   |<span class="hljs-string">   </span>|<br>        |<span class="hljs-string"> saved registers </span>|<span class="hljs-string">   </span>|<br>        |<span class="hljs-string"> local variables </span>|<span class="hljs-string">   </span>|<br>$fp --&gt; |<span class="hljs-string">       ...       </span>|<span class="hljs-string">   </span>|<br>        +-----------------+   |<span class="hljs-string"></span><br><span class="hljs-string">        </span>|<span class="hljs-string"> return address  </span>|<span class="hljs-string">   </span>|<br>        |<span class="hljs-string">   previous fp ------+</span><br><span class="hljs-string">        </span>|<span class="hljs-string"> saved registers </span>|<br>$sp --&gt; |<span class="hljs-string"> local variables </span>|<br>        +-----------------+<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  uint64 ra, cur_fp, prev_fp, page;<br>  cur_fp = r_fp();<br>  page = PGROUNDDOWN(cur_fp);<br>  <span class="hljs-keyword">while</span> (cur_fp &gt;= page &amp;&amp; cur_fp &lt; page + PGSIZE) &#123;<br>    ra = *((uint64*)(cur_fp - <span class="hljs-number">8</span>));<br>    prev_fp = *((uint64*)(cur_fp - <span class="hljs-number">16</span>));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, (<span class="hljs-type">void</span>*)ra);<br>    cur_fp = prev_fp;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[DB]Database System Concepts Chapter 2</title>
    <link href="/2024/11/10/DB-Database-System-Concepts-Chapter-2/"/>
    <url>/2024/11/10/DB-Database-System-Concepts-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-the-Relational-Model"><a href="#Introduction-to-the-Relational-Model" class="headerlink" title="Introduction to the Relational Model"></a>Introduction to the Relational Model</h1><h2 id="1-Structure-of-Relational-Databases"><a href="#1-Structure-of-Relational-Databases" class="headerlink" title="1 Structure of Relational Databases"></a>1 Structure of Relational Databases</h2><p>一个关系型数据库包含一组表，每个表都有一个独特的名字。</p><p><img src="/../images/DB-Database-System-Concepts-Chapter-2/image-20241110210929546.png" alt="instructor关系"></p><p>通常来说，表中的一行代表着一组值之间的关系。</p><p><strong>术语</strong></p><ul><li><p>tuple：一组值的序列</p></li><li><p>n个值的关系用一个n-tuple来表示（表中的一行）</p></li><li><p>relation - 一张表</p></li><li><p>tuple - 表中的一行</p></li><li><p>attribute - 表中的一列</p></li><li><p>relation instance - 某种关系的一个示例（某些特定的行）</p></li><li><p>domain - 某种关系某个attribute的可行值集合</p><p>对于所有关系 r，r 的所有属性域都是原子的。域是原子的的意思是域的元素被视为不可分割的单位。</p></li><li><p>null value - 用来指示某个值未知或者不存在</p></li></ul><h2 id="2-Database-Schema"><a href="#2-Database-Schema" class="headerlink" title="2 Database Schema"></a>2 Database Schema</h2><ul><li>database schema - 数据库的逻辑视图</li><li>database instance - 某个给定的数据库的某个确定时间的一个快照</li><li>relation - 对应编程中的变量</li><li>relation schema - 对应编程中的类型定义</li></ul><p>对于下图中的department关系，其schema为：<br>$$<br>department(dept_name, building, budget)<br>$$<br><img src="/../images/DB-Database-System-Concepts-Chapter-2/image-20241110212615824.png"></p><h2 id="3-Keys"><a href="#3-Keys" class="headerlink" title="3 Keys"></a>3 Keys</h2><p>必须提供一种方法来区分一个关系中不同的tuple。</p><p><strong>超键superkey</strong></p><p>超键是一个或几个属性的集合，它们可以唯一标识一个关系中的某个tuple。<br>$$<br>if \space t_1 \neq t_2,then \space t1.K \neq t2.K<br>$$<br>其中$K$是某个关系$r$的所有属性集合$R$的一个子集。</p><p>如果$K$是一个超键，那么$K$的任何一个超集也是超键</p><p><strong>候选键candidate keys</strong></p><p>候选键的任何一个子集都不是超键。</p><p>对于一个关系，可以有多个候选键。</p><p><strong>主键primary key</strong></p><p>被选定的某个候选键，用来区分tuple。主键的值应该从不或者很少改变。</p><p><strong>主键约束primary key constraints</strong></p><p>键是整个关系的一个性质，而无关某个具体的tuple。任何两个不同的tuple，它们键的值不能相同。这代表这被建模的真实世界的一个约束（主键约束primary key constraints）</p><p><strong>外键约束</strong></p><p>考虑一下教师关系中的部门名属性。如果 instructor 中的元组的系名值与系关系中的系不对应，那是不合理的。因此，在任何数据库实例中，给定教员关系中的任何元组（如 ta），部门关系中一定有某个元组（如 tb），使得 ta 的部门名属性值与 tb 的主键（部门名）值相同。</p><p>从关系 r1 的属性集 A 到关系 r2 的<strong>主键</strong> B 的外键约束规定，在任何数据库实例中，r1 中每个元组的 A 值也必须是 r2 中某个元组的 B 值。属性集 A 被称为来自 r1 并引用 r2 的外键。关系 r1 也被称为外键约束的引用关系，而 r2 被称为被引用关系。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 16</title>
    <link href="/2024/11/10/OS-Three-Easy-Pieces-Chapter-16/"/>
    <url>/2024/11/10/OS-Three-Easy-Pieces-Chapter-16/</url>
    
    <content type="html"><![CDATA[<h1 id="Segmentation"><a href="#Segmentation" class="headerlink" title="Segmentation"></a>Segmentation</h1><h2 id="1-Segmentation-Generalized-Base-Bounds"><a href="#1-Segmentation-Generalized-Base-Bounds" class="headerlink" title="1 Segmentation: Generalized Base&#x2F;Bounds"></a>1 Segmentation: Generalized Base&#x2F;Bounds</h2><p>传统的动态重定位会导致内存空间的浪费（整个用户地址空间可能只有一小部分真正使用，大部分是空闲的）。因此，可以使用分段的方式，将用户地址空间按照逻辑分为不同的segment，每个segment都有一对base&#x2F;bound寄存器。需要注意的是，在进行地址转化的时候，必须将虚拟地址首先转化为段内偏移，然后在转换为物理地址。</p><h2 id="2-Which-Segment-Are-We-Referring-To"><a href="#2-Which-Segment-Are-We-Referring-To" class="headerlink" title="2 Which Segment Are We Referring To"></a>2 Which Segment Are We Referring To</h2><p>一种普遍的做法是，用虚拟地址的高位来索引不同的段，低位作为段内的偏移。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-16/image-20241110195254091.png"></p><p>这种做法的缺点是限制了每个段的大小。</p><p>另外一种可能的做法是通过地址的来源来判断段。如果地址来自PC，那么肯定是代码段；如果地址来自sp，那么肯定是栈段；否则就是堆段。</p><h2 id="3-What-About-The-Stack"><a href="#3-What-About-The-Stack" class="headerlink" title="3 What About The Stack"></a>3 What About The Stack</h2><p>因为堆是逆向增长的，因此需要额外处理。具体地，硬件应该添加一个标记位，用来指示地址增长方向是正向的还是逆向的。</p><h2 id="4-Support-for-Sharing"><a href="#4-Support-for-Sharing" class="headerlink" title="4 Support for Sharing"></a>4 Support for Sharing</h2><p>通过对每个segment添加保护位（可读、可写、可执行等），可以安全的在不同的进程间共享内存。</p><p>同时，MMU在进行地址转换的时候，也要确保某个进程对某块内存有正确的访问权限。</p><h2 id="5-OS-Support"><a href="#5-OS-Support" class="headerlink" title="5 OS Support"></a>5 OS Support</h2><p>段式内存也有一些问题：</p><ul><li>上下文切换的时候操作系统需要负责切换所有段的base&#x2F;bound寄存器</li><li>段增长<ul><li>如果heap有足够的内存，<code>malloc</code> 直接在heap中分配内存，然后返回相应的地址</li><li>如果heap没有足够的内存， <code>malloc</code> 会调用 <code>sbrk</code> 系统调用去增长heap，如果有足够的空间供增长，操作系统会更新堆段的bound寄存器。</li></ul></li><li>管理空闲内存：段式内存最大的问题是会外部碎片问题。有一系列算法来管理内存（BF，WF，FF，伙伴算法等），但是都无法根本上解决外部碎片问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 15</title>
    <link href="/2024/11/10/OS-Three-Easy-Pieces-Chapter-15/"/>
    <url>/2024/11/10/OS-Three-Easy-Pieces-Chapter-15/</url>
    
    <content type="html"><![CDATA[<h1 id="Mechanism-Address-Translation"><a href="#Mechanism-Address-Translation" class="headerlink" title="Mechanism: Address Translation"></a>Mechanism: Address Translation</h1><h2 id="1-Assumptions"><a href="#1-Assumptions" class="headerlink" title="1 Assumptions"></a>1 Assumptions</h2><p>最初的假设很简单：</p><ul><li>用户地址空间在物理内存中连续存放</li><li>用户地址空间不大于物理内存大小</li><li>每个用户地址空间都一样大</li></ul><h2 id="2-Dynamic-Hardware-based-Relocation"><a href="#2-Dynamic-Hardware-based-Relocation" class="headerlink" title="2 Dynamic(Hardware-based) Relocation"></a>2 Dynamic(Hardware-based) Relocation</h2><p>早期，在没有硬件支持的时候，有些操作系统支持软件重定位(static relocation)。<strong>loader</strong>程序负责改写另外一个程序中涉及到的地址为实际的物理地址。这种方法不提供任何的保护，同时也很难修改某个程序在物理内存中的位置。</p><p>后面，在硬件的支持下，提出了动态重定位。每个CPU内部有一个base寄存器和一个bound寄存器，负责将虚拟地址转换为实际的物理地。<br>$$<br>physical\space address &#x3D; virtual \space address + base<br>$$<br>这种地址转换是发生在运行期间的，并且在程序已经开始运行之后，也可以重新定位程序。</p><p>bound寄存器负责提供内存保护，内存管理单元（MMU）检查一个程序提供的虚拟地址是否在bound范围内，如果不在，则触发异常，将进程杀死；如果合法，才接着进行地址转换，将其转换为实际的物理地址。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-15/image-20241110185430276.png"></p><h2 id="3-Operating-System-Issues"><a href="#3-Operating-System-Issues" class="headerlink" title="3 Operating System Issues"></a>3 Operating System Issues</h2><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-15/image-20241110185748756.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[CMU 15-445]HyperLogLog原理</title>
    <link href="/2024/11/09/CMU-15-445-HyperLogLog%E5%8E%9F%E7%90%86/"/>
    <url>/2024/11/09/CMU-15-445-HyperLogLog%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HyperLogLog-in-Presto"><a href="#HyperLogLog-in-Presto" class="headerlink" title="HyperLogLog in Presto"></a>HyperLogLog in Presto</h1><p><strong>情景</strong></p><p>想要确定一个有重复元素的很大集合的cardinality。常规方法的时间开销或者内存开销过大，无法接受。</p><p><strong>A simple estimator</strong></p><p>首先，生成一个理论数据集：</p><ul><li>生成n个均匀分布在[0,1]之间的数。</li><li>随机挑选一些数，随机复制几次。</li><li>打乱顺序</li></ul><p>因为所有数是均匀分布的，可以找出最小的数$x_{min}$，然后估计集合的$cardinality &#x3D; 1&#x2F;x_{min}$.</p><p>为了确保数是均匀分布的，可以对每个数进行哈希，然后根据哈希值来估计。</p><p><img src="/../images/CMU-15-445-HyperLogLog%E5%8E%9F%E7%90%86/image-20241109162303304.png"></p><p>这种简单的估计有较高的偏差，因为如果最小值太小，会导致估计的值过大。</p><p><strong>Probabilistic counting</strong></p><p>为了改善上述问题，我们可以通过统计哈希值二进制开头连续的0的个数。因为某个给定哈希值开头连续出现$i$个0的概率是$1&#x2F;2^i$。也就是说，平均来说，每$2^i$个哈希值才会出现一个连续$i$个0的哈希值。</p><p>因此，我们可以统计所有哈希值中出现的最大的连续的0的个数$k$，然后集合的$cardinality&#x3D;2^k$。</p><p>这种方法有两个缺点：</p><ul><li>最好情况下，该方法估计的值只能是2的幂</li><li>因为该方法仍然只依赖于某个有最长连续0的哈希值，因此也有较大的偏差。</li></ul><p>这种方法的优点是需要的内存空间很小，只需要记录最大连续的0的个数即可。</p><p><strong>Improving accuracy：LogLog</strong></p><p>我们可以设计很多哈希函数，然后将最大连续0的个数取平均。但是这种方法的计算开销过大。</p><p>另一种方法是，用哈希值的最高几位作为索引，索引到一个bucket，每个bucket记录其见过的最长连续0的个数。然后用公式$cardinality &#x3D; constant · m · 2^{1&#x2F;m \Sigma^N_{j&#x3D;1}R_j}$来进行估计。</p><p><img src="/../images/CMU-15-445-HyperLogLog%E5%8E%9F%E7%90%86/image-20241109164308143.png"></p><p>统计分析指出上述方法的估计有一个偏差，因此令$constant &#x3D; 0.79402$来修正这个偏差。</p><p>对于$m$个bucket，该方法的误差大概在$1.3&#x2F;\sqrt{m}$左右。</p><p><strong>HLL：Improving accuracy further</strong></p><ul><li>异常值会降低准确度。因此，可以在收集每个bucket的值的时候，只考虑较小的70%的bucket，扔掉其余30%。这种算法（SuperLogLog），可以将误差降低到$1.05&#x2F;\sqrt{m}$.</li><li>HLL使用调和平均，可以将误差降低到$1.04&#x2F;\sqrt{m}$左右。</li></ul><p>最终，得到的公式为<br>$$<br>CARDINALITY_{HLL} &#x3D; constant · m · \frac{m}{\Sigma_{j&#x3D;1}^N 2^{-R_j}}<br>$$<br><strong>集合并运算</strong></p><p>对于两个HLL数据结构，我们可以对其进行并操作（对每个对应位置的bucket取二者的较大者）。该操作很简单并且是无损的。对于并行运算友好。</p><p><strong>Presto‘s HLL implementation</strong></p><p>该实现方法有两种布局：sparse和dense。</p><p>sparse布局的结果几乎是准确的，但是对于cardinality较大的情况，算法会自动采用dense布局，该布局的结果是上述HLL算法的预估值。</p><p><strong>稀疏布局</strong>存储一组相邻的 32 位的bucket，按桶索引升序排序。当有新数据输入时，Presto 会检查数据桶编号是否已经存在。如果存在，则更新其值。如果数据桶是新的，Presto 会分配一个新的 32 位内存地址来保存该值。随着数据量的增加，存储桶的数量可能会超过预先设定的内存限制。这时，Presto 会切换到密集布局表示法。</p><p><strong>密集布局</strong> 有固定数量的存储桶，相关内存从一开始就被分配。桶值以 4 位值序列的形式编码，如下图所示。根据 HLL 算法的统计特性，4 位足以编码给定 HLL 结构中的大部分值。对于大于4位的值，余数存储在溢出项列表中。</p><p><img src="/../images/CMU-15-445-HyperLogLog%E5%8E%9F%E7%90%86/image-20241109171247559.png"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMU 15-445</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]文件系统filesystem库</title>
    <link href="/2024/11/06/C-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Ffilesystem%E5%BA%93/"/>
    <url>/2024/11/06/C-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9Ffilesystem%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="文件系统filesystem库"><a href="#文件系统filesystem库" class="headerlink" title="文件系统filesystem库"></a>文件系统filesystem库</h1><p>C++17标准的一个重要补充是filesystem库，它使我们能够处理分层文件系统（如Windows或POSIX的文件系统）中的路径、文件和目录。</p><h2 id="1-使用文件系统路径"><a href="#1-使用文件系统路径" class="headerlink" title="1 使用文件系统路径"></a>1 使用文件系统路径</h2><p>filesystem库位于 <code>&lt;filesystem&gt;</code> 头文件的 <code>std::filesystem</code> 命名空间中。</p><p>文件系统组件（文件、目录、硬链接或软链接）的路径由 <code>path</code> 类表示。</p><h3 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h3><ul><li><p>创建路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> path = std::filesystem::path&#123;<span class="hljs-string">&quot;/home/docs&quot;</span>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>添加元素到路径（包含目录分隔符）</p><p>通过成员操作符 <code>/=</code> ，非成员操作符 <code>/</code> 或者 <code>append()</code> 方法将元素附加到路径，包含目录分隔符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">path /= <span class="hljs-string">&quot;Book&quot;</span>;<br>path = path / <span class="hljs-string">&quot;Modern&quot;</span> / <span class="hljs-string">&quot;Cpp&quot;</span>;<br>path.<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;Programming&quot;</span>);<br><span class="hljs-comment">// 输出 &quot;/home/docs/book/Modern/Cpp/Programming&quot;</span><br>cout &lt;&lt; path &lt;&lt; endl;<br></code></pre></td></tr></table></figure></li><li><p>添加元素到路径（不包含目录分隔符）</p><p>使用成员操作符 <code>+=</code> 、非成员操作符 <code>+</code> 或 <code>concat()</code> 方法将元素连接到路径，而不包含目录分隔符</p></li><li><p>分解目录</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> path = filesystem::path&#123;<span class="hljs-string">&quot;root/home/docs/file.txt&quot;</span>&#125;;<br>    cout <br>        &lt;&lt; <span class="hljs-string">&quot;root: &quot;</span>        &lt;&lt; path.<span class="hljs-built_in">root_name</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;root dir: &quot;</span>    &lt;&lt; path.<span class="hljs-built_in">root_directory</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;root path: &quot;</span>   &lt;&lt; path.<span class="hljs-built_in">root_path</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;rel path: &quot;</span>    &lt;&lt; path.<span class="hljs-built_in">relative_path</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;parent path: &quot;</span> &lt;&lt; path.<span class="hljs-built_in">parent_path</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;filename: &quot;</span>    &lt;&lt; path.<span class="hljs-built_in">filename</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;stem: &quot;</span>        &lt;&lt; path.<span class="hljs-built_in">stem</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;extension: &quot;</span>   &lt;&lt; path.<span class="hljs-built_in">extension</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery">root: <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">root</span> dir: <span class="hljs-string">&quot;&quot;</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">root</span><span class="hljs-built_in"> path</span>: <span class="hljs-string">&quot;&quot;</span><br>rel<span class="hljs-built_in"> path</span>: <span class="hljs-string">&quot;root/home/docs/file.txt&quot;</span><br>parent<span class="hljs-built_in"> path</span>: <span class="hljs-string">&quot;root/home/docs&quot;</span><br>filename: <span class="hljs-string">&quot;file.txt&quot;</span><br>stem: <span class="hljs-string">&quot;file&quot;</span><br>extension: <span class="hljs-string">&quot;.txt&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>检查目录各个部分</p><p>使用成员函数（如 <code>has_root_name()</code> 、 <code>has_root_directory()</code> 、<code>has_filename()</code> 、 <code>has_stem()</code> 和 <code>has_extension()</code> ）获取路径的各部分是否可用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> path = filesystem::path&#123;<span class="hljs-string">&quot;root/home/docs/file.txt&quot;</span>&#125;;<br>    cout <br>        &lt;&lt; <span class="hljs-string">&quot;has root: &quot;</span>        &lt;&lt; path.<span class="hljs-built_in">has_root_name</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;has root dir: &quot;</span>    &lt;&lt; path.<span class="hljs-built_in">has_root_directory</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;has root path: &quot;</span>   &lt;&lt; path.<span class="hljs-built_in">has_root_path</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;has rel path: &quot;</span>    &lt;&lt; path.<span class="hljs-built_in">has_relative_path</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;has parent path: &quot;</span> &lt;&lt; path.<span class="hljs-built_in">has_parent_path</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;has filename: &quot;</span>    &lt;&lt; path.<span class="hljs-built_in">has_filename</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;has stem: &quot;</span>        &lt;&lt; path.<span class="hljs-built_in">has_stem</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span><br>        &lt;&lt; <span class="hljs-string">&quot;has extension: &quot;</span>   &lt;&lt; path.<span class="hljs-built_in">has_extension</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">has</span> root: <span class="hljs-number">0</span><br><span class="hljs-attribute">has</span> root dir: <span class="hljs-number">0</span><br><span class="hljs-attribute">has</span> root path: <span class="hljs-number">0</span><br><span class="hljs-attribute">has</span> rel path: <span class="hljs-number">1</span><br><span class="hljs-attribute">has</span> parent path: <span class="hljs-number">1</span><br><span class="hljs-attribute">has</span> filename: <span class="hljs-number">1</span><br><span class="hljs-attribute">has</span> stem: <span class="hljs-number">1</span><br><span class="hljs-attribute">has</span> extension: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>检查路径是相对路径还是绝对路径</p><p>用 <code>is_absolute()</code> 成员函数检查路径是否是绝对路径</p></li><li><p>修改文件名和扩展名</p><p>用 <code>replace_filename()</code> 修改文件名，用 <code>remove_filename()</code> 删除文件名，用<code>replace_extension()</code> 修改扩展名</p></li><li><p>将目录分隔符转换为系统首选的分隔符</p><p>用 <code>make_preferred()</code> 成员函数将目录分隔符转换为系统首选的分隔符</p></li></ul><h2 id="2-创建、复制和删除文件及目录"><a href="#2-创建、复制和删除文件及目录" class="headerlink" title="2 创建、复制和删除文件及目录"></a>2 创建、复制和删除文件及目录</h2><p>filesystem库支持对文件的操作（如复制、移动和删除）以及对目录的操作（如创建、重命名和删除）。</p><ul><li>使用 <code>create_directory()</code> 创建新目录。如果目录已经存在，则该函数什么都不做。注意，该方法不会递归的创建目录</li><li>使用 <code>create_directories()</code> 递归的创建新目录。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 17</title>
    <link href="/2024/11/03/C-C-Primer-Chapter-17/"/>
    <url>/2024/11/03/C-C-Primer-Chapter-17/</url>
    
    <content type="html"><![CDATA[<h1 id="17-标准库特殊设施"><a href="#17-标准库特殊设施" class="headerlink" title="17 标准库特殊设施"></a>17 标准库特殊设施</h1><h2 id="4-随机数"><a href="#4-随机数" class="headerlink" title="4 随机数"></a>4 随机数</h2><p>定义在头文件random中的随机数库通过一组协作的类来生成随机数：</p><ul><li>随机数引擎类（random-number engines）</li><li>随机数分布类（random-number distribution）</li></ul><p>一个引擎类可以生成unsigned随机数序列，一个分布类使用一个引擎类生成指定类型的、在给定范围内的、服从特定概率分布的随机数。</p><h3 id="4-1-随机数引擎和分布"><a href="#4-1-随机数引擎和分布" class="headerlink" title="4.1 随机数引擎和分布"></a>4.1 随机数引擎和分布</h3><p>随机数引擎是函数对象类（参见14.8节，第506页），它们定义了一个调用运算符，该运算符不接受参数并返回一个随机unsigned整数。</p><p>标准库定义了多个随机数引擎类，区别在于性能和随机性质量不同。每个编译器都会指定其中一个作为default_random_engine类型。</p><p><img src="/../images/C-C-Primer-Chapter-17/image-20241103140024471.png"></p><p>对于大多数场合，随机数引擎的输出是不能直接使用的，这也是为什么称之为原始随机数。问题出在生成的随机数的值范围通常与我们需要的不符，而正确转换随机数的范围是极其困难的。</p><p><strong>分布类型和引擎</strong></p><p>为了得到在一个指定范围内的数，需要使用一个分布类型的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>)</span></span>;<br>default_random_engine e;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) <br>    cout &lt;&lt; <span class="hljs-built_in">u</span>(e) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><p>其中 <code>u(0,0)</code> 表示希望得到[0,9]之间的数。</p><p><strong>引擎生成一个数值序列</strong></p><p>对于随机数发生器来说：即使生成的数看起来是随机的，但对一个给定的发生器，每次运行程序它都会返回相同的数值序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">bad_randVec</span><span class="hljs-params">()</span> </span>&#123;<br>    default_random_engine e;<br>    <span class="hljs-function">uniform_int_distribution&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">unsigned</span>&gt; ret;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) <br>        ret.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">u</span>(e));<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码，每次调用都会返回相同的vector，不是我们想要的。</p><p>正确的做法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">good_randVec</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> default_random_engine e;<br>    <span class="hljs-function"><span class="hljs-type">static</span> uniform_int_distribution&lt;<span class="hljs-type">unsigned</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">unsigned</span>&gt; ret;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) <br>        ret.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">u</span>(e));<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>将引擎和分布定义为static的，使其在函数调用之间能够保持住状态。</p><div class="note note-primary">            <p>一个给定的随机数发生器一直会生成相同的随机数序列。一个函数如果定义了局部的随机数发生器，应该将其（包括引擎和分布对象）定义为static的。否则，每次调用函数都会生成相同的序列。</p>          </div><p><strong>设置随机数发生器种子</strong></p><p>最常用的方法是调用系统函数time。这个函数定义在头文件ctime中，它返回从一个特定时刻到当前经过了多少秒。函数time接受单个指针参数，它指向用于写入时间的数据结构。如果此指针为空，则函数简单地返回时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">default_random_engine <span class="hljs-title">e</span><span class="hljs-params">(time(<span class="hljs-number">0</span>))</span></span>;<br></code></pre></td></tr></table></figure><p>由于time返回以秒计的时间，因此这种方式只适用于生成种子的间隔为秒级或更长的应用。</p><h3 id="4-2-其他随机数分布"><a href="#4-2-其他随机数分布" class="headerlink" title="4.2 其他随机数分布"></a>4.2 其他随机数分布</h3><p><strong>生成随机实数</strong></p><p>使用新标准库设施，可以很容易地获得随机浮点数。我们可以定义一个uniform_real_distribution类型的对象，并让标准库来处理从随机整数到随机浮点数的映射。</p><p><strong>使用分布的默认结果类型</strong></p><p>分布类型都是模板，具有单一的模板类型参数，表示分布生成的随机数的类型。</p><p>每个分布模板都有一个默认模板实参。生成浮点值的分布类型默认生成double值，而生成整型值的分布默认生成int值。由于分布类型只有一个模板参数，因此当我们希望使用默认随机数类型时要记得在模板名之后使用空尖括号。</p><p><strong>生成非均匀分布的随机数</strong></p><p>除了正确生成在指定范围内的数之外，新标准库的另一个优势是可以生成非均匀分布的随机数。实际上，新标准库定义了20种分布类型，例如normal_distribution，该分布接受一个均值和方差。</p><p><strong>bernoulli_distribution类</strong></p><p>该类是一个普通类，而不是模板类。此分布总是返回一个bool值。它返回true的概率是一个常数，此概率的默认值是0.5。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 14</title>
    <link href="/2024/11/01/OS-Three-Easy-Pieces-Chapter-14/"/>
    <url>/2024/11/01/OS-Three-Easy-Pieces-Chapter-14/</url>
    
    <content type="html"><![CDATA[<h1 id="Interlude-Memory-API"><a href="#Interlude-Memory-API" class="headerlink" title="Interlude: Memory API"></a>Interlude: Memory API</h1><p>本章介绍UNIX系统中内存相关的API。</p><h2 id="1-Types-of-Memory"><a href="#1-Types-of-Memory" class="headerlink" title="1 Types of Memory"></a>1 Types of Memory</h2><p>在c程序中，有两种类型的内存</p><ul><li><p>栈内存</p><p>栈内存，也被称为自动存储内存，由编译器隐式的申请和释放。</p></li><li><p>堆内存</p><p>由程序员手动的通过malloc和free申请和释放。</p></li></ul><h2 id="2-The-malloc-Call"><a href="#2-The-malloc-Call" class="headerlink" title="2 The malloc() Call"></a>2 The <code>malloc()</code> Call</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>该函数比较简单，在堆上申请指定大小字节的内存，并返回该内存的地址。失败的话，返回 <code>NULL</code>.</p><p>通常情况下会搭配 <code>sizeof()</code> 运算符一起使用。之所以是运算符而不是函数调用是因为 <code>sizeof()</code> 求值通常发生在编译期，而不是运行期。</p><h2 id="3-The-free-Call"><a href="#3-The-free-Call" class="headerlink" title="3 The free() Call"></a>3 The <code>free()</code> Call</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span>;<br></code></pre></td></tr></table></figure><h2 id="4-Underlying-OS-Support"><a href="#4-Underlying-OS-Support" class="headerlink" title="4 Underlying OS Support"></a>4 Underlying OS Support</h2><p>有一个系统调用叫做 <code>brk</code>，用于改变程序<strong>break</strong>的位置，即堆（heap）结束的位置。<code>brk</code> 接受一个参数（新的break地址），可以根据新地址与当前break的位置关系来增大或缩小堆的大小：如果新的break位置比当前的位置大，堆会扩展；如果小，堆会缩小。</p><p>另一个相关的系统调用是 <code>sbrk</code>，它接受一个增量值作为参数，用于在现有堆的基础上增加或减少一定的内存大小，功能与 <code>brk</code> 类似。</p><p>此外，还可以通过 <code>mmap()</code> 系统调用从操作系统获取内存。通过传入合适的参数，<code>mmap()</code> 可以在程序中创建一个匿名内存区域——这个区域不与任何特定文件关联，而是与交换空间相关。这种内存区域也可以像堆一样进行管理和使用。更多细节可以查阅 <code>mmap()</code> 的手册页。</p><h2 id="5-Other-Calls"><a href="#5-Other-Calls" class="headerlink" title="5 Other Calls"></a>5 Other Calls</h2><p><strong><code>calloc()</code></strong></p><p>申请内存并初始化为0.</p><p><strong><code>realloc()</code></strong></p><p>修改某片申请的内存的大小，可能涉及到内存的拷贝。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 13</title>
    <link href="/2024/11/01/OS-Three-Easy-Pieces-Chapter-13/"/>
    <url>/2024/11/01/OS-Three-Easy-Pieces-Chapter-13/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Abstraction-Address-Spaces"><a href="#The-Abstraction-Address-Spaces" class="headerlink" title="The Abstraction: Address Spaces"></a>The Abstraction: Address Spaces</h1><h2 id="1-Early-Systems"><a href="#1-Early-Systems" class="headerlink" title="1 Early Systems"></a>1 Early Systems</h2><p>从内存的角度来看，早期的机器并没有为用户提供太多的抽象概念。基本上，操作系统是在内存中的程序（实际上是程序库），而有一个正在运行的程序（进程）当前位于物理内存中，并使用内存的其余部分。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-13/image-20241101160330010.png"></p><h2 id="2-The-Address-Space"><a href="#2-The-Address-Space" class="headerlink" title="2 The Address Space"></a>2 The Address Space</h2><p>地址空间是操作系统提供给用户的一种抽象。在用户看来，它可以使用整个地址空间的内存。一般来说，地址空间至少包括代码，堆，栈等。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-13/image-20241101161943524.png" alt="用户地址空间"></p><p>由于操作系统需要在多个进程之间共享物理内存，因此它不能直接使用进程地址空间的地址（虚拟地址），它需要将其转换为实际的物理地址，即虚拟化内存。</p><h2 id="3-Goals"><a href="#3-Goals" class="headerlink" title="3 Goals"></a>3 Goals</h2><p>VM系统有如下几个目标：</p><ol><li>transparency：程序不应该意识到虚拟内存的存在，它表现的应该像自己拥有完整的物理内存一样。</li><li>efficiency：时间和空间上高效</li><li>protection：操作系统本身和用户进程不应该受到其他进程的干扰（进程不能访问其他进程的内存）。这引出了isolation的概念，每个进程都应该在自己的隔离的内存中运行。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 10</title>
    <link href="/2024/11/01/OS-Three-Easy-Pieces-Chapter-10/"/>
    <url>/2024/11/01/OS-Three-Easy-Pieces-Chapter-10/</url>
    
    <content type="html"><![CDATA[<h1 id="Multiprocessor-Scheduling-Advanced"><a href="#Multiprocessor-Scheduling-Advanced" class="headerlink" title="Multiprocessor Scheduling (Advanced)"></a>Multiprocessor Scheduling (Advanced)</h1>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 9</title>
    <link href="/2024/11/01/OS-Three-Easy-Pieces-Chapter-9/"/>
    <url>/2024/11/01/OS-Three-Easy-Pieces-Chapter-9/</url>
    
    <content type="html"><![CDATA[<h1 id="Scheduling-Proportional-Share"><a href="#Scheduling-Proportional-Share" class="headerlink" title="Scheduling: Proportional Share"></a>Scheduling: Proportional Share</h1><p>在本章中，将研究一种不同类型的调度程序，即<strong>比例共享（proportional share）</strong>调度程序，有时也称为<strong>公平共享（fair-share）</strong>调度程序。比例共享调度器基于一个简单的概念：调度器可以不对周转时间或响应时间进行优化，而是设法保证每个作业都能获得一定比例的 CPU 时间。其<strong>基本思想</strong>非常简单：每隔一段时间举行一次抽签，决定下一个运行的进程；应该更频繁运行的进程应该有更多机会中签。</p><h2 id="1-Basic-Concept-Tickets-Represent-Your-Share"><a href="#1-Basic-Concept-Tickets-Represent-Your-Share" class="headerlink" title="1 Basic Concept: Tickets Represent Your Share"></a>1 Basic Concept: Tickets Represent Your Share</h2><p>抽签调度的基础是一个非常基本的概念：<strong>tickets</strong>，用来表示进程（或用户或其他）应获得的资源份额。一个进程拥有的 ticket 的百分比代表了它在相关系统资源中的份额。</p><p>抽签调度每隔一段时间进行一次抽签，随机抽一个ticket出来，然后调度拥有该ticket的进程运行。</p><h2 id="2-Ticket-Mechanisms"><a href="#2-Ticket-Mechanisms" class="headerlink" title="2 Ticket Mechanisms"></a>2 Ticket Mechanisms</h2><p><strong>ticket currency</strong></p><p>该机制允许用户根据需要给自己的任务分配货币，然后操作系统根据该用户所有的ticket以及子任务的货币计算出每个子任务的tickets。</p><p>比如，最开始A，B各自有100个tickets</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-9/image-20241101145013205.png"></p><p><strong>ticket transfer</strong></p><p>一个进程可以暂时将自己的tickets转给另外一个进程。该策略在CS模式下非常有用。</p><p>当客户需要服务器帮自己完成某些工作的时候，一并将自己的tickets转给服务器，服务器完成之后，将tickets再转回客户。</p><p><strong>ticket inflation</strong></p><p>在互相信任的环境中，进程可以通过增加或减少其ticket来适应其资源需求。</p><h2 id="3-Implementation"><a href="#3-Implementation" class="headerlink" title="3 Implementation"></a>3 Implementation</h2><p>抽签调度最大的优势就是其实现非常简单，只需要：</p><ol><li>一个设计良好的随机数生成器</li><li>一个维护所有进程的数据结构</li><li>tickets总数</li></ol><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-9/image-20241101150058910.png"></p><p>要做出调度决策，我们首先要从ticket总数中随机抽取一个数字（中奖者）。然后，我们只需遍历列表，用一个简单的计数器帮助我们找到中奖者。代码会遍历进程列表，将每个进程的tickets添加到计数器中，直到计数器超过中奖者为止。一旦出现这种情况，当前列表中的进程就是中奖者。</p><h2 id="4-How-To-Assign-Tickets"><a href="#4-How-To-Assign-Tickets" class="headerlink" title="4 How To Assign Tickets"></a>4 How To Assign Tickets</h2><p>一个方法是认为用户知道如何分配。但这其实并没有解决实际的问题。</p><h2 id="5-Stride-Scheduling"><a href="#5-Stride-Scheduling" class="headerlink" title="5 Stride Scheduling"></a>5 Stride Scheduling</h2><p>该策略是用一个很大的数除以每个进程的ticket，得到每个进程的stride，并用一个计数器来记录每个进程的执行进度（pass）。每次执行一个进程，将其pass增加stride。每次调度都会选取pass值最小的那个进程来执行。</p><p><strong>抽签调度的优势</strong></p><p>相较于stride scheduling，抽签调度的优势是没有全局状态，即没有pass。当有一个新的进程添加的时候，对于stride scheduling，我们不能将其pass简单的设置为0，否则该新进程会主宰系统。而对于抽签调度，我们无需考虑这个问题，只要设置好对应的tickets即可。</p><h2 id="6-The-Linux-Completely-Fair-Scheduler（CFS）"><a href="#6-The-Linux-Completely-Fair-Scheduler（CFS）" class="headerlink" title="6 The Linux Completely Fair Scheduler（CFS）"></a>6 The Linux Completely Fair Scheduler（CFS）</h2><p>Linux的CFS调度器实现了公平共享调度，而且是以高效和可扩展的方式实现的。</p><p><strong>Basic Operation</strong></p><p>大多数调度程序都基于固定时间片的概念，而 CFS 的运行方式则有些不同。它的目标很简单：在所有竞争进程之间公平分配 CPU。它通过一种简单的基于计数的技术来实现这一目标，这种技术被称为<strong>虚拟运行时间（vruntime）</strong>。</p><p>每个进程运行时都会累积 vruntime。在最基本的情况下，每个进程的 vruntime 都以相同的速度增长，与物理（实际）时间成比例。在进行调度决策时，CFS 会选择 vruntime 最低的进程作为下一个运行进程。</p><p>调度程序如何知道何时停止当前正在运行的进程，并运行下一个进程？这里的矛盾很明显：如果 CFS 切换过于频繁，公平性会提高，因为 CFS 将确保每个进程即使在微小的时间窗口内也能获得其 CPU 份额，但代价是性能下降（上下文切换过多）；如果 CFS 切换频率较低，性能会提高（上下文切换减少），但代价是近期公平性下降。</p><p>CFS 通过各种控制参数来处理这种矛盾。</p><p>首先是 <code>sched_latency</code>。CFS 使用该值来确定一个进程在考虑切换前应运行多长时间。典型的调度延迟值为 48（毫秒）；CFS 将此值除以 CPU 上运行的进程数（n）来确定进程的时间片，从而确保在这段时间内，CFS 完全公平。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-9/image-20241101152428006.png"></p><p>上述是一个例子，最开始有四个进程ABCD，因此最开始的时间片是48&#x2F;4 &#x3D; 12ms，之后CD运行完毕，只剩两个进程AB，每个进程的时间片是48&#x2F;2 &#x3D; 12ms。</p><p>但是，当进程过多的时候，会导致每个进程的时间片过多，导致频繁的上下文切换。为了解决这个问题，CFS用另外一个参数来控制，<code>min_granularity</code> ，一般设置为6ms。CFS永远不会将时间片的值设置的比 <code>min_granularity</code> 小，保证上下文切换不会太过频繁。</p><p><strong>Weighting(Niceness)</strong></p><p>CFS（完全公平调度器）还允许对进程优先级进行控制，让用户或管理员可以为某些进程分配更多的CPU资源。这种控制不是通过ticket，而是通过UNIX经典的“nice”机制来实现的。进程的nice参数范围在 -20 到 +19 之间，默认值是 0。正的nice值意味着较低的优先级，负的nice值则表示较高的优先级。</p><p>CFS将nice值映射到weight，并根据一下公式来计算每个进程的时间片。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-9/image-20241101153458916.png"><br>$$<br>time_slice_k &#x3D; \frac{weight_k}{\Sigma_{i &#x3D; 0}^{n - 1}weight_k} · sched_latency<br>$$<br>为了配合时间片计算，vruntime的计算公式也要做出相应的修改，其中$weight_0$是默认权重，为1024，$runtime_i$是某个进程的实际运行时间。<br>$$<br>vruntime_i&#x3D;vruntime_i + \frac{weight_0}{weight_i} · runtime_i<br>$$<br>使用权重表的设计的聪明之处在于，当进程之间的nice值差异保持不变时，CPU分配比例也能保持不变。换句话说，即使两个进程的nice值发生变化，只要它们之间的差值相同，它们的CPU分配比例不会变。</p><p>举个例子：假设最初进程A的nice值为0，进程B的nice值为5。后来我们将A的nice值调整为5，B的nice值调整为10。虽然两个进程的nice值都变了，但由于它们的nice差值仍然是5，CFS会以与之前相同的方式调度它们，保持相同的CPU分配比例。</p><p><strong>Using Red-Black Trees</strong></p><p>CFS使用红黑树来维护所有runnable的进程（其他状态的进程由其他数据结构来维护）。这可以保证每次选取最小vruntime的进程的时间复杂度为$O(logn)$。</p><p>为什么不适用小顶堆来维护？</p><p>关于这个问题，可以参考<a href="https://stackoverflow.com/questions/33191110/reason-why-cfs-scheduler-using-red-black-tree">linux kernel - Reason why CFS scheduler using red black tree? - Stack Overflow</a></p><p><strong>Dealing With I&#x2F;O And Sleeping Process</strong></p><p>在选择下一个运行的最低 vruntime 时会遇到一个问题，那就是作业已经休眠了很长时间。设想有两个进程，A 和 B，其中一个进程（A）持续运行，而另一个进程（B）已经休眠了很长时间（比如 10 秒）。当 B 唤醒时，它的 vruntime 将比 A 晚 10 秒，因此，B 将在接下来的 10 秒内独占 CPU，同时赶上 A，这实际上会饿死 A。</p><p>实际上，CFS 会将该作业的 vruntime 设置为在树中找到的最小值。通过这种方式，CFS 避免了 “饥饿”，但也付出了代价：作业如果经常处于短时间睡眠状态，就无法获得公平的 CPU 资源。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 14</title>
    <link href="/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-14/"/>
    <url>/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-14/</url>
    
    <content type="html"><![CDATA[<h1 id="强枚举类型（C-11C-17-C-20）"><a href="#强枚举类型（C-11C-17-C-20）" class="headerlink" title="强枚举类型（C++11C++17 C++20）"></a>强枚举类型（C++11C++17 C++20）</h1><h2 id="1-枚举类型的弊端"><a href="#1-枚举类型的弊端" class="headerlink" title="1 枚举类型的弊端"></a>1 枚举类型的弊端</h2><p><strong>类型问题</strong></p><p>虽然枚举类型存在一定的安全检查功能，一个枚举类型不允许分配到另外一种枚举类型，而且整型也无法隐式转换成枚举类型。但是枚举类型却可以隐式转换为整型，因为C++标准文档提到“枚举类型可以采用整型提升的方法转换成整型”。</p><p><strong>作用域问题</strong></p><p>枚举类型会把其内部的枚举标识符导出到枚举被定义的作用域。也是就说，我们使用枚举标识符的时候，可以跳过对于枚举类型的描述。</p><h2 id="2-使用强枚举类型"><a href="#2-使用强枚举类型" class="headerlink" title="2 使用强枚举类型"></a>2 使用强枚举类型</h2><p>C++11增加了强枚举类型，具有以下特性：</p><ul><li>枚举标识符属于强枚举类型的作用域。</li><li>枚举标识符不会隐式转换为整型。</li><li>能指定强枚举类型的底层类型，底层类型默认为int类型。</li></ul><p>定义语法很简单，只需要在枚举定义的enum关键字之后加上class关键字就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">HighSchool</span> &#123;<br>    student,<br>    teacher,<br>    principal<br>&#125;;<br></code></pre></td></tr></table></figure><p>强枚举类型不仅实现起来非常简洁，而且还是POD类型。</p><p>我们可以在定义类型的时候使用:符号来指明其底层类型。利用它可以消除不同编译器带来的歧义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">E</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &#123;<br>    e1 = <span class="hljs-number">1</span>,<br>    e2 = <span class="hljs-number">2</span>,<br>    e3 = <span class="hljs-number">0xfffffff0</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> b = e1 &lt; e3;<br>    std::cout &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-列表初始化有底层类型枚举对象"><a href="#3-列表初始化有底层类型枚举对象" class="headerlink" title="3 列表初始化有底层类型枚举对象"></a>3 列表初始化有底层类型枚举对象</h2><p>从C++17标准开始，对有底层类型的枚举类型对象可以直接使用列表初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>  Red,<br>  Green,<br>  Blue<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Color c&#123; <span class="hljs-number">5</span> &#125;;          <span class="hljs-comment">// 编译成功</span><br>  Color c1 = <span class="hljs-number">5</span>;          <span class="hljs-comment">// 编译失败</span><br>  Color c2 = &#123; <span class="hljs-number">5</span> &#125;;      <span class="hljs-comment">// 编译失败</span><br>  <span class="hljs-function">Color <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;           <span class="hljs-comment">// 编译失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p>C++11标准中对强枚举类型初始化做了严格限制，目的就是防止枚举类型的滥用。可是C++17又打破了这种严格的限制，动机是什么？</p><p>现在假设一个场景，我们需要一个新整数类型，该类型必须严格区别于其他整型，也就是说不能够和其他整型做隐式转换，显然使用typedef的方法是不行的。另外，虽然通过定义一个类的方法可以到达这个目的，但是这个方法需要编写大量的代码来重载运算符，也不是一个理想的方案。所以，C++的专家把目光投向了有底层类型的枚举类型，其特性几乎完美地符合以上要求，除了初始化整型值的时候需要用到强制类型转换。于是，C++17为有底层类型的枚举类型放宽了初始化的限制，让其支持列表初始化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Index</span> : <span class="hljs-type">int</span> &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Index a&#123; <span class="hljs-number">5</span> &#125;;<br>  Index b&#123; <span class="hljs-number">10</span> &#125;;<br>  <span class="hljs-comment">// a = 12;</span><br>  <span class="hljs-comment">// int c = b;</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;a &lt; b is &quot;</span> <br>       &lt;&lt; std::boolalpha <br>       &lt;&lt; (a &lt; b) &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-使用using打开强枚举类型"><a href="#4-使用using打开强枚举类型" class="headerlink" title="4 使用using打开强枚举类型"></a>4 使用using打开强枚举类型</h2><p>C++20标准扩展了using功能，它可以打开强枚举类型的命名空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">ColorToString</span><span class="hljs-params">(Color c)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">switch</span> (c)<br>  &#123;<br>  <span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>;<br>  <span class="hljs-keyword">case</span> Red: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Red&quot;</span>;<br>  <span class="hljs-keyword">case</span> Green: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Green&quot;</span>;<br>  <span class="hljs-keyword">case</span> Blue: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Blue&quot;</span>;<br>  <span class="hljs-keyword">default</span>:<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;none&quot;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">ColorToString</span><span class="hljs-params">(Color c)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">switch</span> (c)<br>  &#123;<br>  <span class="hljs-keyword">using</span> Color::Red;<br>  <span class="hljs-keyword">case</span> Red: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Red&quot;</span>;<br>  <span class="hljs-keyword">case</span> Color::Green: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Green&quot;</span>;<br>  <span class="hljs-keyword">case</span> Color::Blue: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Blue&quot;</span>;<br>  <span class="hljs-keyword">default</span>:<br>       <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;none&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 13</title>
    <link href="/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-13/"/>
    <url>/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-13/</url>
    
    <content type="html"><![CDATA[<h1 id="继承构造函数（C-11）"><a href="#继承构造函数（C-11）" class="headerlink" title="继承构造函数（C++11）"></a>继承构造函数（C++11）</h1><h2 id="1-使用继承构造函数"><a href="#1-使用继承构造函数" class="headerlink" title="1 使用继承构造函数"></a>1 使用继承构造函数</h2><p>C++中可以使用using关键字将基类的函数引入派生类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Base::foo;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Derived d;<br>  d.<span class="hljs-built_in">foo</span>(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>C++11的继承构造函数正是利用了这一点，将using关键字的能力进行了扩展，使其能够引入基类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Base</span>() : <span class="hljs-built_in">x_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y_</span>(<span class="hljs-number">0.</span>) &#123;&#125;;<br>  <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y) &#123;&#125;<br>  <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(<span class="hljs-number">0.</span>) &#123;&#125;<br>  <span class="hljs-built_in">Base</span>(<span class="hljs-type">double</span> y) : <span class="hljs-built_in">x_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y_</span>(y) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x_;<br>  <span class="hljs-type">double</span> y_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Base::Base;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li><p>派生类是隐式继承基类的构造函数，所以只有在程序中使用了这些构造函数，编译器才会为派生类生成继承构造函数的代码。</p></li><li><p>派生类不会继承基类的默认构造函数和复制构造函数。这一点乍看有些奇怪，但仔细想想也是顺理成章的。因为在C++语法规则中，执行派生类默认构造函数之前一定会先执行基类的构造函数。同样的，在执行复制构造函数之前也一定会先执行基类的复制构造函数。所以继承基类的默认构造函数和默认复制构造函数的做法是多余的，这里不会这么做。</p></li><li><p>继承构造函数不会影响派生类默认构造函数的隐式声明，也就是说对于继承基类构造函数的派生类，编译器依然会为其自动生成默认构造函数的代码。</p></li><li><p>在派生类中声明签名相同的构造函数会禁止继承相应的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Base</span>() : <span class="hljs-built_in">x_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y_</span>(<span class="hljs-number">0.</span>) &#123;&#125;;<br>  <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y) &#123;&#125;<br>  <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(<span class="hljs-number">0.</span>) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base(int x)&quot;</span> &lt;&lt; std::endl; &#125;<br>  <span class="hljs-built_in">Base</span>(<span class="hljs-type">double</span> y) : <span class="hljs-built_in">x_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y_</span>(y) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base(double y)&quot;</span> &lt;&lt; std::endl; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x_;<br>  <span class="hljs-type">double</span> y_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Base::Base;<br>  <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> x) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Derived(int x)&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Derived <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>  <span class="hljs-function">Derived <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">5.5</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>派生类Derived使用using Base::Base继承了基类的构造函数，但是由于Derived定义了构造函数Derived(int x)，该函数的签名与基类的构造函数Base(int x)相同，因此这个构造函数的继承被禁止了，Derived d(5)会调用派生类的构造函数并且输出”Derived(int x)”。另外，这个禁止动作并不会影响到其他签名的构造函数，Derived d1(5.5)依然可以成功地使用基类的构造函数进行构造初始化。</p></li><li><p>派生类继承多个签名相同的构造函数会导致编译失败</p></li><li><p>继承构造函数的基类构造函数不能为私有</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 12</title>
    <link href="/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-12/"/>
    <url>/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-12/</url>
    
    <content type="html"><![CDATA[<h1 id="委托构造函数（C-11）"><a href="#委托构造函数（C-11）" class="headerlink" title="委托构造函数（C++11）"></a>委托构造函数（C++11）</h1><h2 id="1-委托构造函数"><a href="#1-委托构造函数" class="headerlink" title="1 委托构造函数"></a>1 委托构造函数</h2><p>C++11标准支持了委托构造函数：某个类型的一个构造函数可以委托同类型的另一个构造函数对对象进行初始化。为了描述方便我们称前者为委托构造函数，后者为代理构造函数（英文直译为目标构造函数）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">X</span>() : <span class="hljs-built_in">X</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.</span>) &#123;&#125;<br>  <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a) : <span class="hljs-built_in">X</span>(a, <span class="hljs-number">0.</span>) &#123;&#125;<br>  <span class="hljs-built_in">X</span>(<span class="hljs-type">double</span> b) : <span class="hljs-built_in">X</span>(<span class="hljs-number">0</span>, b) &#123;&#125;<br>  <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b) : <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(b) &#123; <span class="hljs-built_in">CommonInit</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CommonInit</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>  <span class="hljs-type">int</span> a_;<br>  <span class="hljs-type">double</span> b_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>执行顺序是先执行代理构造函数的初始化列表，接着执行代理构造函数的主体（也就是CommonInit函数），最后执行委托构造函数的主体。</p><p><strong>注意事项</strong></p><ul><li>每个构造函数都可以委托另一个构造函数为代理。也就是说，可能存在一个构造函数，它既是委托构造函数也是代理构造函数</li><li>不要递归循环委托！这一点非常重要，因为循环委托不会被编译器报错，随之而来的是程序运行时发生未定义行为，最常见的结果是程序因栈内存用尽而崩溃</li><li>如果一个构造函数为委托构造函数，那么其初始化列表里就不能对数据成员和基类进行初始化</li><li>委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体</li><li>如果在代理构造函数执行完成后，委托构造函数主体抛出了异常，则自动调用该类型的析构函数。</li></ul><h2 id="2-委托模板构造函数"><a href="#2-委托模板构造函数" class="headerlink" title="2 委托模板构造函数"></a>2 委托模板构造函数</h2><p>委托模板构造函数是指一个构造函数将控制权委托到同类型的一个模板构造函数，简单地说，就是代理构造函数是一个函数模板。这样做的意义在于泛化了构造函数，减少冗余的代码的产生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-title">X</span><span class="hljs-params">(T first, T last)</span> : l_(first, last) &#123;</span> &#125;<br>  std::list&lt;<span class="hljs-type">int</span>&gt; l_;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">X</span>(std::vector&lt;<span class="hljs-type">short</span>&gt;&amp;);<br>  <span class="hljs-built_in">X</span>(std::deque&lt;<span class="hljs-type">int</span>&gt;&amp;);<br>&#125;;<br>X::<span class="hljs-built_in">X</span>(std::vector&lt;<span class="hljs-type">short</span>&gt;&amp; v) : <span class="hljs-built_in">X</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()) &#123; &#125;<br>X::<span class="hljs-built_in">X</span>(std::deque&lt;<span class="hljs-type">int</span>&gt;&amp; v) : <span class="hljs-built_in">X</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()) &#123; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::vector&lt;<span class="hljs-type">short</span>&gt; a&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>  std::deque&lt;<span class="hljs-type">int</span>&gt; b&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>  <span class="hljs-function">X <span class="hljs-title">x1</span><span class="hljs-params">(a)</span></span>;<br>  <span class="hljs-function">X <span class="hljs-title">x2</span><span class="hljs-params">(b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-捕获委托构造函数的异常"><a href="#3-捕获委托构造函数的异常" class="headerlink" title="3 捕获委托构造函数的异常"></a>3 捕获委托构造函数的异常</h2><p>当使用Function-try-block去捕获委托构造函数异常时，其过程和捕获初始化列表异常如出一辙。如果一个异常在代理构造函数的初始化列表或者主体中被抛出，那么委托构造函数的主体将不再被执行，与之相对的，控制权会交到异常捕获的catch代码块中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">X</span>() <span class="hljs-keyword">try</span> : <span class="hljs-built_in">X</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>  <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e)<br>  &#123;<br>       std::cout &lt;&lt; <span class="hljs-string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-number">3</span>;<br>  &#125;<br>  <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a) <span class="hljs-keyword">try</span> : <span class="hljs-built_in">X</span>(a, <span class="hljs-number">0.</span>) &#123;&#125;<br>  <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e)<br>  &#123;<br>       std::cout &lt;&lt; <span class="hljs-string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-number">2</span>;<br>  &#125;<br>  <span class="hljs-built_in">X</span>(<span class="hljs-type">double</span> b) : <span class="hljs-built_in">X</span>(<span class="hljs-number">0</span>, b) &#123;&#125;<br>  <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b) : <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(b) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>; &#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a_;<br>  <span class="hljs-type">double</span> b_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>       X x;<br>  &#125;<br>  <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e) &#123;<br>       std::cout &lt;&lt; <span class="hljs-string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">catch</span>: <span class="hljs-number">1</span><br><span class="hljs-keyword">catch</span>: <span class="hljs-number">2</span><br><span class="hljs-keyword">catch</span>: <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h2 id="4-委托参数较少的构造函数"><a href="#4-委托参数较少的构造函数" class="headerlink" title="4 委托参数较少的构造函数"></a>4 委托参数较少的构造函数</h2><p>通常情况下，都是将参数较少的构造函数委托给参数较多的构造函数，因为这样做的自由度更高。但是，并不是完全否定从参数较多的构造函数委托参数较少的构造函数的意义。这种情况通常发生在构造函数的参数必须在函数体中使用的场景。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 11</title>
    <link href="/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-11/"/>
    <url>/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-11/</url>
    
    <content type="html"><![CDATA[<h1 id="非受限联合类型（C-11）"><a href="#非受限联合类型（C-11）" class="headerlink" title="非受限联合类型（C++11）"></a>非受限联合类型（C++11）</h1><h2 id="1-联合类型在C-中的局限性"><a href="#1-联合类型在C-中的局限性" class="headerlink" title="1 联合类型在C++中的局限性"></a>1 联合类型在C++中的局限性</h2><p>过去的C++标准规定，联合类型的成员变量的类型不能是一个非平凡类型，也就是说它的成员类型不能有自定义构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span><br>&#123;<br>  <span class="hljs-type">int</span> x1;<br>  <span class="hljs-type">float</span> x2;<br>  std::string x3;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码是无法通过编译的，因为x3存在自定义的构造函数，所以它是一个非平凡类型。</p><h2 id="2-使用非受限联合类型"><a href="#2-使用非受限联合类型" class="headerlink" title="2 使用非受限联合类型"></a>2 使用非受限联合类型</h2><p>在C++11中联合类型的成员可以是除了引用类型外的所有类型。</p><p>在C++11中如果有联合类型中存在非平凡类型，那么这个联合类型的特殊成员函数将被隐式删除，也就是说我们必须自己至少提供联合类型的构造和析构函数。</p><p>推荐的做法是让联合类型的构造和析构函数为空，也就是什么也不做，并且将其成员的构造和析构函数放在需要使用联合类型的地方。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span><br>&#123;<br>  <span class="hljs-built_in">U</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">U</span>() &#123;&#125;<br>  <span class="hljs-type">int</span> x1;<br>  <span class="hljs-type">float</span> x2;<br>  std::string x3;<br>  std::vector&lt;<span class="hljs-type">int</span>&gt; x4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  U u;<br>  <span class="hljs-keyword">new</span>(&amp;u.x3) std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello world&quot;</span>); <span class="hljs-comment">// placement new技巧</span><br>  std::cout &lt;&lt; u.x3 &lt;&lt; std::endl;<br>  u.x<span class="hljs-number">3.</span>~<span class="hljs-built_in">basic_string</span>();<br><br>  <span class="hljs-keyword">new</span>(&amp;u.x4) std::vector&lt;<span class="hljs-type">int</span>&gt;; <span class="hljs-comment">// placement new技巧</span><br>  u.x<span class="hljs-number">4.</span><span class="hljs-built_in">push_back</span>(<span class="hljs-number">58</span>);<br>  std::cout &lt;&lt; u.x4[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>  u.x<span class="hljs-number">4.</span>~<span class="hljs-built_in">vector</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>联合类型的静态成员不属于联合类型的任何对象，所以并不是对象构造时被定义的，不能在联合类型内部初始化。实际上这一点和类的静态成员变量是一样的，当然了，它的初始化方法也和类的静态成员变量相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span><br>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">int</span> x1;<br>&#125;;<br><span class="hljs-type">int</span> U::x1 = <span class="hljs-number">42</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; U::x1 &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 10</title>
    <link href="/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-10/"/>
    <url>/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-10/</url>
    
    <content type="html"><![CDATA[<h1 id="默认和删除函数（C-11）"><a href="#默认和删除函数（C-11）" class="headerlink" title="默认和删除函数（C++11）"></a>默认和删除函数（C++11）</h1><h2 id="1-类的特殊成员函数"><a href="#1-类的特殊成员函数" class="headerlink" title="1 类的特殊成员函数"></a>1 类的特殊成员函数</h2><ul><li>默认构造函数</li><li>析构函数</li><li>复制构造函数</li><li>复制赋值运算符函数</li><li>移动构造函数（C++11新增）</li><li>移动赋值运算符函数（C++11新增）</li></ul><p><strong>注意事项</strong></p><ol><li>声明任何构造函数都会抑制默认构造函数的添加。</li><li>一旦用自定义构造函数代替默认构造函数，类就将转变为非平凡类型。</li></ol><h2 id="2-显示默认和显示删除-C-11"><a href="#2-显示默认和显示删除-C-11" class="headerlink" title="2 显示默认和显示删除 C++11"></a>2 显示默认和显示删除 C++11</h2><p>显式默认和显式删除的语法非常简单，只需要在声明函数的尾部添加&#x3D;default和&#x3D;delete，它们分别指示编译器添加特殊函数的默认版本以及删除指定的函数。</p><ul><li>&#x3D;default可以添加到类内部函数声明，也可以添加到类外部。</li><li>&#x3D;delete与&#x3D;default不同，它必须添加在类内部的函数声明中，如果将其添加到类外部，那么会引发编译错误。</li></ul><h2 id="3-显示删除的其他用法"><a href="#3-显示删除的其他用法" class="headerlink" title="3 显示删除的其他用法"></a>3 显示删除的其他用法</h2><p>显式删除不仅适用于类的成员函数，对于普通函数同样有效。只不过相对于应用于成员函数，应用于普通函数的意义就不大了。</p><p>显式删除还可以用于类的new运算符和类析构函数。显式删除特定类的new运算符可以阻止该类在堆上动态创建对象，换句话说它可以限制类的使用者只能通过自动变量、静态变量或者全局变量的方式创建对象。</p><p>显式删除类的析构函数在某种程度上和删除new运算符的目的正好相反，它阻止类通过自动变量、静态变量或者全局变量的方式创建对象，但是却可以通过new运算符创建对象。当然了，通过new运算符创建的对象也无法通过delete销毁。</p><h2 id="4-explicit和-delete"><a href="#4-explicit和-delete" class="headerlink" title="4 explicit和&#x3D;delete"></a>4 explicit和&#x3D;delete</h2><p>在类的构造函数上同时使用explicit和&#x3D;delete是一个不明智的做法，它常常会造成代码行为混乱难以理解，应尽量避免这样做。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 9</title>
    <link href="/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-9/"/>
    <url>/2024/11/01/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-9/</url>
    
    <content type="html"><![CDATA[<h1 id="列表初始化（C-11-C-20）"><a href="#列表初始化（C-11-C-20）" class="headerlink" title="列表初始化（C++11 C++20）"></a>列表初始化（C++11 C++20）</h1><h2 id="1-回顾变量初始化"><a href="#1-回顾变量初始化" class="headerlink" title="1 回顾变量初始化"></a>1 回顾变量初始化</h2><p>一般来说，我们称使用括号初始化的方式叫作直接初始化，而使用等号初始化的方式叫作拷贝初始化（复制初始化）。请注意，这里使用等号对变量初始化并不是调用等号运算符的赋值操作。实际情况是，等号是拷贝初始化，<strong>调用的依然是直接初始化对应的构造函数</strong>，只不过这里是隐式调用而已。</p><h2 id="2-使用列表初始化-C-11"><a href="#2-使用列表初始化-C-11" class="headerlink" title="2 使用列表初始化 C++11"></a>2 使用列表初始化 C++11</h2><p>C++11标准引入了列表初始化，它使用大括号{}对变量进行初始化，和传统变量初始化的规则一样，它也区分为直接初始化和拷贝初始化。它支持隐式调用多参数的构造函数。如果不希望进行隐式转换，需要在特定的构造函数上声明explicit。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> &#123;<br>  <span class="hljs-built_in">C</span>(std::string a, <span class="hljs-type">int</span> b) &#123;&#125;<br>  <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> a) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(C)</span> </span>&#123;&#125;<br><span class="hljs-function">C <span class="hljs-title">bar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">5</span>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> x = &#123;<span class="hljs-number">5</span>&#125;;         <span class="hljs-comment">// 拷贝初始化</span><br>  <span class="hljs-type">int</span> x1&#123;<span class="hljs-number">8</span>&#125;;           <span class="hljs-comment">// 直接初始化</span><br>  C x2 = &#123;<span class="hljs-number">4</span>&#125;;          <span class="hljs-comment">// 拷贝初始化</span><br>  C x3&#123;<span class="hljs-number">2</span>&#125;;             <span class="hljs-comment">// 直接初始化</span><br>  <span class="hljs-built_in">foo</span>(&#123;<span class="hljs-number">8</span>&#125;);            <span class="hljs-comment">// 拷贝初始化</span><br>  <span class="hljs-built_in">foo</span>(&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">8</span>&#125;);   <span class="hljs-comment">// 拷贝初始化</span><br>  C x4 = <span class="hljs-built_in">bar</span>();        <span class="hljs-comment">// 拷贝初始化</span><br>  C *x5 = <span class="hljs-keyword">new</span> C&#123; <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-number">42</span> &#125;;  <span class="hljs-comment">// 直接初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-std-initializer-list详解"><a href="#3-std-initializer-list详解" class="headerlink" title="3 std::initializer_list详解"></a>3 std::initializer_list详解</h2><p>标准容器之所以能够支持列表初始化，离不开编译器支持的同时，它们自己也必须满足一个条件：支持std::initializer_list为形参的构造函数。</p><p>std::initializer_list简单地说就是一个支持begin、end以及size成员函数的类模板。编译器负责将列表里的元素（大括号包含的内容）构造为一个std::initializer_list的对象，然后寻找标准容器中支持std:: initializer_list为形参的构造函数并调用它。标准容器的构造函数只需要调用std::initializer_list对象的begin和end函数，在循环中对本对象进行初始化。</p><p>std:: initializer_list的begin和end函数并不是返回的迭代器对象，而是一个常量对象指针const T *。</p><h2 id="4-使用列表初始化的注意事项"><a href="#4-使用列表初始化的注意事项" class="headerlink" title="4 使用列表初始化的注意事项"></a>4 使用列表初始化的注意事项</h2><h3 id="4-1-隐式缩窄转换问题"><a href="#4-1-隐式缩窄转换问题" class="headerlink" title="4.1 隐式缩窄转换问题"></a>4.1 隐式缩窄转换问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">12345</span>;<br><span class="hljs-type">char</span> y = x;<br></code></pre></td></tr></table></figure><p>这段代码中变量y的初始化明显是一个隐式缩窄转换，这在传统变量初始化中是没有问题的，代码能顺利通过编译。但是如果采用列表初始化，比如char z{ x }，根据标准编译器通常会给出一个错误，MSVC和CLang就是这么做的，而GCC有些不同，它只是给出了警告。</p><p>C++中的隐式缩窄转换：</p><ul><li>从浮点类型转换整数类型。</li><li>从long double转换到double或float，或从double转换到float，除非转换源是常量表达式以及转换后的实际值在目标可以表示的值范围内。</li><li>从整数类型或非强枚举类型转换到浮点类型，除非转换源是常量表达式，转换后的实际值适合目标类型并且能够将生成目标类型的目标值转换回原始类型的原始值。</li><li>从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型，除非源是一个常量表达式，其值在转换之后能够适合目标类型。</li></ul><h3 id="4-2-列表初始化的优先级问题"><a href="#4-2-列表初始化的优先级问题" class="headerlink" title="4.2 列表初始化的优先级问题"></a>4.2 列表初始化的优先级问题</h3><p>如果有一个类同时拥有满足列表初始化的构造函数，且其中一个是以std::initializer_list为参数，那么编译器将优先以std::initializer_ list为参数构造函数。</p><h2 id="5-指定初始化-C-20"><a href="#5-指定初始化-C-20" class="headerlink" title="5 指定初始化 C++20"></a>5 指定初始化 C++20</h2><p>为了提高数据成员初始化的可读性和灵活性，C++20标准中引入了指定初始化的特性。该特性允许指定初始化数据成员的名称，从而使代码意图更加明确。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point3D</span> &#123;<br>  <span class="hljs-type">int</span> x;<br>  <span class="hljs-type">int</span> y;<br>  <span class="hljs-type">int</span> z;<br>&#125;;<br><br>Point3D p&#123; .z = <span class="hljs-number">3</span> &#125;;    <span class="hljs-comment">// x = 0, y = 0</span><br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ol><li>它要求对象必须是一个聚合类型</li><li>指定的数据成员必须是非静态数据成员</li><li>每个非静态数据成员最多只能初始化一次</li><li>非静态数据成员的初始化必须按照声明的顺序进行</li><li>针对联合体中的数据成员只能初始化一次，不能同时指定</li><li>不能嵌套指定初始化数据成员</li><li>在C++20中，一旦使用指定初始化，就不能混用其他方法对数据成员初始化了</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[RL]基本概念</title>
    <link href="/2024/10/31/RL-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/10/31/RL-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h3 id="状态（state）"><a href="#状态（state）" class="headerlink" title="状态（state）"></a>状态（state）</h3><p>智能体（agent）相对于环境的状况（status）</p><p><img src="/../images/RL-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/image-20241031181655935.png"></p><p>对于网格世界的例子，智能体的位置就是状态。</p><p><strong>状态空间：</strong>所有状态的集合 $S &#x3D; {s_i}_{i &#x3D; 1}^9$</p><h3 id="动作（action）"><a href="#动作（action）" class="headerlink" title="动作（action）"></a>动作（action）</h3><p>对于每个状态，可以采取的行动。</p><p><strong>状态的动作空间</strong></p>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 8</title>
    <link href="/2024/10/31/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-8/"/>
    <url>/2024/10/31/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-8/</url>
    
    <content type="html"><![CDATA[<h1 id="非静态数据成员默认初始化（C-11-C-20）"><a href="#非静态数据成员默认初始化（C-11-C-20）" class="headerlink" title="非静态数据成员默认初始化（C++11 C++20）"></a>非静态数据成员默认初始化（C++11 C++20）</h1><h2 id="1-使用默认初始化"><a href="#1-使用默认初始化" class="headerlink" title="1 使用默认初始化"></a>1 使用默认初始化</h2><p>在C++11以前，对非静态数据成员初始化需要用到初始化列表，当类的数据成员和构造函数较多时，编写构造函数很痛苦。</p><p>为了解决这种问题，C++11标准提出了新的初始化方法，即在声明非静态数据成员的同时直接对其使用&#x3D;或者{}（见第9章）初始化。在此之前只有类型为整型或者枚举类型的常量静态数据成员才有这种声明默认初始化的待遇。</p><p><strong>注意事项</strong></p><ul><li>不要使用括号()对非静态数据成员进行初始化，因为这样会造成解析问题，所以会编译错误。</li><li>不要用auto来声明和初始化非静态数据成员。</li></ul><h2 id="2-位域的默认初始化（后续再看）"><a href="#2-位域的默认初始化（后续再看）" class="headerlink" title="2 位域的默认初始化（后续再看）"></a>2 位域的默认初始化（后续再看）</h2><p>在C++11标准提出非静态数据成员默认初始化方法之后，C++20标准又对该特性做了进一步扩充。在C++20中我们可以对数据成员的位域进行默认初始化了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span>  <span class="hljs-title class_">S</span> &#123;<br>  <span class="hljs-type">int</span> y : <span class="hljs-number">8</span> = <span class="hljs-number">11</span>;<br>  <span class="hljs-type">int</span> z : <span class="hljs-number">4</span> &#123;<span class="hljs-number">7</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>int数据的低8位被初始化为11，紧跟它的高4位被初始化为7。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 7</title>
    <link href="/2024/10/31/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-7/"/>
    <url>/2024/10/31/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-7/</url>
    
    <content type="html"><![CDATA[<h1 id="lambda表达式（C-11～C-20）"><a href="#lambda表达式（C-11～C-20）" class="headerlink" title="lambda表达式（C++11～C++20）"></a>lambda表达式（C++11～C++20）</h1><h2 id="1-lambda表达式语法"><a href="#1-lambda表达式语法" class="headerlink" title="1 lambda表达式语法"></a>1 lambda表达式语法</h2><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[ captures ] ( params ) specifiers exception -&gt; ret &#123; body &#125;<br></code></pre></td></tr></table></figure><ul><li>[ captures ] —— 捕获列表，它可以捕获当前函数作用域的零个或多个变量，变量之间用逗号分隔。捕获列表的捕获方式有两种：按值捕获和引用捕获。</li><li>( params ) —— 可选参数列表，语法和普通函数的参数列表一样，在不需要参数的时候可以忽略参数列表。</li><li>specifiers —— 可选限定符，C++11中可以用mutable，它允许我们在lambda表达式函数体内改变按值捕获的变量，或者调用非const的成员函数。</li><li>exception —— 可选异常说明符，我们可以使用noexcept来指明lambda是否会抛出异常。</li><li>ret —— 可选返回值类型，不同于普通函数，lambda表达式使用返回类型后置的语法来表示返回类型，如果没有返回值（void类型），可以忽略包括-&gt;在内的整个部分。另外，我们也可以在有返回值的情况下不指定返回类型，这时编译器会为我们推导出一个返回类型。</li><li>{ body } —— lambda表达式的函数体，这个部分和普通函数的函数体一样。</li></ul><h2 id="2-捕获列表"><a href="#2-捕获列表" class="headerlink" title="2 捕获列表"></a>2 捕获列表</h2><h3 id="2-1-作用域"><a href="#2-1-作用域" class="headerlink" title="2.1 作用域"></a>2.1 作用域</h3><p>捕获列表中的变量存在于两个作用域</p><ul><li>lambda表达式定义的函数作用域</li><li>lambda表达式函数体的作用域。</li></ul><p>前者是为了捕获变量，后者是为了使用变量。</p><p>标准规定能捕获的变量必须是一个<strong>自动存储类型</strong>。简单来说就是<strong>非静态的局部变量</strong>。</p><p>如果想使用全局变量或者局部静态变量，直接使用就可以，无需捕获。</p><h3 id="2-2-捕获值和捕获引用"><a href="#2-2-捕获值和捕获引用" class="headerlink" title="2.2 捕获值和捕获引用"></a>2.2 捕获值和捕获引用</h3><p><strong>捕获值</strong></p><p>直接在捕获列表中写入变量名即可，多个变量用逗号分隔。</p><p>捕获值是将函数作用域的x和y的值复制到lambda表达式对象的内部，就如同lambda表达式的成员变量一样。</p><p><strong>捕获引用</strong></p><p>捕获引用的语法与捕获值只有一个&amp;的区别，要表达捕获引用我们只需要在捕获变量之前加上&amp;。</p><p><strong>改变捕获值</strong></p><p>lambda表达式捕获的变量默认为常量，或者说lambda是一个常量函数（类似于常量成员函数）。所以，值捕获的变量无法在lambda表达式内部修改，而引用捕获的变量可以修改（这是因为修改引用捕获的变量，实际是修改引用绑定的变量，而引用本身并没有被修改）。</p><p>为了修改值捕获的变量，需要用到 <code>mutable</code> 说明符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">auto</span> foo = [x, y] () <span class="hljs-keyword">mutable</span> &#123;<br>        x += <span class="hljs-number">1</span>;<br>        y += <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> x * y;<br>    &#125;;<br>    std::cout &lt;&lt; <span class="hljs-built_in">foo</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项</strong></p><ul><li>值捕获的变量是原本变量的一个副本，修改不会影响原本的变量，但是引用捕获的变量会影响原本的变量。</li><li>在lambda表达式内部修改某个按值捕获的变量，每一次调用lambda表达式造成的修改，都会影响下一次的调用。</li><li>捕获值的变量在lambda表达式定义的时候已经固定下来了，无论函数在lambda表达式定义后如何修改外部变量的值，lambda表达式捕获的值都不会变化</li></ul><h3 id="2-3-特殊的捕获方法"><a href="#2-3-特殊的捕获方法" class="headerlink" title="2.3 特殊的捕获方法"></a>2.3 特殊的捕获方法</h3><p>lambda表达式的捕获列表除了指定捕获变量之外还有3种特殊的捕获方法</p><ul><li>[this] —— 捕获this指针，捕获this指针可以让我们使用this类型的成员变量和函数。</li><li>[&#x3D;] —— 捕获lambda表达式定义作用域的全部变量的值，包括this。</li><li>[&amp;] —— 捕获lambda表达式定义作用域的全部变量的引用，包括this。</li></ul><h2 id="3-lambda表达式的实现原理"><a href="#3-lambda表达式的实现原理" class="headerlink" title="3 lambda表达式的实现原理"></a>3 lambda表达式的实现原理</h2><p>在C++11标准中，lambda表达式的优势在于书写简单方便且易于维护，而函数对象的优势在于使用更加灵活不受限制，但总的来说它们非常相似。实际上这也正是lambda表达式的实现原理。</p><p>lambda表达式在编译期会由编译器自动生成一个闭包类，在运行时由这个闭包类产生一个对象，我们称它为闭包。在C++中，所谓的闭包可以简单地理解为一个匿名且可以包含定义时作用域上下文的函数对象。</p><h2 id="4-无状态lambda表达式"><a href="#4-无状态lambda表达式" class="headerlink" title="4 无状态lambda表达式"></a>4 无状态lambda表达式</h2><p>C++标准对于无状态的lambda表达式有着特殊的照顾，即它可以隐式转换为函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">void</span>(*)())</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">f</span>([] &#123;&#125;); &#125; <span class="hljs-comment">// 编译成功</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">void</span>(&amp;)())</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">f</span>(*[] &#123;&#125;); &#125;<br></code></pre></td></tr></table></figure><h2 id="5-在STL中使用lambda表达式"><a href="#5-在STL中使用lambda表达式" class="headerlink" title="5 在STL中使用lambda表达式"></a>5 在STL中使用lambda表达式</h2><p>STL中常常会见到这样一些算法函数，它们的形参需要传入一个函数指针或函数对象从而完成整个算法，例如std::sort、std::find_if等。</p><p>使用lambda表达式直接在传参时定义了辅助函数。无论是编写还是阅读代码，直接定义lambda表达式都比定义辅助函数更加简洁且容易理解。</p><h2 id="6-广义捕获-C-14-（后续再看）"><a href="#6-广义捕获-C-14-（后续再看）" class="headerlink" title="6 广义捕获 C++14 （后续再看）"></a>6 广义捕获 C++14 （后续再看）</h2><p>C++14标准中定义了广义捕获，所谓广义捕获实际上是两种捕获方式，</p><ol><li><p>简单捕获，这种捕获就是前文中提到的捕获方法，即[identifier]、[&amp;identifier]以及[this]等。</p></li><li><p>初始化捕获，这种捕获方式是在C++14标准中引入的，它解决了简单捕获的一个重要问题，即只能捕获lambda表达式定义上下文的变量，而无法捕获表达式结果以及自定义捕获变量名，比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> foo = [r = x + <span class="hljs-number">1</span>]&#123; <span class="hljs-keyword">return</span> r; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>初始化捕获在某些场景下是非常实用的</p><ol><li><p>使用移动操作减少代码运行的开销，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string x = <span class="hljs-string">&quot;hello c++ &quot;</span>;<br>    <span class="hljs-keyword">auto</span> foo = [x = std::<span class="hljs-built_in">move</span>(x)]&#123; <span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot;world&quot;</span>; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在异步调用时复制this对象，防止lambda表达式被调用时因原始this对象被析构造成未定义的行为，比如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Work</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Work</span>() : <span class="hljs-built_in">value</span>(<span class="hljs-number">42</span>) &#123;&#125;<br>    <span class="hljs-function">std::future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spawn</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">async</span>([=, tmp = *<span class="hljs-keyword">this</span>]() -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> tmp.value; &#125;);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="7-泛型lambda表达式-C-14"><a href="#7-泛型lambda表达式-C-14" class="headerlink" title="7 泛型lambda表达式 C++14"></a>7 泛型lambda表达式 C++14</h2><p>C++14标准让lambda表达式具备了模版函数的能力，即<strong>泛型lambda表达式</strong>。泛型lambda表达式语法只需要使用auto占位符即可，例如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> foo = [](<span class="hljs-keyword">auto</span> a) &#123; <span class="hljs-keyword">return</span> a; &#125;;<br>    <span class="hljs-type">int</span> three = <span class="hljs-built_in">foo</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">char</span> <span class="hljs-type">const</span>* hello = <span class="hljs-built_in">foo</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-常量lambda表达式和捕获-this-C-17"><a href="#8-常量lambda表达式和捕获-this-C-17" class="headerlink" title="8 常量lambda表达式和捕获*this C++17"></a>8 常量lambda表达式和捕获*this C++17</h2><p>C++17标准对lambda表达式同样有两处增强</p><ul><li><p>常量lambda表达式</p></li><li><p>对捕获*this的增强。</p><p><code>[*this]</code> 的语法让程序生成了一个*this对象的副本并存储在lambda表达式内，可以在lambda表达式内直接访问这个复制对象的成员，消除了之前lambda表达式需要通过tmp访问对象成员的尴尬。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Work</span><br>&#123;<br>  <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Work</span>() : <span class="hljs-built_in">value</span>(<span class="hljs-number">42</span>) &#123;&#125;<br>    <span class="hljs-function">std::future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spawn</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">async</span>([=, *<span class="hljs-keyword">this</span>]() -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> value; &#125;);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h2 id="9-捕获-this-C-20"><a href="#9-捕获-this-C-20" class="headerlink" title="9 捕获[&#x3D;, this] C++20"></a>9 捕获[&#x3D;, this] C++20</h2><p>[&#x3D;] 可以捕获this指针，相似的，<code>[=,*this]</code> 会捕获this对象的副本。但是在代码中大量出现[&#x3D;]和 <code>[=,*this]</code> 的时候我们可能很容易忘记前者与后者的区别。为了解决这个问题，在C++20标准中引入了[&#x3D;, this]捕获this指针的语法，它实际上表达的意思和[&#x3D;]相同，目的是让程序员们区分它与 <code>[=,*this]</code> 的不同</p><p>在C++20标准中还特别强调了要用[&#x3D;, this]代替[&#x3D;]</p><p>同时用两种语法捕获this指针是不允许的，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[<span class="hljs-keyword">this</span>, *<span class="hljs-keyword">this</span>]&#123;&#125;;<br></code></pre></td></tr></table></figure><h2 id="10-模板语法的泛型lambda表达式-C-20"><a href="#10-模板语法的泛型lambda表达式-C-20" class="headerlink" title="10 模板语法的泛型lambda表达式 C++20"></a>10 模板语法的泛型lambda表达式 C++20</h2><p>C++20中添加模板对lambda的支持，语法非常简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">[]&lt;<span class="hljs-keyword">typename</span> T&gt;(T t) &#123;&#125;<br><br><span class="hljs-keyword">auto</span> f = []&lt;<span class="hljs-keyword">typename</span> T&gt;(std::vector&lt;T&gt; vector) &#123;<br><span class="hljs-comment">// …</span><br>&#125;;<br><br><span class="hljs-keyword">auto</span> f = []&lt;<span class="hljs-keyword">typename</span> T&gt;(T <span class="hljs-type">const</span>&amp; x) &#123;<br>T copy = x;<br><span class="hljs-keyword">using</span> Iterator = <span class="hljs-keyword">typename</span> T::iterator;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="11-可构造和可赋值的无状态lambda表达式-C-20"><a href="#11-可构造和可赋值的无状态lambda表达式-C-20" class="headerlink" title="11 可构造和可赋值的无状态lambda表达式 C++20"></a>11 可构造和可赋值的无状态lambda表达式 C++20</h2><p>在C++20标准之前无状态的lambda表达式类型既不能构造也无法赋值，这阻碍了许多应用的实现。</p><p>举例来说，我们已经了解了像std::sort和std::find_if这样的函数需要一个函数对象或函数指针来辅助排序和查找，这种情况我们可以使用lambda表达式完成任务。但是如果遇到std::map这种容器类型就不好办了，因为std::map的比较函数对象是通过模板参数确定的，这个时候我们需要的是一个类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> greater = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) &#123; <span class="hljs-keyword">return</span> x &gt; y; &#125;;<br>std::map&lt;std::string, <span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(greater)&gt; mymap;<br><br><span class="hljs-keyword">auto</span> greater = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) &#123; <span class="hljs-keyword">return</span> x &gt; y; &#125;;<br>std::map&lt;std::string, <span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(greater)&gt; mymap1, mymap2;<br>mymap1 = mymap2;<br></code></pre></td></tr></table></figure><p>上述代码在C++17中不可行，因为lambda表达式类型无法构造也无法赋值。</p><p>在C++17中要想让上述代码通过编译，需要明确的将greater对象传递给mymap</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> greater = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) &#123; <span class="hljs-keyword">return</span> x &gt; y; &#125;;<br><span class="hljs-function">std::map&lt;std::string, <span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(greater)</span>&gt; <span class="hljs-title">mymap</span><span class="hljs-params">(greater)</span></span>;<br></code></pre></td></tr></table></figure><p>C++20标准允许了无状态lambda表达式类型的构造和赋值，所以使用C++20标准的编译环境来编译上面的代码是可行的。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]2140.解决智力问题</title>
    <link href="/2024/10/31/LC-2140-%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2024/10/31/LC-2140-%E8%A7%A3%E5%86%B3%E6%99%BA%E5%8A%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>questions</code> ，其中 <code>questions[i] = [pointsi, brainpoweri]</code> 。</p><p>这个数组表示一场考试里的一系列题目，你需要 <strong>按顺序</strong> （也就是从问题 <code>0</code> 开始依次解决），针对每个问题选择 <strong>解决</strong> 或者 <strong>跳过</strong> 操作。解决问题 <code>i</code> 将让你 <strong>获得</strong> <code>pointsi</code> 的分数，但是你将 <strong>无法</strong> 解决接下来的 <code>brainpoweri</code> 个问题（即只能跳过接下来的 <code>brainpoweri</code> 个问题）。如果你跳过问题 <code>i</code> ，你可以对下一个问题决定使用哪种操作。</p><p>比方说，给你 </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">questions = <span class="hljs-comment">[<span class="hljs-comment">[3, 2]</span>, <span class="hljs-comment">[4, 3]</span>, <span class="hljs-comment">[4, 4]</span>, <span class="hljs-comment">[2, 5]</span>]</span><br></code></pre></td></tr></table></figure><ul><li>如果问题 <code>0</code> 被解决了， 那么你可以获得 <code>3</code> 分，但你不能解决问题 <code>1</code> 和 <code>2</code> 。</li><li>如果你跳过问题 <code>0</code> ，且解决问题 <code>1</code> ，你将获得 <code>4</code> 分但是不能解决问题 <code>2</code> 和 <code>3</code> 。</li></ul><p>请你返回这场考试里你能获得的 <strong>最高</strong> 分数。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>考虑用$dp[i]$表示解决前$i$道题目可以获得的最高分数，此时有两种情况：</p><ul><li>如果不解决第$i$道题目，那么$dp[i] &#x3D; dp[i - 1]$.</li><li>如果解决第$i$道题目，那么$dp[i] &#x3D; points[i] + max(0, max_{0 \leq j &lt; i, j + brainpower[j] &lt; i}{dp[j]})$.</li></ul><p>时间复杂度为$O(n^2)$.</p><p><strong>后效性</strong></p><p>对于每一道题目，解决与否不会影响前面的题目，因此可以考虑反方向定义状态，即$dp[i]$表示解决第$i$道题目及以后的题目可以获得的最高分数，那么有状态转移方程：</p><ul><li>如果不解决第$i$道题目，那么$dp[i] &#x3D; dp[i + 1]$.</li><li>如果解决第$i$道题目，那么$dp[i] &#x3D; points[i] + dp[i + brainpower[i] + 1]$.</li></ul><p>注意，需要考虑数组越界的问题，如果越界，那么$dp[i] &#x3D; 0, i &gt;&#x3D; n$.</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">mostPoints</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; questions)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = questions.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> dp = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>], questions[i][<span class="hljs-number">0</span>] + dp[<span class="hljs-built_in">min</span>(n, i + questions[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度:</strong> $O(n)$.</p><p><strong>空间复杂度:</strong>$O(n)$.</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OOP]C++面向对象高效编程 Chapter 2</title>
    <link href="/2024/10/28/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/"/>
    <url>/2024/10/28/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是数据抽象"><a href="#什么是数据抽象" class="headerlink" title="什么是数据抽象"></a>什么是数据抽象</h1><span id="more"></span><p>数据抽象（data abstraction）在忽略类对象间存在差异的同时，展现了对用户而言最重要的特性。的确，抽象应该对终端用户隐藏无关紧要的细节，避免暴露有可能分散用户注意力或与使用环境毫不相干的细节。</p><h2 id="1-接口和实现的分离"><a href="#1-接口和实现的分离" class="headerlink" title="1 接口和实现的分离"></a>1 接口和实现的分离</h2><p><strong>接口的含义</strong></p><p>类对象的接口支持外部视图，接口就是用户观察的对象视图，以及用户可以用接口做什么（也包括接口对用户做什么）。</p><p>当我们设计接口时，应最大程度地满足用户的要求，这些用户也称为客户（client）。所谓类的客户，就是使用类且不知道（或不用关心）类内部运作的人。客户可创建类的对象，并通过接口对其进行操作。</p><p><strong>实现的含义</strong></p><p>接口告诉客户可以做什么，实现则负责如何做，所有的工作都在实现中完成。客户无需了解类如何实现接口所提供的操作。因此，实现用于支持由对象表现的接口。</p><h2 id="2-对象接口的重要性"><a href="#2-对象接口的重要性" class="headerlink" title="2 对象接口的重要性"></a>2 对象接口的重要性</h2><p>数据抽象的目的是，提供清晰和充足的接口，在方便且受控的模式下允许用户访问底层实现。</p><h2 id="3-保护实现"><a href="#3-保护实现" class="headerlink" title="3 保护实现"></a>3 保护实现</h2><p>如果实现在生存期内无法保证自身的完整性，这样的实现则毫无用处。</p><p>接口（速度表、ATM、电源插座）都由实现支持，而且该实现由对应的接口来保护（即接口提供一个清晰且定义明确的方法访问实现）。换言之，实现以特定方式工作，并跟踪自身的状态。另外，实现假设它的状态仅能通过接口更改，如果违反此前提条件（即不知何故，实现的状态被直接从外部更改，并未通过提供的接口更改），则无法保证实现进行正确地操作。</p><p>数据抽象引出了相关的概念：数据封装（data encapsulation）。只要存在由实现支持的带接口的对象，就一定存在实现隐藏（implementation hiding）（也称为信息隐藏）。有些信息对实现而言相当重要，但是对使用接口的用户而言却毫无价值，这些信息将被隐藏在实现中。实现由接口封装，而且接口是访问该实现的唯一合法途径。</p><p>被封装的数据对于对象的实现极其重要。进一步而言，实现必须维护被封装信息的完整（或正确的状态）。</p><h2 id="4-数据封装的优点"><a href="#4-数据封装的优点" class="headerlink" title="4 数据封装的优点"></a>4 数据封装的优点</h2><p>数据被封装后，客户无法直接访问，更不能修改，只有接口函数才可访问和修改封装的信息。进一步而言，使用接口的用户完全不知道描述该接口的函数如何使用封装信息，而且对象（或类）的用户对此也毫无兴趣。</p><p>数据封装的另一个优点是<strong>实现独立（implementation independence）</strong>。由于类的用户无法查看封装的数据（或信息），他们甚至不会注意到封装数据的存在。因此，改动封装内的数据不会（也不该）影响用户所见的接口。</p><h2 id="5-接口、实现和数据封装之间的关系"><a href="#5-接口、实现和数据封装之间的关系" class="headerlink" title="5 接口、实现和数据封装之间的关系"></a>5 接口、实现和数据封装之间的关系</h2><ul><li>接口是任何类（和它的对象）客户的视图；</li><li>接口由封装的实现支持；</li><li>改变类的实现（支持接口）不应该影响该类客户所见的接口；</li><li>封装的实现能让实现者修改实现但不影响接口。即客户使用的接口与支持接口的实现彼此独立；</li></ul><h2 id="6-确定封装的内容"><a href="#6-确定封装的内容" class="headerlink" title="6 确定封装的内容"></a>6 确定封装的内容</h2><ul><li>如果某项对于用户理解类毫无帮助，封装该项，即从接口中移除该项根本不会减少类的效用；</li><li>如果某项包含敏感数据（商业秘密、专利信息、个人信息等），为了不让用户直接访问，封装该项；</li><li>如果某些项有潜在的危险（激光束、X射线、微波等），并且要求用户掌握特殊技能（普通用户不具备）才能操作，则封装该项；</li><li>如果类为了自我管理而使用某些元素，且对接口意义不大，应封装这些元素；</li><li>如果某些项倾向于在将来进行改动（为了使用更新的技术或者让其更快或更安全），必须从类的接口中移除，封装这些项。</li></ul><h2 id="7-抽象数据类型"><a href="#7-抽象数据类型" class="headerlink" title="7 抽象数据类型"></a>7 抽象数据类型</h2><p><strong>抽象数据类型</strong>是由程序员定义的新类型，附带一组操控新类型的操作。定义新抽象类型将直接应用数据抽象的概念。抽象数据类型也称为程序员定义类型（programmer defined type）。</p><h2 id="8-对象是重点"><a href="#8-对象是重点" class="headerlink" title="8 对象是重点"></a>8 对象是重点</h2><p>在面向对象编程中，我们总是使用对象。要牢记：无论何时我们讨论调用函数或发送消息时，都必须涉及一个对象。我们通过对象调用函数（或发送消息给对象），在没有对象接收消息的情况下，不能发送消息。必须有的放矢，对象即是目标。</p><h2 id="9-什么是多线程安全类"><a href="#9-什么是多线程安全类" class="headerlink" title="9 什么是多线程安全类"></a>9 什么是多线程安全类</h2><p>一个进程内的两个线程可以使用相同的对象。当一个线程调用一个成员函数，在成员函数内部完成执行之前，如果（操作系统）调度（schedule）另一个线程运行，且该线程也通过相同的对象调用相同的成员函数，则对象必须保证自身完整和运行良好。如果对象不能做到这一点，这样的类就不是<strong>线程安全（thread-safe）</strong>的。</p><h2 id="10-确保抽象的可靠性——类不变式和断言"><a href="#10-确保抽象的可靠性——类不变式和断言" class="headerlink" title="10 确保抽象的可靠性——类不变式和断言"></a>10 确保抽象的可靠性——类不变式和断言</h2><h3 id="10-1-类不变式"><a href="#10-1-类不变式" class="headerlink" title="10.1 类不变式"></a>10.1 类不变式</h3><p>每个类都会在对象中包含一些恒为真的条件，无论对象调用任何成员函数，这些条件都必须为真。这样的条件称为类不变式（class invariant）。</p><h3 id="10-2-前置条件和后置条件"><a href="#10-2-前置条件和后置条件" class="headerlink" title="10.2 前置条件和后置条件"></a>10.2 前置条件和后置条件</h3><p>成员函数可能会包含其他条件，在执行代码前必须保证这些条件为真。这些在操作开始被调用之前必须为真的条件，称为<strong>前置条件（precondition）</strong>。</p><p>在C和C++中，断言已经使用很长一段时间。所有的C和C++编译器都支持assert宏。该宏接受一个表达式，而且必须判断表达式的真假。倘若表达式判断为真，则继续执行；倘若表达式为假，则程序停止，并显示错误消息表明断言失败。</p><h3 id="10-3-高效使用断言"><a href="#10-3-高效使用断言" class="headerlink" title="10.3 高效使用断言"></a>10.3 高效使用断言</h3><p>高效使用断言可实现更可靠的程序。当条件不成立时，断言至少保证程序不会继续执行。但是发生断言失败，就不可能再复原。要解决这个问题，需要用到 C++支持的真正的异常管理工具。</p><h2 id="11-统一建模语言（UML）"><a href="#11-统一建模语言（UML）" class="headerlink" title="11 统一建模语言（UML）"></a>11 统一建模语言（UML）</h2><h3 id="11-1-类和对象的表示"><a href="#11-1-类和对象的表示" class="headerlink" title="11.1 类和对象的表示"></a>11.1 类和对象的表示</h3><p>类用矩形表示。类名通常用粗体表示。属性在类名下的第二栏中列出，操作在类名下的第三栏中列出。在高级概述图中，第二栏和第三栏可以省略，只在矩形中显示类名即可。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028193708004.png"></p><p>在类名的上方可以规定类的衍型（stereotype）。衍型表示它是何种类型的类，如异常类、控制类、接口类等。衍型包含在一对双尖括号中。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028193938215.png"></p><p>抽象类的名称用斜体表示，抽象操作也用斜体表示。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028194101136.png"></p><p>对象用矩形表示，矩形中的对象名和类名带下划线。</p><p>顶格中以对象名：类名的形式显示。匿名对象可以省略对象名。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028194115589.png"></p><h3 id="11-2-UML中类的关系"><a href="#11-2-UML中类的关系" class="headerlink" title="11.2 UML中类的关系"></a>11.2 UML中类的关系</h3><h4 id="11-2-1-关联关系"><a href="#11-2-1-关联关系" class="headerlink" title="11.2.1 关联关系"></a>11.2.1 关联关系</h4><p>关联表示对象与不同类之间的结构关系（structual relationship），大多数关联都是二元关系（binary relation）。类之间的多重关联（multiple association）和类本身的自关联（self association）都是合法的。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028194319605.png"></p><p>每个关联的末端就是角色。每个角色都有一个名称，说明其他的类如何看待这个类。Company将Person看做成“雇员”。类似地，Person将Company看成“雇主”。角色名必须唯一，它比关联名更重要。</p><p>每个角色都说明了类的多重性（multiplicity）。例如，Person可以为许多公司工作（即人与许多公司相关联）。这说明角色的多重性。符号 <code>*</code> 表明“许多”（对象的无限数目，其表示为 0..*）。多重性也可以是一个数字（1或5等等），或者是一个范围（1..5）。</p><p>关联末端的箭头表明关联的导航性。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028194707559.png"></p><p>一个类还可以与本身形成关联，即成为关联类（association class）。在关联线用虚线引出的类，即是关联类。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028194912827.png"></p><h4 id="11-2-2-包含关系（has-a）"><a href="#11-2-2-包含关系（has-a）" class="headerlink" title="11.2.2 包含关系（has-a）"></a>11.2.2 包含关系（has-a）</h4><p><strong>聚集</strong></p><p>聚集（aggregation）是一种特殊形式的关联。这种情况下，部分（即整体所包含的部分）的生存期不再取决于整体的生存期。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028195042337.png"></p><p>通过一个空菱形连接的类为聚集。不能在线的两端都绘制菱形。当类之间没有生存期依赖时，该表示法用于表示常见的<strong>按引用聚集</strong>。Orchestra（管弦乐队）是Performer（演奏者）的全体演出者。如果将表示聚集的空菱形填充，则表示<strong>组合（composition）</strong>——聚集的一种加强的形式。</p><p><strong>组合</strong></p><p>这是一种聚集形式，有很强的生存期，且部分和整体之间的所有权依赖关系也很强。聚集（容器）的多重性不能超过1个（无共享）。组合的对象一起被创建，一起被销毁。</p><p>当多重性（基数）大于 1 时，可以在创建聚集本身后再创建部分（part），除非在聚集被销毁前，显式移除部分，否则部分会和聚集一起被销毁。一架 AirPlane 有多个 Engine和多个Seat等，而且在AirPlane类对象的生存期内，可以添加或移除Seat。当AirPlane类对象被销毁后，它所包含的所有对象都会被销毁，除非它们已经从AirPlane类对象中移除（例如，座椅可能被移除，复用于另一架飞机中）。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028201313888.png"></p><p><strong>OR关联</strong></p><p>在某些情况下，一个类可以参与两个关联，但是每个对象一次只能参与一个关联。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028201147824.png"></p><h4 id="11-2-3-泛化关系（is-a）"><a href="#11-2-3-泛化关系（is-a）" class="headerlink" title="11.2.3 泛化关系（is-a）"></a>11.2.3 泛化关系（is-a）</h4><p>泛化关系用于表示继承，意味着从基类到派生类的一般——特殊关系，图中的箭头必须为空心</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-2/image-20241028201814607.png"></p>]]></content>
    
    
    <categories>
      
      <category>面向对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OOP]C++面向对象高效编程 Chapter 1</title>
    <link href="/2024/10/28/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-1/"/>
    <url>/2024/10/28/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h1><span id="more"></span><h2 id="1-理解对象模型"><a href="#1-理解对象模型" class="headerlink" title="1 理解对象模型"></a>1 理解对象模型</h2><p>OOP中的基本实体是类。对象是类的实例。</p><p>在OOP中，函数通过对象调用。</p><h2 id="2-理解消息、方法和实例变量"><a href="#2-理解消息、方法和实例变量" class="headerlink" title="2 理解消息、方法和实例变量"></a>2 理解消息、方法和实例变量</h2><p>类的任何用户（另一个程序、另一个类等）都是类的客户。客户通过类的对象使用成员函数（消息）进行有用的操作。</p><p>消息只是客户所见的一个名称，该名称可能在运行期被绑定在正确的实现上（方法）。类的每个示例都包含实例变量的单独副本。</p><h2 id="3-什么可以作为类"><a href="#3-什么可以作为类" class="headerlink" title="3 什么可以作为类"></a>3 什么可以作为类</h2><p>类拥有一组对象的共同属性（或者特性）。</p><p>类不只是容器，不能认为它仅仅用于存储被函数修改的数据。类为客户提供了复杂实体的简化版本，并允许客户通过操作类的对象完成有用的工作。类不只是将它的各个部分简单地组合起来而已。类决定如何完成任务，它清楚地陈述了该类的对象可以做什么。</p><h2 id="4-什么不是类"><a href="#4-什么不是类" class="headerlink" title="4 什么不是类"></a>4 什么不是类</h2><p>一个 C“结构”不能直接成为一个类。不能将结构修改成类，让所有数据成为私有数据，然后添加一组函数来获得和设置数据成员，这不是类。类不只是一组允许客户获取和设置数据成员值的函数。数据封装隐藏了类中的数据，而且通过成员函数提供更高层次的抽象。如果只是让函数读写结构中的数据，其实并未简化任何东西。只包含获值函数（getter）和设值函数（setter）的类是糟糕的设计。</p><h2 id="5-类的目的"><a href="#5-类的目的" class="headerlink" title="5 类的目的"></a>5 类的目的</h2><p>设计类的目的必须非常明确。一个优秀的类应该易于理解和使用，必须清楚地向客户说明其目的。每个类都是为特定领域的某种用途而设计的。</p><p>类（实际上是类的对象）负责履行其功能。当设计出类后，它（实际上是类的设计人员）便对客户承诺了它的功能。程序在执行时，类会负责管理一些细节，因此客户不用担心。</p><h2 id="6-深入了解对象"><a href="#6-深入了解对象" class="headerlink" title="6 深入了解对象"></a>6 深入了解对象</h2><p>区别类和对象是一个逻辑问题。简单地说，对象是带有状态和行为的活的实体。所有类对象的行为都定义在类中，而状态则由对象单独维护。</p><h3 id="6-1-对象的状态"><a href="#6-1-对象的状态" class="headerlink" title="6.1 对象的状态"></a>6.1 对象的状态</h3><p>每个BankAccount类对象中都有一个balance数据成员。假设我们不允许客户的账户透支，那么，只需声明账户中的余额不允许小于0。这是任何银行账户对象的已知性质（property），我们不必检查对象的状态来确认这个属性。也就是说，这是每个银行账户对象的<strong>静态性质（static property）</strong>。然而，在BankAccout类对象生存期内的任何时候，账户中的余额都是balance数据成员中的值。该数据成员的值随着账户的存款、转账、取款不断变化。因此，账户余额是一个动态变化的值。换言之，balance 数据成员是一个动态值。<strong>对象的状态是所有静态性质以及这些静态性质的动态值的集合。</strong></p><h3 id="6-2-对象状态的重要性"><a href="#6-2-对象状态的重要性" class="headerlink" title="6.2 对象状态的重要性"></a>6.2 对象状态的重要性</h3><p>对象如何响应我们的命令（操作）以及对其他对象（客户）做什么，都直接依赖于对象的状态；执行某方法所得的结果也直接依赖于对象的状态。</p><h3 id="6-3-谁控制对象的状态"><a href="#6-3-谁控制对象的状态" class="headerlink" title="6.3 谁控制对象的状态"></a>6.3 谁控制对象的状态</h3><p>对象的状态通过成员函数修改。类假定无法从外部修改对象的状态。所有不让普通客户访问的数据都应封装在类的private区域中。这也称为<strong>数据封装（data encapsulation）</strong>。</p><h3 id="6-4-对象的行为"><a href="#6-4-对象的行为" class="headerlink" title="6.4 对象的行为"></a>6.4 对象的行为</h3><p>对象的行为在某种方式上是对客户调用消息的响应。行为是对象对消息采取的行动和做出的反应。消息会引起状态的变化，也会引起发送更多的消息至其他对象，或两者兼有之。</p><h2 id="7-面向对象软件开发的阶段"><a href="#7-面向对象软件开发的阶段" class="headerlink" title="7 面向对象软件开发的阶段"></a>7 面向对象软件开发的阶段</h2><h3 id="7-1-面向对象分析OOA"><a href="#7-1-面向对象分析OOA" class="headerlink" title="7.1 面向对象分析OOA"></a>7.1 面向对象分析OOA</h3><p>从简单描述问题开始（大多数都不完整），这是面向对象软件开发过程的起点。在这一阶段中，我们要找到合适的类。</p><p>面向对象分析（Object-Oriented Analysis，缩写OOA）涉及从类和对象的角度分析问题，这些类和对象都要从问题领域（problem domain）中找出。但是，这些类并不是在最终实现中能直接使用的类。整个过程基本上是一个建模练习，即尝试建立问题领域的模型。本阶段的任务主要是，彻底地分析问题和明确地指定要求。要在客户的问题领域找出类和对象，并用其完整地描述什么方案可行，什么方案不可行。换言之，我们应采用客户能够理解的类和对象来描述问题。这些类和对象都可以直接在问题领域中找到。</p><p>在OOA阶段中，我们应该将注意力放在问题领域中使用的类，而非实现中使用的类。实现的细节将在面向对象设计（OOD）阶段实现。</p><h3 id="7-2-面向对象设计OOD"><a href="#7-2-面向对象设计OOD" class="headerlink" title="7.2 面向对象设计OOD"></a>7.2 面向对象设计OOD</h3><p>OOD（面向对象设计）阶段在OOA（面向对象分析）阶段之后，在本阶段中，我们将在OOA阶段开发的框架中加入细节，待解决的问题将被分解为类和对象用于实现中。本阶段需要完成的任务包括<strong>定义类之间的关系</strong>、<strong>描述对象如何才能适应系统的进程模型</strong>、<strong>如何跨地址空间划分对象</strong>、<strong>系统如何完成动态行为</strong>等。</p><p><strong>找到那些难以琢磨的对象</strong></p><p>一般情况下，可将问题中的下列实体转化为类：</p><ul><li>人，位置和东西；</li><li>事件——鼠标输入、出生、死亡等；</li><li>交易——同意贷款、汽车销售等；</li><li>人所扮演的角色——父亲、母亲等。</li></ul><h3 id="7-3-面向对象编程OOP"><a href="#7-3-面向对象编程OOP" class="headerlink" title="7.3 面向对象编程OOP"></a>7.3 面向对象编程OOP</h3><p>这是面向对象软件开发环节的最后一个阶段。将 OOD 阶段的成果输出，将其输入至OOP 阶段中。</p><h2 id="8-对象模型的关键要素"><a href="#8-对象模型的关键要素" class="headerlink" title="8 对象模型的关键要素"></a>8 对象模型的关键要素</h2><p>建立对象模型的关键要素：</p><ul><li>数据抽象</li><li>封装</li><li>层次</li></ul><p><strong>数据抽象（data abstraction）</strong>是为了强调对象的相似性，忽略其差异性来定义类。在表现类（抽象）的主要特性时，应避免展现那些不重要的和分散注意力的元素。实际上，类就是一个抽象。顺带一提，抽象将重点放在对象的外部视图上，并将对象必不可少的行为从内部的实现细节中分离出来。</p><p><strong>封装（encapsulation）</strong>是为了隐藏抽象的内部实现细节。它将抽象的外部接口从内部实现细节中分离出来。封装和抽象彼此互补。一个设计良好的抽象会封装一些成员，而被封装的实体则帮助抽象保持完整性。需要注意的是：抽象先于封装。另外，只有在开始实现时，才应该将注意力放在封装上。</p><p><strong>层次（hierarchy）</strong>是为了支持抽象的有序。抽象很强大很有用。但是，在绝大多数重大问题中，我们最终都会由于创建了太多的抽象，以至于无法统观大局。虽然封装和模块在一定程度上能缓解这一局面，但是，我们仍陷入了不计其数的抽象迷雾中。人的思维一次只能理解一组有限的抽象，提出太多抽象对读者而言简直就是一次信息保留测试，实在让人难以消化。为了避免这些不利因素，我们可以将这些抽象安排在不同的层次，这样即便尚未充分理解抽象的主要特性，也可完全明白某层次中的所有抽象。</p><p>在OOP中普遍存在两种层次。<strong>继承关系</strong>支持类层次（class hierarchy）（is-a关系，见图1-6）；聚集关系（aggregation relation）（has-a关系，见图1-7）支持部分-整体概念。继承用于描述一般-特殊关系，而聚集用于描述涉及包含（containment）和共享的关系。</p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-1/image-20241028185457489.png"></p><p><img src="/../images/OOP-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B-Chapter-1/image-20241028185508195.png"></p>]]></content>
    
    
    <categories>
      
      <category>面向对象</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Xv6 Chapter 8</title>
    <link href="/2024/10/27/MIT-6-1810-Xv6-Chapter-8/"/>
    <url>/2024/10/27/MIT-6-1810-Xv6-Chapter-8/</url>
    
    <content type="html"><![CDATA[<h1 id="File-system"><a href="#File-system" class="headerlink" title="File system"></a>File system</h1><p>文件系统的功能主要就是组织、存储、共享数据。</p><h2 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1 Overview"></a>1 Overview</h2><p>xv6的文件系统由七层组成。</p><ul><li>disk ：以块为单位，读写硬盘</li><li>buffer cache：<ul><li>缓存硬盘块</li><li>同步：确保每次只有一个内核进程可以修改某个特定块的数据。</li></ul></li><li>logging：<ul><li>允许高层在一个<strong>事务</strong>中对多个块进行更新</li><li>确保崩溃的时候，多个块的更新具有原子性（都更新或者都没更新）</li></ul></li><li>inode：用i-number唯一标识了一个文件</li><li>directory：目录是一个特殊的文件，文件内容是一组目录项，每个目录项包含文件名和i-number</li><li>pathname：提供了层次路径，并递归的解析路径</li><li>file descriptor：对管道、硬件、文件等资源进行抽象</li></ul><p><img src="/../images/MIT-6-1810-Xv6-Chapter-8/image-20241027165526300.png" alt="Layers of the xv6 file system"></p><p>硬盘传统上以 512 字节块（也称为扇区）的编号序列来组织磁盘上的数据。操作系统文件系统使用的块大小可能与磁盘使用的扇区大小不同，但通常块大小是扇区大小的倍数。Xv6 将读取到内存中的数据块副本保存在 <code>struct buf</code> 类型的对象中（kernel&#x2F;buf.h:1）。存储在此结构中的数据有时与磁盘不同步：这些数据可能尚未从磁盘读入（磁盘正在处理这些数据，但尚未返回扇区内容），也可能已被软件更新，但尚未写入磁盘。</p><p>xv6 将磁盘分为几个部分。</p><ul><li>文件系统不使用块 0（存放引导扇区）。</li><li>块 1 是超级块，包含文件系统的元数据（以块为单位的文件系统大小、数据块数、inodes 数和log中的块数）。超级块由名为 mkfs 的单独程序填充，该程序负责构建初始文件系统。</li><li>从 2 开始的块存放日志。</li><li>日志之后是inodes，每个块包含多个inode。</li><li>之后是位图块，用于跟踪正在使用的数据块。</li><li>其余的块是数据块</li></ul><p><img src="/../images/MIT-6-1810-Xv6-Chapter-8/image-20241027172905942.png"></p><h2 id="Buffer-cache-layer"><a href="#Buffer-cache-layer" class="headerlink" title="Buffer cache layer"></a>Buffer cache layer</h2><p>该层有两个功能：</p><ol><li>同步对硬盘块的访问，确保每个硬盘块在内存中只有一份拷贝，并且每次只有一个内核线程能够访问某块数据。</li><li>缓存硬盘块</li></ol><p>该层采用LRU策略，当文件系统请求一个新的硬盘块的时候，如果此时缓冲区已满，则需要替换一个最久未使用的块出缓冲区。</p><p>为了确保同步访问，每个 <code>buf</code> 都有一个 sleep-lock 锁，<code>bread</code> 返回一个上锁的 <code>buf</code> ，当某个线程使用完这个 <code>buf</code> 之后，需要调用 <code>brelse</code> 释放这个锁。</p><h2 id="Code-Buffer-cache"><a href="#Code-Buffer-cache" class="headerlink" title="Code: Buffer cache"></a>Code: Buffer cache</h2><p>缓冲由一个双向链表管理，链表头结点是最近使用的结点，尾结点是最久未使用的结点。</p><p>每个 <code>buf</code> 有两个状态位：</p><ul><li><code>valid</code> ：表示 <code>buf</code> 是否持有硬盘块的一份拷贝</li><li><code>disk</code> ：表示 <code>buf</code> 的内容被移交给硬盘，有可能导致 <code>buf</code> 的内容发生改变。</li></ul><p><code>bcache</code> 负责维护双向链表的头结点和一个自旋锁，该锁保护缓存块的信息，而每个 <code>buf</code> 的锁则负责保护对该块内容的读写。</p><p>需要确保每个硬盘块至多只有一份缓存，这需要确保对于某个块是否在缓存中的检查和对该块分配缓存块的操作是原子的。若该操作不是原子的，某个内核线程检查某个块a，发现其不在缓存中，然后执行另外一个内核线程，该块同样检查块a，发现不在缓存中，然后为该块分配了一个缓存，接下来回到第一个内核线程执行，该线程由于已经完成了检查，又为块a分配了另一个缓存，导致块a在缓存中有两份拷贝。</p><p>如果所有的 <code>buf</code> 此时都在被访问，则 <code>bget</code> 会panic。</p><p>如果某个线程修改了 <code>buf</code> 的内容，则它在释放该 <code>buf</code> 之前，必须调用 <code>bwrite</code> 把修改写回硬盘。</p><p>当某个线程用完了 <code>buf</code> ，必须调用 <code>brelse</code> 去释放该 <code>buf</code> ，该调用释放该 <code>buf</code> 的锁，然后将该 <code>buf</code> 移动到链表头。</p><h2 id="Logging-layer"><a href="#Logging-layer" class="headerlink" title="Logging layer"></a>Logging layer</h2><p>xv6通过日志解决文件系统操作过程中的崩溃问题。</p><p>系统调用不会直接写入磁盘，而是在磁盘的日志中记录对磁盘的写入操作，当系统调用记录了所有写入操作，他会向磁盘写入一条特殊的提交记录，表明该日志已经包含一个完整的操作。之后，系统调用会将写入内容开始实际写入到磁盘中，写完后，将日志清除。</p><p>如果系统崩溃并重新启动，在运行任何进程之前，文件系统代码会按如下方式从崩溃中恢复：</p><ul><li>如果日志被标记为包含完整操作，那么恢复代码会将写入内容复制到磁盘文件系统中属于它们的位置。</li><li>如果日志未标记为包含完整操作，则恢复代码会忽略日志。</li><li>恢复代码最后会擦除日志。</li></ul><h2 id="Log-design"><a href="#Log-design" class="headerlink" title="Log design"></a>Log design</h2><p>日志位于超级块中指定的已知固定位置。日志由一个标题块和一系列更新块副本（“日志块”）组成。标题块包含一个扇区号数组（每个日志块一个）和日志块计数。磁盘标题块中的计数要么为零，表示日志中没有事务；要么为非零，表示日志中包含一个完整的已提交事务。Xv6 会在事务提交时写入标题块，而不会在事务提交前写入，并在将日志块中指定的操作完成后将计数设为零。 </p><p>每个系统调用的代码标记了需要原子写入的一系列操作（即要么全部成功，要么全部失败的写入操作）。为了允许多个进程并发执行文件系统操作，日志系统可以将多个系统调用的写入操作累积成一个事务。这种方式允许系统在单个提交中处理多个系统调用的写入请求，这样可以提高效率。</p><p>为了避免将一个系统调用分成多个事务，日志系统只有在没有文件系统调用进行时才会提交事务。</p><p>将多个事务一起提交的想法被称为分组提交。分组提交可减少磁盘操作次数，因为它将提交的固定成本分摊到多个操作中。</p><h2 id="Code-logging"><a href="#Code-logging" class="headerlink" title="Code: logging"></a>Code: logging</h2><p>系统调用中对日志的一个典型用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">begin_op();<br><span class="hljs-comment">// ...</span><br>bp = bread(...);<br>bp-&gt;data[..] = ...;<br>log_write(bp);<br><span class="hljs-comment">// ...</span><br>end_op();<br></code></pre></td></tr></table></figure><p><code>begin_op</code> 等待日志系统完成提交，或者有足够的空间记录所有写入块。<code>log.outstanding</code> 表示目前正在执行的系统调用的个数，可以保证提交不会发生在某个系统调用执行过程中。</p><p><code>log_write</code> 是 <code>bwrite</code> 的代理。它在内存中记录了需要写入的块号，并且将 <code>buf</code> 的 <code>refcnt</code> 字段加1，确保该块在提交之前一直保留在缓存中。需要注意的是，如果在一个事务中对某个块多次写入，<code>log_wirte</code> 只会保留一个记录，这样可以提高效率，这种优化技术称为 absorption。</p><p><code>end_op</code> 首先将 <code>log.outstanding</code> 减1，如果 <code>log.outstanding</code> 现在是0，表示该事务是最后一个事务，那么可以提交。</p><p><code>commit</code> 分为四个阶段：</p><ol><li><code>write_log</code> 将需要记录的块写入到磁盘中的log中。</li><li><code>write_head</code> 将当前内存中的标题块写入到磁盘中。这是实际的提交点，在该写入之后的崩溃，都会重新执行崩溃前的事务。</li><li><code>install_trans</code> 将log中的块写入到实际的块。</li><li>将标题块中的count置0</li></ol><h2 id="Code-Block-allocator"><a href="#Code-Block-allocator" class="headerlink" title="Code: Block allocator"></a>Code: Block allocator</h2><p>xv6用位图来管理空闲块。</p><p><code>balloc</code> 在位图中找一个空闲位。</p><p><code>bfree</code> 在位图中清除一个位。</p><p>这两个函数必须在一个事务中调用。</p><h2 id="Inode-layer"><a href="#Inode-layer" class="headerlink" title="Inode layer"></a>Inode layer</h2><p>Inode 一词有两种含义：</p><ul><li>它可以指包含文件大小和数据块编号列表的磁盘数据结构。</li><li>或者，“inode ”可能指内存中的 inode，它包含磁盘 inode 的副本以及内核所需的额外信息。</li></ul><p><strong>on-disk inode</strong></p><p>磁盘上的inode被打包到磁盘上的一个连续区域，每个inode的大小都是固定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// On-disk inode structure</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dinode</span> &#123;</span><br>  <span class="hljs-type">short</span> type;           <span class="hljs-comment">// File type</span><br>  <span class="hljs-type">short</span> major;          <span class="hljs-comment">// Major device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> minor;          <span class="hljs-comment">// Minor device number (T_DEVICE only)</span><br>  <span class="hljs-type">short</span> nlink;          <span class="hljs-comment">// Number of links to inode in file system</span><br>  uint size;            <span class="hljs-comment">// Size of file (bytes)</span><br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];   <span class="hljs-comment">// Data block addresses</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>in-memory inode</strong></p><p>内核在 <code>itable</code> 中管理in-memory inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// in-memory copy of an inode</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> &#123;</span><br>  uint dev;           <span class="hljs-comment">// Device number</span><br>  uint inum;          <span class="hljs-comment">// Inode number</span><br>  <span class="hljs-type">int</span> ref;            <span class="hljs-comment">// Reference count</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sleeplock</span> <span class="hljs-title">lock</span>;</span> <span class="hljs-comment">// protects everything below here</span><br>  <span class="hljs-type">int</span> valid;          <span class="hljs-comment">// inode has been read from disk?</span><br><br>  <span class="hljs-type">short</span> type;         <span class="hljs-comment">// copy of disk inode</span><br>  <span class="hljs-type">short</span> major;<br>  <span class="hljs-type">short</span> minor;<br>  <span class="hljs-type">short</span> nlink;<br>  uint size;<br>  uint addrs[NDIRECT+<span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><p>内核只有在当前有c指针引用该inode的时候，才会将其加载到 <code>itable</code> 中。</p><p>xv6中关于inode有四种锁：</p><ul><li><code>itable.lock</code> 保证某个inode至多只在 <code>itable</code> 中出现一次。并且保证 <code>ref</code> 字段的一致性。</li><li><code>inode.lock</code> 保证对 <code>inode</code> 的互斥访问。</li><li><code>ref</code> 字段保证系统不要重用其 <code>itable</code> 中的inode。</li><li><code>unlink</code> 字段维护引用某个文件的目录项个数。</li></ul><p><code>iget</code> 返回的inode保证是有效的，而且不是互斥访问的。需要注意的是，<code>iget</code> 返回的inode只保证是有效的，但是内容并不一定有用，必须调用 <code>ilock</code> 将其从硬盘中读入内存中。这种分离机制帮助避免一些死锁情况。</p><h2 id="Code-Inodes"><a href="#Code-Inodes" class="headerlink" title="Code: Inodes"></a>Code: Inodes</h2><p><code>ialloc</code> 遍历所有inode，找出一个空闲的inode结点并分配之。</p><p><code>iget</code> 在 <code>itable</code> 中查找指定的inode，如果找到，返回之，否则重用一个空闲的inode。</p><p><code>iput</code> 释放一个引用某个inode的c指针，如果该c指针是最后一个引用该inode的指针，则表明 <code>itable</code> 中的该项可以重用。如果 <code>iput</code> 发现某个inode的 <code>ref</code> 字段和 <code>unlink</code> 字段为0，则表明该inode表示的文件必须被删除。<code>iput</code> 调用 <code>itrunc</code> 将该文件截断，释放相应的数据块，将 <code>type</code> 字段设置为0，并将该 <code>inode</code> 写回磁盘中。</p><p><code>iput</code> 中的锁策略：</p><ul><li>另外一个线程可能正在等待 <code>ilock</code> ，这种情况下，当前执行 <code>iput</code> 的线程的 <code>ref</code> 字段不可能为0，保证了不会将inode释放掉。</li><li>对 ialloc 的并发调用可能会选择 iput 正在释放的同一个 inode。这种情况只有在 iupdate 写入磁盘，使 inode 类型为零之后才会发生。这种竞赛是良性的；分配线程会礼貌地等待获得 inode 的休眠锁，然后再读取或写入 inode，此时 iput 就完成了。</li></ul><p><code>iput</code> 可能会写硬盘，这意味着即使是只读的系统调用也必须封装在一个事务中。</p><p>当文件的链接数降为零时，<code>iput</code> 不会立即截断文件，因为某些进程可能仍在内存中持有对 inode 的引用：某个进程可能仍在读写文件，因为它成功打开了文件。但是，如果崩溃发生在最后一个进程关闭文件的文件描述符之前，那么该文件将被标记为已在磁盘上分配，但没有目录项指向它。<br>文件系统有两种方法处理这种情况。</p><ul><li>一种简单的解决方案是，在重启后恢复时，文件系统会扫描整个文件系统，查找标记为已分配但没有目录项指向的文件。如果存在这样的文件，就可以释放这些文件。</li><li>第二种解决方案不需要扫描文件系统。在这种解决方案中，文件系统会在磁盘上（如超级块中）记录链接计数降为零但引用计数不为零的文件的 inode inumber。如果文件系统在其引用计数为 0 时删除了该文件，那么它就会更新磁盘上的列表，将该 inode 从列表中删除。恢复时，文件系统会释放列表中的任何文件。</li><li>Xv6 没有实现任何一种方案，这意味着即使节点不再使用，它们也可能被标记为已在磁盘上分配。这意味着随着时间的推移，xv6 可能会面临磁盘空间耗尽的风险</li></ul><h2 id="Code-Inode-content"><a href="#Code-Inode-content" class="headerlink" title="Code: Inode content"></a>Code: Inode content</h2><p>磁盘 inode 结构 struct dinode 包含一个大小和一个块编号数组（见图 8.3）。数组的前12个数据块是直接数据块，最后一个数据块是间接数据块。函数 bmap 对表示法进行了管理，这样我们即将看到的 readi 和 writei 等高级例程就不需要管理这种复杂性了。如果 ip 还没有这样的数据块，bmap 会根据需要分配数据块。如果 ip-&gt;addrs[] 或间接条目为零，则表示没有分配块。当 bmap 遇到零时，它会用按需分配的新块的编号来代替。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-8/image-20241028162956014.png"></p><h2 id="Code-directory-layer"><a href="#Code-directory-layer" class="headerlink" title="Code: directory layer"></a>Code: directory layer</h2><p>目录其实就是一个文件，它的内容是一串目录项。每个目录项 <code>struct dirent</code> 包含文件名和inode number。文件名最多 <code>DIRSIZE</code> （14）个字符，inode numer为0表示该目录项是空闲的。</p><p>函数 <code>dirlookup</code> 会在一个目录中搜索带有给定名称的条目。如果找到了，它会返回一个指向相应 inode 的指针（未上锁），并将 <code>*poff</code> 设置为该条目在目录中的字节偏移量，以备调用者编辑。如果 <code>dirlookup</code> 找到了名称正确的条目，它会更新 <code>*poff</code> 并返回通过 <code>iget</code> 获得的未上锁的 inode。调用者已经锁定了 <code>dp</code>，因此如果查找的是当前目录的别名 <code>.</code>，在返回之前尝试锁定 inode 会重新锁定 <code>dp</code> 并导致死锁。(还有更复杂的死锁情况，涉及多个进程和<code>..</code>（父目录的别名）；<code>.</code> 不是唯一的问题）。调用者可以先解锁 <code>dp</code>，然后再锁定 <code>ip</code>，以确保每次只持有一个锁。</p><p>函数 <code>dirlink</code> 使用给定的名称和 inode 编号向目录 <code>dp</code> 写入一个新的目录条目。如果名称已经存在，<code>dirlink</code> 会返回错误信息。主循环读取目录条目，寻找未分配的条目。找到后，它会提前结束循环，并将 <code>off</code> 设为可用条目的偏移量。否则，循环结束，<code>off</code> 设置为 <code>dp-&gt;size</code>。无论哪种情况，<code>dirlink</code> 都会在偏移量 <code>off</code> 处写入一个新条目。</p><h2 id="Code-Path-names"><a href="#Code-Path-names" class="headerlink" title="Code: Path names"></a>Code: Path names</h2><p>路径名查找涉及对 <code>dirlookup</code> 的连续调用，每个路径组件都有一个调用。<code>namei</code> 对路径进行求值并返回相应的 inode。函数 <code>nameiparent</code> 是一个变体：它在最后一个元素之前停止，返回父目录的 inode 并将最后一个元素复制到 name 中。</p><h2 id="File-descriptor-layer"><a href="#File-descriptor-layer" class="headerlink" title="File descriptor layer"></a>File descriptor layer</h2><p>Xv6 为每个进程提供了自己的打开文件表或文件描述符。每个打开的文件都由一个 <code>struct file</code> 表示，它是对 inode 或管道的封装，外加一个 I&#x2F;O 偏移量。每次调用 open 都会创建一个新的打开文件：如果多个进程独立打开同一个文件，不同的实例会有不同的 I&#x2F;O 偏移量。另一方面，一个打开的文件（同一个结构文件）可以多次出现在一个进程的文件表和多个进程的文件表中。如果一个进程使用 open 打开文件，然后使用 dup 创建别名，或使用 fork 与子进程共享，就会出现这种情况。引用计数跟踪特定打开文件的引用次数。文件可以为读取或写入打开，也可以同时为读取和写入打开。可读和可写字段会跟踪这一点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> &#123;</span> FD_NONE, FD_PIPE, FD_INODE, FD_DEVICE &#125; type;<br>  <span class="hljs-type">int</span> ref; <span class="hljs-comment">// reference count</span><br>  <span class="hljs-type">char</span> readable;<br>  <span class="hljs-type">char</span> writable;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pipe</span> *<span class="hljs-title">pipe</span>;</span> <span class="hljs-comment">// FD_PIPE</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">ip</span>;</span>  <span class="hljs-comment">// FD_INODE and FD_DEVICE</span><br>  uint off;          <span class="hljs-comment">// FD_INODE</span><br>  <span class="hljs-type">short</span> major;       <span class="hljs-comment">// FD_DEVICE</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>系统中所有打开的文件都保存在一个全局文件表 <code>ftable</code> 中。文件表中有分配文件（filealloc）、创建重复引用（filedup）、释放引用（fileclose）以及读写数据（fileread 和 filewrite）的函数。</p><p>filealloc (kernel&#x2F;file.c:30) 会在文件表中扫描未引用的文件（f-&gt;ref &#x3D;&#x3D;0）并返回一个新的引用；filedup (kernel&#x2F;file.c:48) 会增加引用计数；fileclose (kernel&#x2F;file.c:60) 会减少引用计数。当文件的引用计数为零时，fileclose 会释放底层管道或 inode。</p><p>函数 filestat、fileread 和 filewrite 实现了对文件的统计、读取和写入操作。filestat（kernel&#x2F;file.c:88）只允许对 inode 进行操作，并调用 stati。fileread 和 filewrite 会检查打开模式是否允许操作，然后将调用传递给管道或 inode 实现。如果文件代表一个 inode，fileread 和 filewrite 会使用 I&#x2F;O 偏移量作为操作的偏移量，然后向前推进（kernel&#x2F;file.c:122-123）（kernel&#x2F;file.c:153-154）。管道没有偏移量的概念。回想一下，inode 函数要求调用者处理加锁（kernel&#x2F;file.c:94-96）（kernel&#x2F;file.c:121-124）（kernel&#x2F;file.c:163-166）。inode 锁定有一个方便的副作用，即读取和写入的偏移量是原子更新的，因此多个同时写入同一文件的人不会覆盖彼此的数据，尽管他们的写入可能会交错进行。</p><h2 id="Code-System-calls"><a href="#Code-System-calls" class="headerlink" title="Code: System calls"></a>Code: System calls</h2><p>函数 <code>sys_link</code> 和 <code>sys_unlink</code> 编辑目录，创建或删除对 inodes 的引用。<code>sys_link</code> 首先获取参数，即两个字符串 <code>old</code> 和 <code>new</code>。假设 <code>old</code> 存在且不是目录，<code>sys_link</code> 会增加其 <code>ip-&gt;nlink</code> 计数。然后，<code>sys_link</code> 调用 <code>nameiparent</code> 查找 <code>new</code> 的父目录和最终路径元素，并创建一个指向 <code>old</code> 的 inode 的新目录条目。新的父目录必须存在，并且与现有的 inode 位于同一设备上：inode 只有在单个磁盘上才有唯一意义。如果出现类似错误，<code>sys_link</code> 必须返回并递减 <code>ip-&gt;nlink</code> .</p><p>由于需要更新多个磁盘块，因此事务简化了执行过程，但我们不必担心更新的顺序。它们要么全部成功，要么一个都不成功。例如，如果没有事务，在创建链接之前更新 ip-&gt;nlink 会使文件系统暂时处于不安全状态，而中间的崩溃可能会导致大灾难。有了事务，我们就不必担心这个问题了 。</p><p><code>sys_link</code> 为现有的 inode 创建新名称。函数 <code>create</code>为新的 inode 创建新名称。它是对三种文件创建系统调用的概括：使用 <code>O_CREATE</code> 标志打开一个新的普通文件，使用 <code>mkdir</code> 创建一个新的目录，使用 <code>mkdev</code> 创建一个新的设备文件。与 <code>sys_link</code> 类似，<code>create</code> 也是通过调用 <code>nameiparent</code> 来获取父目录的 inode。然后调用 <code>dirlookup</code> 检查名称是否已经存在。如果名称确实存在，<code>create</code> 的行为将取决于它被用于哪个系统调用：<code>open</code> 与 <code>mkdir</code> 和 <code>mkdev</code> 的语义不同。如果 <code>create</code> 是代表 <code>open</code> 使用（类型 &#x3D;&#x3D; T_FILE），而存在的名称本身就是一个普通文件，那么 <code>open</code> 会将其视为成功。否则会出错。如果文件名不存在，<code>create</code> 会使用 <code>ialloc</code> 分配一个新的 inode。如果新的 inode 是一个目录，<code>create</code> 会使用 <code>.</code> 和 <code>..</code>条目对其进行初始化。最后，既然数据已经正确初始化，<code>create</code> 就可以将其链接到父目录。<code>create</code> 和 <code>sys_link</code> 一样，同时持有两个 inode 锁：<code>ip</code> 和 <code>dp</code>。由于 inode ip 是新分配的，因此不会出现死锁：系统中不会有其他进程在持有 <code>ip</code> 锁后又试图锁定 <code>dp</code>。</p><p>使用 <code>create</code>，可以很容易地实现 <code>sys_open</code>、<code>sys_mkdir</code> 和 <code>sys_mknod</code>。<code>sys_open</code>是最复杂的，因为创建新文件只是它能做的事情的一小部分。如果 <code>open</code> 传递了 <code>O_CREATE</code> 标志，它就会调用 <code>create</code>。否则，它将调用 <code>namei</code>。必须锁定 inode 本身。这为检查目录是否只为读取而不是写入打开提供了方便。假设以某种方式获得了 inode，<code>sys_open</code> 会分配一个文件和一个文件描述符，然后填入文件。请注意，其他进程无法访问部分初始化的文件，因为它只存在于当前进程的表中。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[GIT]常用基本操作</title>
    <link href="/2024/10/21/GIT-%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/10/21/GIT-%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>Git 是一个分布式版本控制系统，用于跟踪文件的更改，协助团队协作开发软件项目。</p><h3 id="1-初始化-Git-仓库"><a href="#1-初始化-Git-仓库" class="headerlink" title="1. 初始化 Git 仓库"></a>1. <strong>初始化 Git 仓库</strong></h3><p>要使用 Git 跟踪项目，首先需要将项目目录初始化为 Git 仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>这会在当前目录下创建一个隐藏的 <code>.git</code> 文件夹，用于存储版本控制相关的数据。</p><h3 id="2-克隆远程仓库"><a href="#2-克隆远程仓库" class="headerlink" title="2. 克隆远程仓库"></a>2. <strong>克隆远程仓库</strong></h3><p>如果已有远程仓库，可以通过 <code>git clone</code> 命令将其复制到本地：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/username/repo.git<br></code></pre></td></tr></table></figure><p>这会将远程仓库下载到当前目录，并创建一个同名文件夹。</p><h3 id="3-查看仓库状态"><a href="#3-查看仓库状态" class="headerlink" title="3. 查看仓库状态"></a>3. <strong>查看仓库状态</strong></h3><p>使用 <code>git status</code> 查看当前仓库的状态，比如哪些文件被修改了、哪些文件处于暂存区等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p>这会显示未跟踪文件、已修改文件和暂存区的文件。</p><h3 id="4-跟踪新文件"><a href="#4-跟踪新文件" class="headerlink" title="4. 跟踪新文件"></a>4. <strong>跟踪新文件</strong></h3><p>要将新文件添加到 Git 的跟踪列表中，使用 <code>git add</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>也可以一次性添加所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br></code></pre></td></tr></table></figure><p>这会将当前目录下的所有修改和新文件添加到暂存区。</p><h3 id="5-提交更改"><a href="#5-提交更改" class="headerlink" title="5. 提交更改"></a>5. <strong>提交更改</strong></h3><p>一旦添加了文件到暂存区，可以使用 <code>git commit</code> 来提交这些更改。每次提交都会记录一条历史记录，可以随时查看和恢复。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;Commit message describing the changes&quot;</span><br></code></pre></td></tr></table></figure><p><code>-m</code> 后跟的消息应简要描述这次提交的更改内容。</p><h3 id="6-查看提交历史"><a href="#6-查看提交历史" class="headerlink" title="6. 查看提交历史"></a>6. <strong>查看提交历史</strong></h3><p>使用 <code>git log</code> 命令可以查看仓库的提交历史：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>这会显示提交的哈希值、作者、日期和提交消息。如果想查看简化的日志，可以使用 <code>--oneline</code> 选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> --oneline<br></code></pre></td></tr></table></figure><h3 id="7-创建分支"><a href="#7-创建分支" class="headerlink" title="7. 创建分支"></a>7. <strong>创建分支</strong></h3><p>在 Git 中，分支用于并行开发不同的功能。可以创建一个新的分支来开发一个新功能：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b &lt;branch-name&gt;<br></code></pre></td></tr></table></figure><p>这会创建并切换到一个新的分支。如果你只想切换分支而不创建新分支，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;branch-name&gt;<br></code></pre></td></tr></table></figure><h3 id="8-推送到远程仓库"><a href="#8-推送到远程仓库" class="headerlink" title="8. 推送到远程仓库"></a>8. <strong>推送到远程仓库</strong></h3><p>将本地的提交推送到远程仓库，以便与团队成员共享代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin &lt;branch-name&gt;<br></code></pre></td></tr></table></figure><p>例如，如果想将 <code>main</code> 分支的更改推送到远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin main<br></code></pre></td></tr></table></figure><h3 id="9-拉取远程仓库的更改"><a href="#9-拉取远程仓库的更改" class="headerlink" title="9. 拉取远程仓库的更改"></a>9. <strong>拉取远程仓库的更改</strong></h3><p>使用 <code>git pull</code> 从远程仓库拉取最新的更改并合并到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin &lt;branch-name&gt;<br></code></pre></td></tr></table></figure><p>例如，从 <code>main</code> 分支拉取远程仓库的最新更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin main<br></code></pre></td></tr></table></figure><h3 id="10-暂存工作（Stashing）"><a href="#10-暂存工作（Stashing）" class="headerlink" title="10. 暂存工作（Stashing）"></a>10. <strong>暂存工作（Stashing）</strong></h3><p>如果正在处理一些代码更改，但还不想提交这些更改，而又想切换到另一个分支或做其他事情，可以使用 <code>git stash</code> 将工作区的更改暂存起来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure><p>之后可以使用 <code>git stash apply</code> 恢复暂存的工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash apply<br></code></pre></td></tr></table></figure><h3 id="11-查看差异"><a href="#11-查看差异" class="headerlink" title="11. 查看差异"></a>11. <strong>查看差异</strong></h3><p>要查看文件的更改内容，可以使用 <code>git diff</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br></code></pre></td></tr></table></figure><p>这会显示自上次提交以来的更改内容。</p><h3 id="12-还原更改"><a href="#12-还原更改" class="headerlink" title="12. 还原更改"></a>12. <strong>还原更改</strong></h3><p>在 Git 中，还原代码或撤销更改是非常常见的操作，无论是恢复某个文件的状态，还是撤销某次提交，Git 都提供了多个方式来安全、灵活地操作项目历史。以下是 Git 中常用的还原和撤销操作的详细介绍。</p><h4 id="12-1-撤销未提交的更改"><a href="#12-1-撤销未提交的更改" class="headerlink" title="12.1 撤销未提交的更改"></a>12.1 <strong>撤销未提交的更改</strong></h4><h5 id="还原工作区的修改"><a href="#还原工作区的修改" class="headerlink" title="还原工作区的修改"></a><strong>还原工作区的修改</strong></h5><p>如果修改了文件，但还没有提交（即文件还未加入暂存区或已经暂存但未提交），可以将它们恢复到上次提交时的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -- &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>这个命令会丢弃文件中的所有未提交的更改，恢复为上一次提交时的版本。如果想还原多个文件，也可以直接用 <code>.</code> 表示当前目录下的所有文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -- .<br></code></pre></td></tr></table></figure><h5 id="撤销已暂存的更改"><a href="#撤销已暂存的更改" class="headerlink" title="撤销已暂存的更改"></a><strong>撤销已暂存的更改</strong></h5><p>如果已经通过 <code>git add</code> 将文件添加到暂存区，但你想撤销这个操作，可以使用 <code>git reset</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>这会将文件从暂存区移出，但保留文件的更改。此时，可以再次编辑文件或选择不提交这些更改。</p><h5 id="还原整个工作目录"><a href="#还原整个工作目录" class="headerlink" title="还原整个工作目录"></a><strong>还原整个工作目录</strong></h5><p>如果想撤销所有未提交的更改（包括暂存区和未暂存的文件），可以使用 <code>git reset</code> 和 <code>git checkout</code> 的组合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD<br></code></pre></td></tr></table></figure><p>这会将整个工作区还原为最后一次提交的状态，所有未提交的更改都会丢失。</p><h4 id="12-2-撤销已提交的更改"><a href="#12-2-撤销已提交的更改" class="headerlink" title="12.2 撤销已提交的更改"></a>12.2 <strong>撤销已提交的更改</strong></h4><h5 id="修改最近的提交"><a href="#修改最近的提交" class="headerlink" title="修改最近的提交"></a><strong>修改最近的提交</strong></h5><p>如果已经提交了更改，但发现提交信息有误或文件遗漏，可以使用 <code>git commit --amend</code> 来修改最近一次的提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit --amend<br></code></pre></td></tr></table></figure><p>这会打开编辑器，允许修改提交消息，或者可以添加更多的文件到该提交。如果想改动的是最近一次提交的内容而不是消息，可以先用 <code>git add</code> 再执行 <code>git commit --amend</code>。</p><h5 id="回滚到指定提交"><a href="#回滚到指定提交" class="headerlink" title="回滚到指定提交"></a><strong>回滚到指定提交</strong></h5><p>如果想撤销一个或多个提交，可以使用 <code>git reset</code> 命令。<code>git reset</code> 有多个选项，根据需要选择合适的方式：</p><ul><li><p><strong>软重置（<code>--soft</code>）</strong>：只移动提交指针，保留所有文件的修改状态和暂存状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --soft &lt;commit&gt;<br></code></pre></td></tr></table></figure><p>这样可以回到某个提交，但保留所有更改在暂存区，之后可以重新提交。</p></li><li><p><strong>混合重置（<code>--mixed</code>，默认）</strong>：回到指定的提交，但保留文件的更改，只是将其移出暂存区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --mixed &lt;commit&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>硬重置（<code>--hard</code>）</strong>：彻底回滚到指定的提交，删除所有未提交的更改，工作目录会与指定的提交完全一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard &lt;commit&gt;<br></code></pre></td></tr></table></figure></li></ul><h5 id="撤销某次提交但保留更改"><a href="#撤销某次提交但保留更改" class="headerlink" title="撤销某次提交但保留更改"></a><strong>撤销某次提交但保留更改</strong></h5><p>有时候不想彻底回到之前的某个提交，而只是想撤销某个提交的影响，但保留它的内容供重新修改。这种情况下可以使用 <code>git revert</code>。</p><ul><li><p><strong>回滚单个提交</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;commit&gt;<br></code></pre></td></tr></table></figure><p>这会生成一个新的提交，撤销指定提交的内容，但不会改变提交历史。</p></li></ul><h5 id="删除最近的提交"><a href="#删除最近的提交" class="headerlink" title="删除最近的提交"></a><strong>删除最近的提交</strong></h5><p>如果想删除最新的一个或多个提交（且不保留更改），可以使用 <code>git reset</code> 的硬重置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD~1<br></code></pre></td></tr></table></figure><p>这会删除最近的提交，<code>HEAD~1</code> 表示倒退一个提交。如果删除多个提交，可以使用 <code>HEAD~n</code>，其中 <code>n</code> 是想删除的提交数。</p><h4 id="12-3-还原已删除的文件"><a href="#12-3-还原已删除的文件" class="headerlink" title="12.3 还原已删除的文件"></a>12.3 <strong>还原已删除的文件</strong></h4><p>如果不小心删除了一个文件，但没有提交这个删除操作，可以使用 <code>git checkout</code> 恢复文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -- &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>这个命令会将文件恢复到上一次提交时的状态。</p><p>如果已经提交了文件删除操作，但想恢复该文件，可以通过 <code>git reset</code> 或 <code>git revert</code> 撤销删除操作，或者通过以下命令恢复特定的已删除文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;commit&gt; -- &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>这个命令会将文件恢复到指定提交时的状态。</p><h4 id="12-4-暂存工作并稍后恢复"><a href="#12-4-暂存工作并稍后恢复" class="headerlink" title="12.4 暂存工作并稍后恢复"></a>12.4 <strong>暂存工作并稍后恢复</strong></h4><p>当在进行某些更改时，突然需要切换到其他分支或处理其他任务，但不想提交当前的更改，可以使用 <code>git stash</code> 暂存这些未完成的工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash<br></code></pre></td></tr></table></figure><p>这会将当前的所有未提交更改（包括暂存和未暂存的内容）暂存起来，工作目录会恢复到干净状态。</p><p>当想恢复这些工作时，使用 <code>git stash apply</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash apply<br></code></pre></td></tr></table></figure><p>这会将暂存的更改恢复到工作目录。</p><h4 id="12-5-查看提交的历史记录"><a href="#12-5-查看提交的历史记录" class="headerlink" title="12.5 查看提交的历史记录"></a>12.5 <strong>查看提交的历史记录</strong></h4><p>可以使用 <code>git log</code> 命令查看仓库的历史提交记录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><p>如果需要查看某个文件在不同提交间的变动，可以使用 <code>git log</code> 加上文件名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">log</span> &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>这会显示与该文件相关的所有提交。</p><h4 id="12-6-查看文件差异"><a href="#12-6-查看文件差异" class="headerlink" title="12.6 查看文件差异"></a>12.6 <strong>查看文件差异</strong></h4><p>使用 <code>git diff</code> 可以查看工作区和暂存区的文件差异：</p><ul><li><p><strong>查看工作区和暂存区的差异</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff<br></code></pre></td></tr></table></figure></li><li><p><strong>查看暂存区和上次提交的差异</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff --cached<br></code></pre></td></tr></table></figure></li><li><p><strong>查看某次提交的更改</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git diff &lt;commit&gt;<br></code></pre></td></tr></table></figure></li></ul><h4 id="12-7-强制推送还原"><a href="#12-7-强制推送还原" class="headerlink" title="12.7 强制推送还原"></a>12.7 <strong>强制推送还原</strong></h4><p>如果已经推送了错误的提交到远程仓库，并且需要还原远程仓库的状态，可以使用 <code>git push</code> 的强制推送选项（<strong>注意：这会覆盖远程仓库的历史，需要谨慎使用</strong>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push --force<br></code></pre></td></tr></table></figure><p>这种操作适用于紧急情况下的错误修复，且需要团队协作时的额外沟通，以避免其他开发者的工作被覆盖。</p><h3 id="13-克隆、推送和拉取常用流程"><a href="#13-克隆、推送和拉取常用流程" class="headerlink" title="13. 克隆、推送和拉取常用流程"></a>13. <strong>克隆、推送和拉取常用流程</strong></h3><ol><li><p><strong>克隆仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/username/repo.git<br></code></pre></td></tr></table></figure></li><li><p><strong>拉取最新代码</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull origin main<br></code></pre></td></tr></table></figure></li><li><p><strong>进行开发、提交</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Add new feature&quot;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>推送到远程仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin main<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[GIT]分支常用操作</title>
    <link href="/2024/10/21/GIT-%E5%88%86%E6%94%AF%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/10/21/GIT-%E5%88%86%E6%94%AF%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>分支允许我们在不同的方向上工作，而不影响主分支。如果项目中不同的功能或修复位于不同的分支上，便可以单独开发、测试，并在必要时合并回主分支。</p><h3 id="1-创建分支"><a href="#1-创建分支" class="headerlink" title="1. 创建分支"></a>1. <strong>创建分支</strong></h3><p>当开始一个新功能或想要实验某些东西时，可以创建一个新的分支。假设已经初始化了一个 Git 仓库或克隆了一个现有的仓库，可以使用以下命令创建并切换到一个新的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b &lt;branch-name&gt;<br></code></pre></td></tr></table></figure><p>例如，如果正在开发一个新的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b feature-new-functionality<br></code></pre></td></tr></table></figure><p>此命令会同时创建一个名为 <code>feature-new-functionality</code> 的新分支，并切换到该分支。</p><h3 id="2-在分支上工作"><a href="#2-在分支上工作" class="headerlink" title="2. 在分支上工作"></a>2. <strong>在分支上工作</strong></h3><p>在新分支上，可以进行正常的开发工作，例如添加文件、修改代码等。所有这些更改都会存储在这个分支上，不会影响其他分支。</p><p>查看当前所在的分支，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch<br></code></pre></td></tr></table></figure><p>它会列出当前仓库中的所有分支，当前所在分支会标记一个星号（<code>*</code>）。</p><h3 id="3-提交更改"><a href="#3-提交更改" class="headerlink" title="3. 提交更改"></a>3. <strong>提交更改</strong></h3><p>在分支中完成了一些更改后，和使用 Git 的常规工作流程一样，需要将这些更改添加到暂存区，并提交到本地仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;files&gt;<br>git commit -m <span class="hljs-string">&quot;Add new functionality to the project&quot;</span><br></code></pre></td></tr></table></figure><h3 id="4-切换分支"><a href="#4-切换分支" class="headerlink" title="4. 切换分支"></a>4. <strong>切换分支</strong></h3><p>可以在不同的分支之间切换，而不会丢失任何工作。假设正在 <code>feature-new-functionality</code> 分支上工作，但现在想回到 <code>main</code> 分支查看项目的稳定版本，可以使用以下命令切换分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure><p>Git 会切换到 <code>main</code> 分支，同时保留 <code>feature-new-functionality</code> 分支上的所有工作。</p><h3 id="5-合并分支"><a href="#5-合并分支" class="headerlink" title="5. 合并分支"></a>5. <strong>合并分支</strong></h3><p>当在一个分支上完成了某个功能，并且经过测试后决定将它合并到 <code>main</code> 分支（或其他分支）时，可以使用以下命令进行合并操作：</p><ol><li><p>首先，切换到想要合并到的分支（例如 <code>main</code>）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout main<br></code></pre></td></tr></table></figure></li><li><p>然后，合并工作的分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge feature-new-functionality<br></code></pre></td></tr></table></figure></li><li><p>如果合并时有冲突（即两个分支修改了相同的文件部分），Git 会提示进行冲突解决。解决冲突后，可以再次提交解决后的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;resolved-files&gt;<br>git commit -m <span class="hljs-string">&quot;Resolve merge conflicts&quot;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="6-删除分支（可选）"><a href="#6-删除分支（可选）" class="headerlink" title="6. 删除分支（可选）"></a>6. <strong>删除分支（可选）</strong></h3><p>当一个分支的工作完成并成功合并后，可以选择删除这个分支，以保持仓库整洁：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d feature-new-functionality<br></code></pre></td></tr></table></figure><p>如果分支没有合并到其他分支，而还是想删除它，可以使用 <code>-D</code> 强制删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -D feature-new-functionality<br></code></pre></td></tr></table></figure><h3 id="7-推送分支到远程仓库"><a href="#7-推送分支到远程仓库" class="headerlink" title="7. 推送分支到远程仓库"></a>7. <strong>推送分支到远程仓库</strong></h3><p>如果想将本地分支推送到远程仓库（例如 GitHub），可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin &lt;branch-name&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin feature-new-functionality<br></code></pre></td></tr></table></figure><p>这会将新分支推送到远程仓库。团队中的其他成员也可以在远程仓库中看到这个分支，并进行协作。</p><h3 id="8-拉取远程分支"><a href="#8-拉取远程分支" class="headerlink" title="8. 拉取远程分支"></a>8. <strong>拉取远程分支</strong></h3><p>当在远程仓库中发现其他人创建的分支时，可以将它拉取到本地，进行协作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br>git checkout &lt;branch-name&gt;<br></code></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch<br>git checkout feature-other-developer<br></code></pre></td></tr></table></figure><h3 id="9-使用-Git-分支的最佳实践"><a href="#9-使用-Git-分支的最佳实践" class="headerlink" title="9. 使用 Git 分支的最佳实践"></a>9. <strong>使用 Git 分支的最佳实践</strong></h3><ul><li><strong>主分支保持稳定</strong>：通常，<code>main</code> 或 <code>master</code> 分支应保持稳定。可以在其他功能分支中进行实验或开发，当确认无误后再合并回主分支。</li><li><strong>小而频繁的提交</strong>：在分支上工作时，进行小而频繁的提交有助于更好地追踪进展和更容易地解决冲突。</li><li><strong>定期同步主分支</strong>：如果功能分支开发周期较长，建议定期将 <code>main</code> 分支中的更新合并到功能分支，以避免较大的冲突。</li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 6</title>
    <link href="/2024/10/20/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-6/"/>
    <url>/2024/10/20/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-6/</url>
    
    <content type="html"><![CDATA[<h1 id="右值引用（C-11-C-17-C-20）"><a href="#右值引用（C-11-C-17-C-20）" class="headerlink" title="右值引用（C++11 C++17 C++20）"></a>右值引用（C++11 C++17 C++20）</h1><h2 id="1-左值和右值"><a href="#1-左值和右值" class="headerlink" title="1 左值和右值"></a>1 左值和右值</h2><p>在C++中</p><ul><li><strong>左值</strong>一般是指一个指向特定内存的具有名称的值（具名对象），它有一个相对稳定的内存地址，并且有一段较长的生命周期。</li><li><strong>右值</strong>则是不指向稳定内存地址的匿名值（不具名对象），它的生命周期很短，通常是暂时性的。</li></ul><p>基于这一特征，可以用取地址符&amp;来判断左值和右值，能取到内存地址的值为左值，否则为右值。</p><div class="note note-primary">            <p>除字符串字面量以外的字面量，通常都是右值。编译器会将字符串字面量存储到程序的数据段中，程序加载的时候也会为其开辟内存空间，所以我们可以使用取地址符&amp;来获取字符串字面量的内存地址。</p>          </div><h2 id="2-左值引用"><a href="#2-左值引用" class="headerlink" title="2 左值引用"></a>2 左值引用</h2><p>左值引用在传参的时候经常使用，可以免去创建一个临时对象的操作。</p><p>非常量左值引用的引用对象必须是一个左值</p><p>常量左值引用的引用对象可以引用右值。这个特性很有用，在作为参数的时候，可以接受一个右值，但是这会导致参数的常量性，需要右值引用来解决。</p><h2 id="3-右值引用"><a href="#3-右值引用" class="headerlink" title="3 右值引用"></a>3 右值引用</h2><p>右值引用是一种引用右值且只能引用右值的方法。在语法方面右值引用可以对比左值引用，在左值引用声明中，需要在类型后添加&amp;，而右值引用则是在类型后添加&amp;&amp;</p><p>右值引用的特点之一是可以延长右值的生命周期。以此达到减少复制，提升性能的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">X</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;X ctor&quot;</span> &lt;&lt; std::endl; &#125;<br>  <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;x) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;X copy ctor&quot;</span> &lt;&lt; std::endl; &#125;<br>  ~<span class="hljs-built_in">X</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;X dtor&quot;</span> &lt;&lt; std::endl; &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;show X&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function">X <span class="hljs-title">make_x</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  X x1;<br>  <span class="hljs-keyword">return</span> x1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  X &amp;&amp;x2 = <span class="hljs-built_in">make_x</span>();<br>  x<span class="hljs-number">2.</span><span class="hljs-built_in">show</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果执行 <code>X x2 = make_x();</code>，在没有任何优化的情况下，会执行三次构造函数，首先构造x1，然后return的时候执行拷贝构造函数构造一个临时对象，最后赋值的时候调用拷贝构造函数。</p><p>如果执行 <code>X &amp;&amp;x2 = make_x();</code>，则只会执行两次构造函数，前两次和上面一样，但是最后由于x2右值引用了临时对象，因此这个临时对象的生命期得以延长。</p><h2 id="4-移动语义"><a href="#4-移动语义" class="headerlink" title="4 移动语义"></a>4 移动语义</h2><p>c++11标准提供了移动语义，可以将资源在对象中进行转移，即进行浅拷贝的工作。</p><p>使用的时候有两点需要注意：</p><ol><li>同复制构造函数一样，编译器在一些条件下会生成一份移动构造函数，这些条件包括：没有任何的复制函数，包括复制构造函数和复制赋值函数；没有任何的移动函数，包括移动构造函数和移动赋值函数；也没有析构函数。虽然这些条件严苛得让人有些不太愉快，但是我们也不必对生成的移动构造函数有太多期待，因为编译器生成的移动构造函数和复制构造函数并没有什么区别。</li><li>虽然使用移动语义在性能上有很大收益，但是却也有一些风险，这些风险来自异常。试想一下，在一个移动构造函数中，如果当一个对象的资源移动到另一个对象时发生了异常，也就是说对象的一部分发生了转移而另一部分没有，这就会造成源对象和目标对象都不完整的情况发生，这种情况的后果是无法预测的。所以在编写移动语义的函数时建议确保函数不会抛出异常，与此同时，如果无法保证移动构造函数不会抛出异常，可以使用noexcept说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用std::terminate中止执行以免造成其他不良影响。</li></ol><h2 id="5-值类别"><a href="#5-值类别" class="headerlink" title="5 值类别"></a>5 值类别</h2><p>值类别是C++11标准中新引入的概念，具体来说它是表达式的一种属性，该属性将表达式分为3个类别，它们分别是左值（lvalue）、纯右值（prvalue）和将亡值（xvalue）。</p><p><img src="/../images/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-6/image-20241020202812151.png"></p><p>实际上，这里的左值（lvalue）就是上文中描述的C++98的左值，而这里的纯右值（prvalue）则对应上文中描述的C++98的右值。</p><p>将亡值（<strong>Xvalue</strong>，Expiring value）是表示即将“被销毁”的值，通常是<strong>资源可以被移动的对象</strong>。将亡值允许资源被“移动”，即允许将其内部的资源转移到另一个对象中，而不是拷贝。</p><p><strong>特点：</strong></p><ul><li>可以被移动构造或移动赋值。</li><li>典型的将亡值包括：返回右值引用的表达式、<code>std::move</code> 转换后的对象。</li></ul><h2 id="6-将左值转换为右值"><a href="#6-将左值转换为右值" class="headerlink" title="6 将左值转换为右值"></a>6 将左值转换为右值</h2><p>在c++11中，我们可以使用 <code>static_cast&lt;Foo&amp;&amp;&gt;(foo)</code> 将一个左值转换为一个将亡值，然后将右值引用绑定到这个将亡值上。此外，我们可以通过这种方式让左值使用移动语义。需要注意的是，转换前后，对象具有相同的内存地址和生命周期。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move_pool</span><span class="hljs-params">(BigMemoryPool &amp;&amp;pool)</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;call move_pool&quot;</span> &lt;&lt; std::endl;<br>  <span class="hljs-function">BigMemoryPool <span class="hljs-title">my_pool</span><span class="hljs-params">(pool)</span></span>; <span class="hljs-comment">// 调用拷贝构造函数</span><br>  <span class="hljs-function">BigMemoryPool <span class="hljs-title">my_pool1</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;BigMemoryPool&amp;&amp;&gt;(pool))</span></span>; <span class="hljs-comment">// 调用移动构造函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">move_pool</span>(<span class="hljs-built_in">make_pool</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个代码中，虽然 <code>make_pool</code> 返回的是一个临时对象，且 <code>move_pool</code> 的形参是一个右值引用，但是在构造 <code>my_pool</code> 的时候还是会执行拷贝构造函数。这是因为无论一个函数的实参是左值还是右值，即使形参是一个右值引用，这个形参本身也是一个左值。</p><p>c++11的标准库中提供了一个函数模板 <code>std::move</code> 来将左值转换为右值，本质也是用 <code>static_cast</code> 来做的转换，推荐使用 <code>std::move</code> 。</p><h2 id="7-万能引用和引用折叠"><a href="#7-万能引用和引用折叠" class="headerlink" title="7 万能引用和引用折叠"></a>7 万能引用和引用折叠</h2><p>含有 <code>T&amp;&amp;</code> 和 <code>auto&amp;&amp;</code> 的是万能引用。在这个推导过程中，初始化的源对象如果是一个左值，则目标对象会推导出左值引用；反之如果源对象是一个右值，则会推导出右值引用，不过无论如何都会是一个引用类型。</p><p>万能引用能如此灵活地引用对象，实际上是因为在C++11中添加了一套引用叠加推导的规则——引用折叠。</p><p><img src="/../images/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-6/image-20241020211329825.png"></p><h2 id="8-完美转发"><a href="#8-完美转发" class="headerlink" title="8 完美转发"></a>8 完美转发</h2><p>万能引用最典型的用途被称为完美转发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_type</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(t).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">normal_forwarding</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">show_type</span>(t);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::string s = <span class="hljs-string">&quot;hello world&quot;</span>;<br>  <span class="hljs-built_in">normal_forwarding</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面这个例子中，当调用 <code>normal_forwarding</code> 的时候，会拷贝一次字符串，然后调用 <code>show_type</code> 的时候，又将拷贝一次字符串。我们可以将 <code>normal_forwarding</code> 的形参声明为引用来减少一次拷贝，但是这会导致函数无法接受右值。这个问题也可以通过常量左值引用来解决，但是这就会导致无法修改字符串。</p><p>有了万能引用，就可以解决这个问题。需要注意的是，因为形参t一定是一个左值，为了让转发能够将左右值属性带到目标函数中去（<code>show_type</code>），这里需要进行类型转换，同样用到了引用折叠的概念。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_type</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(t).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perfect_forwarding</span><span class="hljs-params">(T &amp;&amp;t)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">show_type</span>(<span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t));<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">get_string</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi world&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::string s = <span class="hljs-string">&quot;hello world&quot;</span>;<br>  <span class="hljs-built_in">perfect_forwarding</span>(s);<br>  <span class="hljs-built_in">perfect_forwarding</span>(<span class="hljs-built_in">get_string</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>在c++11标准库中提供了 <code>std::forward</code> 函数模板，其内部也是使用 <code>static_cast</code> 进行的类型转换，但是采用 <code>std::forward</code> 使语义更加清楚。</p><p>注意 <code>std::move</code> 和 <code>std::forward</code> 的区别：</p><ul><li>其中 <code>std::move</code> 一定会将实参转换为一个右值引用，并且使用 <code>std::move</code> 不需要指定模板实参，模板实参是由函数调用推导出来的。</li><li>而 <code>std::forward</code> 会根据左值和右值的实际情况进行转发，在使用的时候<strong>需要指定模板实参</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 5</title>
    <link href="/2024/10/20/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-5/"/>
    <url>/2024/10/20/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-5/</url>
    
    <content type="html"><![CDATA[<h1 id="函数返回类型后置（C-11）"><a href="#函数返回类型后置（C-11）" class="headerlink" title="函数返回类型后置（C++11）"></a>函数返回类型后置（C++11）</h1><h2 id="1-使用函数返回类型后置声明函数"><a href="#1-使用函数返回类型后置声明函数" class="headerlink" title="1 使用函数返回类型后置声明函数"></a>1 使用函数返回类型后置声明函数</h2><p>返回复杂类型的时候，返回类型后置更有效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar_impl</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span><span class="hljs-params">(*bar)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">bar <span class="hljs-title">foo1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> bar_impl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span>-&gt;<span class="hljs-title">int</span><span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> bar_impl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> func = <span class="hljs-built_in">foo2</span>();<br>  <span class="hljs-built_in">func</span>(<span class="hljs-number">58</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-推导函数模板返回类型"><a href="#2-推导函数模板返回类型" class="headerlink" title="2 推导函数模板返回类型"></a>2 推导函数模板返回类型</h2><p>C++11标准中函数返回类型后置的作用之一是推导函数模板的返回类型，前提是需要用到decltype说明符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum1</span><span class="hljs-params">(T1 t1, T2 t2)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(t1 + t2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> t1 + t2;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> x1 = <span class="hljs-built_in">sum1</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 4</title>
    <link href="/2024/10/20/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-4/"/>
    <url>/2024/10/20/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-4/</url>
    
    <content type="html"><![CDATA[<h1 id="decltype说明符（C-11～C-17）"><a href="#decltype说明符（C-11～C-17）" class="headerlink" title="decltype说明符（C++11～C++17）"></a>decltype说明符（C++11～C++17）</h1><h2 id="1-使用decltype说明符"><a href="#1-使用decltype说明符" class="headerlink" title="1 使用decltype说明符"></a>1 使用decltype说明符</h2><p>decltype说明符可以获取对象或者表达式的类型。并且可以用于非静态成员变量。</p><p><strong>用处</strong></p><ol><li><p>在c++11标准中，不支持对auto声明的返回类型进行推导，所以需要用decltype在函数的尾部对返回类型进行说明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(T1 a1, T2 a2)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(a1 + a2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> a1 + a2;<br>&#125;<br><br><span class="hljs-keyword">auto</span> x4 = <span class="hljs-built_in">sum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10.5</span>);<br></code></pre></td></tr></table></figure></li><li><p>在c++14标准中，支持对auto声明的返回类型进行推导，可以简化为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(T1 a1, T2 a2)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> a1 + a2;<br>&#125;<br><br><span class="hljs-keyword">auto</span> x5 = <span class="hljs-built_in">sum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10.5</span>);<br></code></pre></td></tr></table></figure></li><li><p>但是，上述代码有一点问题，如果我们期望返回一个引用，上述代码无法做到。配合decltype可以做到</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">return_ref</span><span class="hljs-params">(T&amp; t)</span>-&gt;<span class="hljs-title">decltype</span><span class="hljs-params">(t)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">static_assert</span>(<br>    std::is_reference_v&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">return_ref</span>(x1))&gt;    <span class="hljs-comment">// 编译成功</span><br>    );<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-推导规则"><a href="#2-推导规则" class="headerlink" title="2 推导规则"></a>2 推导规则</h2><p>decltype(e)（其中e的类型为T）的推导规则有5条。</p><ol><li>如果e是一个<strong>未加括号的标识符表达式</strong>（结构化绑定除外）或者<strong>未加括号的类成员访问</strong>，则decltype(e)推断出的类型是e的类型T。如果并不存在这样的类型，或者e是一组重载函数，则无法进行推导。</li><li>如果e是一个<strong>函数调用或者仿函数调用</strong>，那么decltype(e)推断出的类型是其<strong>返回值的类型</strong>。</li><li>如果e是一个<strong>类型为T的左值</strong>，则decltype(e)是T&amp;。</li><li>如果e是一个<strong>类型为T的将亡值</strong>，则decltype(e)是T&amp;&amp;。</li><li>除去以上情况，则decltype(e)是T。</li></ol><h2 id="3-cv限定符的推导"><a href="#3-cv限定符的推导" class="headerlink" title="3 cv限定符的推导"></a>3 cv限定符的推导</h2><ul><li>通常情况下，推导会同步e的cv限定符。</li><li>当e是未加括号的成员变量时，父对象表达式的cv限定符会被忽略</li><li>当e是加括号的成员变量时，父对象表达式的cv限定符会同步到结果</li></ul><h2 id="4-decltype-auto"><a href="#4-decltype-auto" class="headerlink" title="4 decltype(auto)"></a>4 decltype(auto)</h2><p>C++14标准中出现了decltype和auto两个关键字的结合体：decltype(auto)。它的作用简单来说，就是告诉编译器用decltype的推导表达式规则来推导auto。另外需要注意的是，decltype(auto)必须单独声明，也就是它不能结合指针、引用以及cv限定符。</p><p>有了这个用法，上述返回引用的类型可以进一步优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">return_ref</span><span class="hljs-params">(T&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">static_assert</span>(<br>    std::is_reference_v&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">return_ref</span>(x1))&gt;    <span class="hljs-comment">// 编译成功</span><br>    );<br></code></pre></td></tr></table></figure><h2 id="5-decltype-auto-作为非类型模板形参占位符"><a href="#5-decltype-auto-作为非类型模板形参占位符" class="headerlink" title="5 decltype(auto)作为非类型模板形参占位符"></a>5 decltype(auto)作为非类型模板形参占位符</h2><p>与auto一样，在C++17标准中decltype(auto)也能作为非类型模板形参的占位符</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 8</title>
    <link href="/2024/10/20/OS-Three-Easy-Pieces-Chapter-8/"/>
    <url>/2024/10/20/OS-Three-Easy-Pieces-Chapter-8/</url>
    
    <content type="html"><![CDATA[<h1 id="Scheduling-The-Multi-Level-Feedback-Queue"><a href="#Scheduling-The-Multi-Level-Feedback-Queue" class="headerlink" title="Scheduling: The Multi-Level Feedback Queue"></a>Scheduling: The Multi-Level Feedback Queue</h1><p>多级反馈队列（Multi-level Feedback Queue，MLFQ）需要解决两个问题：</p><ol><li><p>优化周转时间</p><p>通过SJF或者STCT可以优化周转时间，但是这需要提前知道一个任务的运行时间。</p></li><li><p>优化响应时间</p><p>RR可以优化响应时间，但是周转时间很差。</p></li></ol><h2 id="1-MLFQ-Basic-Rules"><a href="#1-MLFQ-Basic-Rules" class="headerlink" title="1 MLFQ: Basic Rules"></a>1 MLFQ: Basic Rules</h2><p>多级反馈队列有多个队列，每个队列的优先级不同。总是让优先级高的任务先运行，如果两个任务在同一个队列（优先级相同），则使用RR策略。</p><ul><li>规则1：如果$Priority(A) &gt; Priority(b)$，那么A运行</li><li>规则2：如果$Priority(A) &#x3D; Priority(B)$，那么A，B用RR策略</li></ul><p>多级反馈队列根据任务的历史行为来预测任务的未来行为，并以此调整任务的优先级。如果一个任务频繁的放弃CPU，申请IO，那么维持这个任务的高优先级（IO密集型），因为该任务可能需要较强的交互性；反之，如果一个任务使用CPU很长一段时间（CPU密集型），那么降低任务的优先级。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-8/image-20241020162512090.png"></p><h2 id="2-Attempt-1-How-To-Change-Priority"><a href="#2-Attempt-1-How-To-Change-Priority" class="headerlink" title="2 Attempt #1: How To Change Priority"></a>2 Attempt #1: How To Change Priority</h2><p><strong>任务的配额</strong>：即一个给定任务在当前优先级的队列能运行的时间，如果时间用完了，那么就会降低其优先级。</p><ul><li><strong>规则3</strong>：作业进入系统时，会被置于最高优先级（最顶队列）。</li><li><strong>规则4a</strong>：如果作业在运行过程中用完了分配资源，其优先级就会降低（即向下移动一个队列）。</li><li><strong>规则4b</strong>：如果作业在分配时间结束前放弃 CPU（如执行 I&#x2F;O 操作），则其优先级保持不变（即其分配时间被重置）。</li></ul><p><strong>问题</strong></p><ol><li><p>饥饿问题</p><p>如果一直有短作业到来，那么优先级低的任务将永远无法运行。</p></li><li><p>恶意程序</p><p>如果一个任务在用完自己的时间片之前，申请一个IO操作，那么它将永远维持高优先级，导致分配不公平。</p></li><li><p>任务变动</p><p>如果一个任务从CPU密集型转变为IO密集型，如何处理</p></li></ol><h2 id="3-Attempt-2-The-Priority-Boost"><a href="#3-Attempt-2-The-Priority-Boost" class="headerlink" title="3 Attempt #2: The Priority Boost"></a>3 Attempt #2: The Priority Boost</h2><ul><li><strong>规则5</strong>：在经过一段时间S后，将所有的任务重新放置在最高优先级队列中。</li></ul><p>通过这么做，解决了上述的问题1和问题2。</p><p>S的值很难确定，如果太长，会导致低优先级的任务饥饿；如果太短，会导致交互性降低。</p><h2 id="4-Attempt-3-Better-Accounting"><a href="#4-Attempt-3-Better-Accounting" class="headerlink" title="4 Attempt #3: Better Accounting"></a>4 Attempt #3: Better Accounting</h2><p>调度器应该记录每个任务在当前队列的运行时间，只要用完了时间片，就降低其优先级。所以，规则4修改为</p><ul><li><strong>规则4</strong>：一旦某项作业用完了给定级别的时间分配（无论它让出 CPU 多少次），其优先级就会降低（即向下移动一个队列）。</li></ul><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-8/image-20241020164719536.png"></p><h2 id="5-Tuning-MLFQ-And-Other-Issues"><a href="#5-Tuning-MLFQ-And-Other-Issues" class="headerlink" title="5 Tuning MLFQ And Other Issues"></a>5 Tuning MLFQ And Other Issues</h2><p>大多数实现允许不同优先级的队列有不同的时间片大小，高优先级的通常小一点，低优先级的通常高一些。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 7</title>
    <link href="/2024/10/20/OS-Three-Easy-Pieces-Chapter-7/"/>
    <url>/2024/10/20/OS-Three-Easy-Pieces-Chapter-7/</url>
    
    <content type="html"><![CDATA[<h1 id="Scheduling-Introduction"><a href="#Scheduling-Introduction" class="headerlink" title="Scheduling: Introduction"></a>Scheduling: Introduction</h1><h2 id="1-Workload-Assumptions"><a href="#1-Workload-Assumptions" class="headerlink" title="1 Workload Assumptions"></a>1 Workload Assumptions</h2><ol><li>Each job runs for the same amount of time. </li><li>All jobs arrive at the same time. </li><li>Once started, each job runs to completion. </li><li>All jobs only use the CPU (i.e., they perform no I&#x2F;O) </li><li>The run-time of each job is known.</li></ol><h2 id="2-Scheduling-Metrics"><a href="#2-Scheduling-Metrics" class="headerlink" title="2 Scheduling Metrics"></a>2 Scheduling Metrics</h2><ul><li>周转时间（turnaround time）：$T_{turnaround} &#x3D; T_{completion} - T_{arrival}$</li><li>公平性</li><li>响应时间（response time）：$T_{response} &#x3D; T_{fisrtrun} - T_{arrival}$</li></ul><h2 id="3-First-In-First-Out-FIFO"><a href="#3-First-In-First-Out-FIFO" class="headerlink" title="3 First In, First Out (FIFO)"></a>3 First In, First Out (FIFO)</h2><p>最基本的调度算法，先到来的任务先执行，也称为先来先服务（FCFS）。</p><p><strong>优点</strong></p><ul><li>实现简单</li><li>无饥饿现象</li></ul><p><strong>缺点</strong></p><ul><li>存在护航效应（convoy effect），即短作业排在长作业之后，导致系统平均周转时间边长。</li></ul><h2 id="4-Shortest-Job-First-SJF"><a href="#4-Shortest-Job-First-SJF" class="headerlink" title="4  Shortest Job First (SJF)"></a>4  Shortest Job First (SJF)</h2><p>每次选择调度当前最短的任务。传统上是不可抢占的。</p><p><strong>优点</strong></p><ul><li>平均周转时间较短</li><li>简单</li></ul><p><strong>缺点</strong></p><ul><li>当任务到达时间不同的时候，仍然存在护航效应</li></ul><h2 id="5-Shortest-Time-to-Completion-First-STCF"><a href="#5-Shortest-Time-to-Completion-First-STCF" class="headerlink" title="5 Shortest Time-to-Completion First (STCF)"></a>5 Shortest Time-to-Completion First (STCF)</h2><p>最短完成时间，也称为抢占式短作业优先（PSJF）。</p><p>该调度策略是对短作业优先的改进，每当有新的任务到来的时候，就抢占当前进程，让调度器根据目前所需最短完成时间来进行调度。</p><p><strong>优点</strong></p><ul><li>解决了SJF的护航效应</li></ul><p><strong>缺点</strong></p><ul><li>响应时间长，交互性差</li></ul><h2 id="6-Round-Robin"><a href="#6-Round-Robin" class="headerlink" title="6 Round Robin"></a>6 Round Robin</h2><p>将CPU划分为时间片，平均分配给各个进程，每个进程轮流得到时间片。</p><p><strong>优点</strong></p><ul><li>公平</li><li>响应时间低</li></ul><p><strong>缺点</strong></p><ul><li>平均周转时间差（最差之一）</li></ul><p>时间片过长会导致响应时间变差，最坏情况下会退化成FCFS。时间片过短虽然会提升响应时间，但是会导致上下文切换开销过大。需要注意的是，这种开销不单单是切换寄存器的值，当程序运转的时候，会在CPU缓存，TLB，分支预测等硬件建立很多状态来提升效率，当切换进程的时候，这些状态全部需要替换，造成一定的开销。</p><h2 id="7-Incorporating-I-O"><a href="#7-Incorporating-I-O" class="headerlink" title="7 Incorporating I&#x2F;O"></a>7 Incorporating I&#x2F;O</h2><p>将任务分为CPU密集型和IO密集型，IO密集型的优先级更高，这样可以更好的利用资源。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-7/image-20241020160849081.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 6</title>
    <link href="/2024/10/19/OS-Three-Easy-Pieces-Chapter-6/"/>
    <url>/2024/10/19/OS-Three-Easy-Pieces-Chapter-6/</url>
    
    <content type="html"><![CDATA[<h1 id="Mechanism-Limited-Direct-Execution"><a href="#Mechanism-Limited-Direct-Execution" class="headerlink" title="Mechanism: Limited Direct Execution"></a>Mechanism: Limited Direct Execution</h1><p>操作系统必须以<strong>高效</strong>的方式虚拟化 CPU，同时保留对系统的<strong>控制</strong>。为此，需要<strong>硬件</strong>和<strong>操作系统</strong>的支持。操作系统通常会明智地使用一些硬件支持，以便有效地完成工作。</p><h2 id="1-Basic-Technique-Limited-Direct-Execution"><a href="#1-Basic-Technique-Limited-Direct-Execution" class="headerlink" title="1 Basic Technique: Limited Direct Execution"></a>1 Basic Technique: Limited Direct Execution</h2><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-6/image-20241019145343980.png"></p><p>图中显示了直接执行的简要流程，这个流程存在两个问题：</p><ul><li>操作系统如何保持对进程的控制，防止其做违法操作</li><li>操作系统如何切换进程，以在多个进程间共享CPU</li></ul><h2 id="2-Problem-1-Restricted-Operations"><a href="#2-Problem-1-Restricted-Operations" class="headerlink" title="2 Problem #1: Restricted Operations"></a>2 Problem #1: Restricted Operations</h2><p>为了限制进程的行为，提出内核态和用户态的概念。</p><p>用户进程一般运行在用户态，用户态中对硬件资源的访问是受限的，不能执行特权指令（访问IO等）；而操作系统内核一般运行在内核态，在内核态中对硬件资源有完整的访问权限，可以执行特权指令，访问各种IO等。</p><p>有了这个概念，当一个用户进程希望访问一些硬件资源的时候，需要执行系统调用，告诉操作系统他要干啥，然后操作系统进行一些参数、权限检查等，确保用户进程有权利执行这个操作，并且这个操作不是一些恶意操作，然后替用户进程执行这个操作，再返回用户进程继续执行。从用户进程的视角来看，系统调用就像任何一个正常的函数调用一样。</p><p>为了执行系统调用，程序必须执行一个特殊的<strong>trap</strong>指令，该指令跳转到内核中并修改当前态为内核态，同时，该指令也会保存一些寄存器到内核栈（每个进程都有一个）中，以便能够顺利返回到用户进程。当操作系统完成系统调用后，会执行一个特殊的返回指令，该指令从内核栈中恢复寄存器的值，返回到用户进程继续执行，并修改当前态为用户态。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-6/image-20241019152221694.png"></p><p>最后，一个trap指令如何知道跳转到哪里执行呢，如何区分不同的系统调用。我们不能允许用户进程直接指定执行指令的位置，因此，操作系统通过一个trap table来实现。trap table实际上就是一个表格，将不同的系统调用映射到对应的处理例程的地址。执行trap指令的时候，由用户负责提供一个系统调用号，然后操作系统根据这个系统调用号跳转到对应的地方执行。trap table是在操作系统boot的时候设定的（通过某种特权指令告诉硬件trap table的地址，硬件记住这个地址，之后直接到这里查找）。</p><h2 id="3-Problem-2-Switching-Between-Processes"><a href="#3-Problem-2-Switching-Between-Processes" class="headerlink" title="3 Problem #2: Switching Between Processes"></a>3 Problem #2: Switching Between Processes</h2><h3 id="操作系统如何获取控制权"><a href="#操作系统如何获取控制权" class="headerlink" title="操作系统如何获取控制权"></a>操作系统如何获取控制权</h3><p>进程切换的第一个问题是，当进程上CPU执行之后，操作系统理论上就不能执行任何操作了（没有CPU资源），那么操作系统如何切换进程？因此，我们需要提供一种机制让操作系统能够重新获取控制权。</p><ol><li><p>合作方法：等待进程执行系统调用</p><p>在早期的OS中，内核相信进程会时不时的让出CPU的控制权，即使进程不让出控制权，其也会时不时的执行系统调用，或者是触发异常等，操作系统在此时获取控制权。然而，当进程陷入死循环中，操作系统就无法获取控制权了。</p></li><li><p>非合作方法：操作系统接管</p><p>通过借助硬件的帮助（<strong>时钟中断</strong>），操作系统可以获取控制权。具体的，在boot的时候，操作系统告诉硬件，当发生时钟中断的时候，执行什么代码，然后启动时钟。这样，当时钟中断发生的时候，当前进程就会停止执行，然后跳转到时钟中断处理程序中执行，这时，操作系统就获取了控制权，可以做任何事情。</p><p>需要注意的是，对中断处理和系统调用很类似，硬件都要负责保存寄存器的值，切换态等，以便之后能够顺利继续执行。</p></li></ol><h2 id="4-Saving-and-Restoring-Context"><a href="#4-Saving-and-Restoring-Context" class="headerlink" title="4 Saving and Restoring Context"></a>4 Saving and Restoring Context</h2><p>上下文切换要做的事情其实很简单，保存当前进程的寄存器的值到PCB中，然后从要切换的进程的PCB中恢复这些值到寄存器中。具体的，当时钟中断发生的时候，硬件会负责将一些寄存器保存到当前进程A的内核栈中，然后进入时钟中断处理程序执行，并切换到内核态，内核决定要进行调度，切换另一个进程B执行，此时进行上下文切换，将当前寄存器的值保存到当前进程A的PCB中，然后从进程B的PCB中恢复这些寄存器的值，然后切换到进程B的内核栈，此时执行返回指令，硬件从内核栈中恢复寄存器的值，跳转到进程B被中断的地方继续执行。可能还会涉及额外的页表的切换。</p><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-6/image-20241019163100890.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 5</title>
    <link href="/2024/10/18/OS-Three-Easy-Pieces-Chapter-5/"/>
    <url>/2024/10/18/OS-Three-Easy-Pieces-Chapter-5/</url>
    
    <content type="html"><![CDATA[<h1 id="Interlude-Process-API"><a href="#Interlude-Process-API" class="headerlink" title="Interlude: Process API"></a>Interlude: Process API</h1><span id="more"></span><h2 id="1-The-fork-System-Call"><a href="#1-The-fork-System-Call" class="headerlink" title="1 The fork() System Call"></a>1 The <code>fork()</code> System Call</h2><p><code>fork</code> 系统调用创建一个新的进程，新的进程几乎和原来的进程完全一样，具体来说，它返回给 <code>fork</code> 调用的返回值和父进程是不同的。在父进程中，返回值是子进程的PID，而在子进程中，返回值是0. 新进程不会从 <code>main</code> 开始执行，而是从调用 <code>fork</code> 的指令的下一条指令开始执行。</p><p>需要注意的是，当创建好进程之后，此时系统中就有两个就绪的进程（父进程和子进程），二者谁先运行是不确定的，我们不能对此做任何假设。</p><h2 id="2-The-wait-System-Call"><a href="#2-The-wait-System-Call" class="headerlink" title="2 The wait() System Call"></a>2 The <code>wait()</code> System Call</h2><p>有时候，父进程等待子进程完成是很有必要的，可以使用 <code>wait</code> 或者 <code>waitpid</code> 系统调用来实现。父进程调用 <code>wait</code> 阻塞等待子进程执行并完成，只有在子进程退出后，父进程才会从 <code>wait</code> 系统调用返回，继续执行。</p><h2 id="3-Finally-The-exec-System-Call"><a href="#3-Finally-The-exec-System-Call" class="headerlink" title="3 Finally, The exec() System Call"></a>3 Finally, The exec() System Call</h2><p><code>exec</code> 系统调用用另一个可执行程序的代码和静态数据覆盖当前进程的代码和可执行数据，堆栈等内存空间都被重新初始化，之后操作系统运行这个新的程序。</p><p>成功的 <code>exec</code> 调用不会返回。</p><h2 id="4-Why-Motivating-The-API"><a href="#4-Why-Motivating-The-API" class="headerlink" title="4 Why? Motivating The API"></a>4 Why? Motivating The API</h2><p>之所以要这样设计 <code>fork</code> 和 <code>exec</code> ，是因为这种设计可以允许shell在 <code>fork</code> 之后，<code>exec</code> 之前执行一些代码。这样可以让我们简单的实现一些有用的特性。</p><p>例如IO重定向（<code>wc p3.c &gt; p3.output</code>），我们可以在子进程执行 <code>exec</code> 之前，关闭标准输出，然后打开p3.output文件，这样之后子进程运行的任何本来应该输出到标准输出的内容都会写入p3.output中。之所以会这样是因为在 <code>exec</code> 系统调用中，文件描述符是不会发生改变的，并且unix分配文件描述符是从0开始寻找第一个尚未分配的文件描述符，当我们关闭标准输出之后，子进程的1号文件描述符就可用了，这时如果我们打开一个文件，操作系统会将1号文件描述符分配给该文件。</p><h2 id="5-Process-Control-And-Users"><a href="#5-Process-Control-And-Users" class="headerlink" title="5 Process Control And Users"></a>5 Process Control And Users</h2><p>除了 fork()、exec() 和 wait()，UNIX 系统中还有很多与进程交互的接口。例如，kill() 系统调用用于向进程发送信号，包括暂停、死亡和其他有用的指令。在大多数 UNIX shell 中，某些按键组合被配置为向当前运行的进程发送特定信号；例如，control-c 会向进程发送 SIGINT（中断）信号（通常会终止进程），而 control-z 则会发送 SIGTSTP（停止）信号，从而使进程在执行中途暂停（可以稍后使用命令恢复进程，例如许多 shell 中的 fg 内置命令）</p><p>整个信号系统提供了丰富的基础设施，用于向进程发送外部事件，包括在单个进程内接收和处理这些信号的方法，以及向单个进程和整个进程组发送信号的方法。要使用这种通信方式，进程应使用 signal() 系统调用来 “捕获 ”各种信号；这样做可确保当特定信号传送到进程时，进程将暂停其正常执行，并运行特定代码来响应该信号。</p><p>这自然会引出一个问题：谁能向进程发送信号，谁不能？一般来说，我们使用的系统可能会有多人同时使用；如果其中一人可以任意发送 SIGINT 等信号（中断进程，很可能终止进程），那么系统的可用性和安全性就会受到影响。因此，现代系统中包含了强烈的用户概念。用户在输入密码建立凭证后，登录以访问系统资源。然后，用户可以启动一个或多个进程，并对它们进行完全控制（暂停、杀死等）。用户通常只能控制自己的进程。</p><h2 id="6-Useful-Tools"><a href="#6-Useful-Tools" class="headerlink" title="6 Useful Tools"></a>6 Useful Tools</h2><p>还有许多命令行工具也很有用。</p><ul><li>例如，使用 ps 命令可以查看正在运行的进程；</li><li>top 工具也很有用，它可以显示系统进程及其占用的 CPU 和其他资源。</li><li>kill 命令可以用来向进程发送任意信号。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[OS]Three Easy Pieces Chapter 4</title>
    <link href="/2024/10/18/OS-Three-Easy-Pieces-Chapter-4/"/>
    <url>/2024/10/18/OS-Three-Easy-Pieces-Chapter-4/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Abstraction-The-Process"><a href="#The-Abstraction-The-Process" class="headerlink" title="The Abstraction: The Process"></a>The Abstraction: The Process</h1><span id="more"></span><p>进程的定义，简单来说，就是运行的程序。</p><p><strong>主要的挑战</strong>：</p><p>即使我们只有几个实际的物理CPU，操作系统如何提供一个有无限CPU的假象。</p><p>操作系统通过<strong>虚拟化</strong>来提供这种假象。为了实现这种虚拟化，我们需要：</p><ul><li>低级硬件支持：上下文切换</li><li>高级策略：调度策略（根据历史信息、工作负载、性能指标等）</li></ul><h2 id="1-The-Abstraction-A-Process"><a href="#1-The-Abstraction-A-Process" class="headerlink" title="1 The Abstraction: A Process"></a>1 The Abstraction: A Process</h2><p>操作系统对运行中程序的抽象，称之为进程。进程只是一个运行中的程序；在任何时间，我们都可以通过盘点进程在执行过程中访问或影响的系统的不同部分来概括进程</p><p>在任何时候，一个进程都可以通过以下状态来描述：</p><ul><li>内存空间中的内容</li><li>寄存器中的值</li><li>交互的IO设备</li></ul><h2 id="2-Process-API"><a href="#2-Process-API" class="headerlink" title="2 Process API"></a>2 Process API</h2><p>抽象的来看，任何操作系统至少要提供一下API</p><ul><li><p>Create</p></li><li><p>Destroy</p></li><li><p>Wait</p></li><li><p>Miscel Control</p><p>例如，OS希望可以暂停某个进程的执行，之后再继续执行它</p></li><li><p>Status</p><p>获取进程的一些状态信息</p></li></ul><h2 id="3-Process-Creation-A-Little-More-Detail"><a href="#3-Process-Creation-A-Little-More-Detail" class="headerlink" title="3 Process Creation: A Little More Detail"></a>3 Process Creation: A Little More Detail</h2><p>为了执行一个程序，操作系统：</p><ul><li><p>首先，将硬盘中的程序（指令、静态数据等）装载进内存中。</p><p>硬盘中的程序必须符合某种<strong>可执行格式</strong>。早期的操作系统装载时将整个程序装载进内存，现代操作系统通常采用懒装载，即，只将需要的内容装载到内存中。</p></li><li><p>之后，操作系统需要分配栈内存，并用参数初始化这个栈（argc，argv）</p></li><li><p>分配堆内存</p></li><li><p>处理IO相关的初始化</p><p>Unix中，每个进程初始有三个打开的文件描述符（标准输入，标准输出，标准错误）</p></li><li><p>最后，操作系统跳转到新进程的entry point（main()）开始执行。</p></li></ul><h2 id="4-Process-States"><a href="#4-Process-States" class="headerlink" title="4 Process States"></a>4 Process States</h2><p><img src="/../images/OS-Three-Easy-Pieces-Chapter-4/image-20241018151951494.png" alt="进程三状态模型"></p><h2 id="5-Data-Structures"><a href="#5-Data-Structures" class="headerlink" title="5 Data Structures"></a>5 Data Structures</h2><p>操作系统需要记录所有就绪进程，运行进程，阻塞进程，并且能够正确的转换进程的状态。比如，当某个IO事件完成了，需要将任何等待该事件的进程从阻塞队列移动到就绪队列中。</p><p>在xv6内核中，操作系统需要跟踪并记录如下内容。当一个进程将要进行上下文切换的时候，将其寄存器的值保存到 <code>context</code> 结构体中，之后将下一个要调度的进程的 <code>context</code> 结构体中的值装载到实际的寄存器中，完成上下文切换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Saved registers for kernel context switches.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> &#123;</span><br>  uint64 ra;<br>  uint64 sp;<br><br>  <span class="hljs-comment">// callee-saved</span><br>  uint64 s0;<br>  uint64 s1;<br>  uint64 s2;<br>  uint64 s3;<br>  uint64 s4;<br>  uint64 s5;<br>  uint64 s6;<br>  uint64 s7;<br>  uint64 s8;<br>  uint64 s9;<br>  uint64 s10;<br>  uint64 s11;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> &#123;</span> UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;<br><br><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-type">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-type">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-type">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-type">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-type">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">usyscall</span>;</span>   <span class="hljs-comment">// shared data between kernel and user</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]47.全排列Ⅱ</title>
    <link href="/2024/10/18/LC-47-%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1/"/>
    <url>/2024/10/18/LC-47-%E5%85%A8%E6%8E%92%E5%88%97%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题目给定的数组中存在重复数字，我们可以先将数字排序，然后在枚举$pos$的时候只枚举不同的元素，如果当前元素已经在当前位置被枚举过了，则跳过，保证每个位置每个元素只会被枚举一次。</p><p>需要特别注意的是跳过条件，如果我们只是单纯的采用如下条件判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>这会导致枚举下一个位置的时候，也无法枚举相同的元素，比如1，1，2。当我们在第一个位置枚举了1，第二个位置就不能枚举1了，会被跳过。所以我们需要添加一个条件，只有当上一个位置的重复元素没有被访问的时候，我们才跳过，否则我们不应该跳过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !visited[i - <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permuteUnique</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        cur = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        vis = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>] &amp;&amp; !vis[i - <span class="hljs-number">1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            cur[pos] = nums[i];<br>            <span class="hljs-built_in">backtrack</span>(nums, pos + <span class="hljs-number">1</span>);<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]46.全排列</title>
    <link href="/2024/10/18/LC-46-%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <url>/2024/10/18/LC-46-%E5%85%A8%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="标记数组"><a href="#标记数组" class="headerlink" title="标记数组"></a>标记数组</h4><p>每次枚举一个位置$pos$的可能的值，当前枚举的值在标记数组中标记，然后继续枚举下一个位置。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        cur = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>);<br>        vis = <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(nums.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">backtrace</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(cur);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            cur[pos] = nums[i];<br>            <span class="hljs-built_in">backtrace</span>(nums, pos + <span class="hljs-number">1</span>);<br>            vis[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    vector&lt;<span class="hljs-type">int</span>&gt; cur;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; vis;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>空间复杂度：</strong>$O(n)$</p><h4 id="原地"><a href="#原地" class="headerlink" title="原地"></a>原地</h4><p>我们可以将当前枚举的元素交换到数组的前端，使得$[0, pos]$的元素是枚举过的元素，而$[pos + 1, n - 1]$的元素是尚未枚举过的元素，这样枚举下个位置的时候直接从$pos+1$开始枚举，就能保证枚举的元素一定是未枚举过的元素。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">backtrack</span>(nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> pos)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (pos == nums.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(nums);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = pos; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[pos]);<br>            <span class="hljs-built_in">backtrack</span>(nums, pos + <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">swap</span>(nums[i], nums[pos]);<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>空间复杂度：</strong>$O(1)$.</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]24.接雨水</title>
    <link href="/2024/10/18/LC-24-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
    <url>/2024/10/18/LC-24-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定 <code>n</code> 个非负整数表示每个宽度为 <code>1</code> 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h4><p>对于每个位置 <code>i</code> ，分别找到其左右的最大高度$leftMax$和$rightMax$，那么该点能接的雨水值为$min(leftMax, rightMax) - height_i$. </p><p><strong>时间复杂度</strong>: $O(n^2)$</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>观察暴力算法，我们不难发现，时间复杂度高的原因主要是因为对于每个位置，寻找其左右的最大值需要$O(n)$的时间复杂度，我们可以用数组$leftMax$来维护每个位置左边的最大值，这样在遍历的时候只需要$O(1)$就能找到其左边的最大值，对于右边的最大值同理。</p><p>为了求得每个位置左边的最大值，规定$leftMax[i]$表示位置$i$左边的最大值，由此可以得到状态转移方程：<br>$$<br>\begin{align}<br>    &amp; leftMax[i] &#x3D; max(leftMax[i - 1], height[i]) \\<br>    &amp; rightMax[i] &#x3D; max(rightMax[i + 1], height[i])<br>\end{align}<br>$$<br>我们只需要从前往后遍历一遍数组，就可以得到$leftMax$，从后往前遍历一遍数组，就可以得到$rightMax$.时间复杂度为$O(n)$.</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftMax</span><span class="hljs-params">(n, height[<span class="hljs-number">0</span>])</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rightMax</span><span class="hljs-params">(n, height[n - <span class="hljs-number">1</span>])</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>        &#123;<br>            leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i - <span class="hljs-number">1</span>], height[i]);<br>            rightMax[n - i - <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(rightMax[n - i], height[n - i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            ans += (<span class="hljs-built_in">min</span>(leftMax[i], rightMax[i]) - height[i]); <br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(n)$</p><p><strong>空间复杂度：</strong>$O(n)$</p><h4 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h4><p>观察动态规划算法，我们可以发现，$leftMax$和$rightMax$数组是单调的，而且每个位置$i$的能接的雨水只取决于左边和右边最大值中较小的一个。如果我们使用双指针来做，边遍历边维护左右最大值。左指针指向的位置的左边最大值就是当前位置$i$的左边的最大值，右指针指向的位置的右边最大值就是当前位置$i$的右边的最大值。即，左指针的左边最大值是确定的，而右边的最大值有可能会增大，右指针的右边最大值是确定的，而左边的最大值可能会增大。此时，如果左边的最大值小于右边的最大值，那么左指针指向位置的值就可以计算了，因为其只取决于左边的最大值，如果右边的最大值小于左边的最大值，那么右指针指向位置的值就可以计算了。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = height.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> leftMax = height[<span class="hljs-number">0</span>], rightMax = height[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)<br>        &#123;<br>            leftMax = <span class="hljs-built_in">max</span>(leftMax, height[left]);<br>            rightMax = <span class="hljs-built_in">max</span>(rightMax, height[right]);<br>            <span class="hljs-keyword">if</span> (leftMax &lt;= rightMax)<br>                ans += (leftMax - height[left++]);<br>            <span class="hljs-keyword">else</span> <br>                ans += (rightMax - height[right--]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(n)$</p><p><strong>空间复杂度：</strong>$O(1)$</p><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><p>用一个单调栈来维护数组下标，保证靠近栈底的高度不小于靠近栈顶的高度。当遇到一个位置$i$的高度大于栈顶高度的时候，当前位置$i$，栈顶的位置$top$，栈顶第二个位置$left$，三者就可能构成一个凹槽，能够接雨水($height[left] &gt;&#x3D; height[top], height[i] &gt; height[top], left &lt; top &lt; i$).接的雨水量等于$(min(height[left], height[i]) - height[top]) \times (i - left - 1)$.</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">trap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; height.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; height[s.<span class="hljs-built_in">top</span>()] &lt; height[i])<br>            &#123;<br>                <span class="hljs-type">int</span> top = s.<span class="hljs-built_in">top</span>(); s.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-type">int</span> left = s.<span class="hljs-built_in">top</span>();<br>                ans += ((<span class="hljs-built_in">min</span>(height[left], height[i]) - height[top]) *<br>                        (i - left - <span class="hljs-number">1</span>));<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(n)$.</p><p><strong>空间复杂度：</strong>$O(n)$.</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>dp</tag>
      
      <tag>单调栈</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]146.LRU缓存</title>
    <link href="/2024/10/18/LC-146-LRU%E7%BC%93%E5%AD%98/"/>
    <url>/2024/10/18/LC-146-LRU%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>为了满足平均$O(1)$的时间复杂度，采用哈希表+双链表的方式实现。其中哈希表用来查找指定的键，而双链表则用来维护访问时间，将最近访问过的值放在链表头，最久未使用的值放在队尾。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> cap): <span class="hljs-built_in">capacity</span>(cap), <span class="hljs-built_in">size</span>(<span class="hljs-number">0</span>) &#123;<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>();<br>        head-&gt;next = tail;<br>        tail-&gt;prev = head;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">find</span>(key) == cache.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">auto</span> node = cache[key];<br>        <span class="hljs-built_in">move2head</span>(node);<br>        <span class="hljs-keyword">return</span> node-&gt;val;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.<span class="hljs-built_in">find</span>(key) != cache.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> node = cache[key];<br>            node-&gt;val = value;<br>            <span class="hljs-built_in">move2head</span>(node);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (size == capacity)<br>            &#123;<br>                <span class="hljs-comment">// 1.删除LRU元素</span><br>                <span class="hljs-comment">// 1.1 从哈希表中删除</span><br>                cache.<span class="hljs-built_in">erase</span>(tail-&gt;prev-&gt;key);<br>                <span class="hljs-comment">// 1.2 从链表中删除</span><br>                tail-&gt;prev-&gt;val = value;<br>                tail-&gt;prev-&gt;key = key;<br>                <span class="hljs-comment">// 2.插入新元素</span><br>                cache.<span class="hljs-built_in">emplace</span>(key, tail-&gt;prev);<br>                <span class="hljs-comment">// 3.移动到对头</span><br>                <span class="hljs-built_in">move2head</span>(tail-&gt;prev);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                ++size;<br>                <span class="hljs-keyword">auto</span> node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DLinkedNode</span>(key, value);<br>                <span class="hljs-built_in">add2head</span>(node);<br>                cache.<span class="hljs-built_in">emplace</span>(key, node);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">LRUCache</span>()<br>    &#123;<br>        <span class="hljs-keyword">delete</span> head;<br>        <span class="hljs-keyword">delete</span> tail;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DLinkedNode</span>&#123;<br>        <span class="hljs-type">int</span> key, val;<br>        DLinkedNode *prev;<br>        DLinkedNode *next;<br>        <span class="hljs-built_in">DLinkedNode</span>(): <span class="hljs-built_in">key</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>        <span class="hljs-built_in">DLinkedNode</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v): <span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">val</span>(v), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    &#125;;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add2head</span><span class="hljs-params">(DLinkedNode *node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        node-&gt;next = head-&gt;next;<br>        head-&gt;next-&gt;prev = node;<br>        head-&gt;next = node;<br>        node-&gt;prev = head;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeNode</span><span class="hljs-params">(DLinkedNode *node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        node-&gt;prev-&gt;next = node-&gt;next;<br>        node-&gt;next-&gt;prev = node-&gt;prev;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move2head</span><span class="hljs-params">(DLinkedNode *node)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">removeNode</span>(node);<br>        <span class="hljs-built_in">add2head</span>(node);<br>    &#125;<br>    <br>    unordered_map&lt;<span class="hljs-type">int</span>, DLinkedNode*&gt; cache;<br>    DLinkedNode *head;<br>    DLinkedNode *tail;<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]现代C++语言核心特性解析 Chapter 3</title>
    <link href="/2024/10/09/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-3/"/>
    <url>/2024/10/09/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-3/</url>
    
    <content type="html"><![CDATA[<h1 id="auto占位符（C-11～C-17）"><a href="#auto占位符（C-11～C-17）" class="headerlink" title="auto占位符（C++11～C++17）"></a>auto占位符（C++11～C++17）</h1><h2 id="1-重新定义的auto关键字"><a href="#1-重新定义的auto关键字" class="headerlink" title="1 重新定义的auto关键字"></a>1 重新定义的auto关键字</h2><p>C++11标准赋予了auto新的含义：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> i = <span class="hljs-number">5</span>;                      <span class="hljs-comment">// 推断为int</span><br><span class="hljs-keyword">auto</span> str = <span class="hljs-string">&quot;hello auto&quot;</span>;         <span class="hljs-comment">// 推断为const char*</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2)</span>-&gt;<span class="hljs-type">int</span>    <span class="hljs-comment">// 返回类型后置，auto为返回值占位符</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a1+a2;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用auto的时候有4点需要注意：</p><ol><li><p>当用一个auto关键字声明多个变量的时候，编译器遵从由左往右的推导规则，以最左边的表达式推断auto的具体类型</p></li><li><p>当使用条件表达式初始化auto声明的变量时，编译器总是使用表达能力更强的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> i = <span class="hljs-literal">true</span> ? <span class="hljs-number">5</span> : <span class="hljs-number">8.0</span>;    <span class="hljs-comment">// i的数据类型为double</span><br></code></pre></td></tr></table></figure></li><li><p>auto无法声明非静态成员变量。</p><ul><li><p>在c++11中静态成员变量可以使用auto声明并初始化，但必须是const的。</p></li><li><p>在c++17中去掉了必须是const的限定，但仍然只支持静态成员变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sometype</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> i = <span class="hljs-number">5</span>;    <span class="hljs-comment">// C++17</span><br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>按照C++20之前的标准，无法在函数形参列表中使用auto声明形参（注意，<strong>在C++14中，auto可以为lambda表达式声明形参</strong>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-keyword">auto</span> str)</span> </span>&#123;…&#125; <span class="hljs-comment">// C++20之前编译失败，C++20编译成功</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-推导规则"><a href="#2-推导规则" class="headerlink" title="2 推导规则"></a>2 推导规则</h2><ol><li>如果auto声明的变量是按值初始化（没有使用引用和指针），则推导出的类型会忽略cv限定符。</li><li>使用auto声明变量初始化时，目标对象如果是引用，则引用属性会被忽略</li><li>使用auto和万能引用声明变量时（见第6章），对于左值会将auto推导为引用类型</li><li>使用auto声明变量，如果目标对象是一个数组或者函数，则auto会被推导为对应的指针类型</li><li>当auto关键字与列表初始化组合时，这里的规则有新老两个版本，这里只介绍新规则（C++17标准）。<ul><li>直接使用列表初始化，列表中必须为单元素，否则无法编译，auto类型被推导为单元素的类型。</li><li>用等号加列表初始化，列表中可以包含单个或者多个元素，auto类型被推导为 <code>std::initializer_list&lt;T&gt;</code> ，其中T是元素类型。请注意，在列表中包含多个元素的时候，元素的类型必须相同，否则编译器会报错。</li></ul></li></ol><p><strong>例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Base::f()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived::f()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Base *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br>    <span class="hljs-keyword">auto</span> b1 = *b;<br>    <span class="hljs-keyword">auto</span> &amp;b2 = *b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;b &quot;</span>;  b-&gt;<span class="hljs-built_in">f</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;b1 &quot;</span>; b<span class="hljs-number">1.f</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;b2 &quot;</span>; b<span class="hljs-number">2.f</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果</strong></p><p><img src="/../images/C-%E7%8E%B0%E4%BB%A3C-%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E8%A7%A3%E6%9E%90-Chapter-3/image-20241020170535616.png"></p><h2 id="3-什么时候使用auto"><a href="#3-什么时候使用auto" class="headerlink" title="3 什么时候使用auto"></a>3 什么时候使用auto</h2><ol><li><p>当一眼就能看出声明变量的初始化类型的时候可以使用auto。</p><p>比如迭代器等。</p></li><li><p>对于复杂的类型，例如lambda表达式、bind等直接使用auto。</p></li></ol><h2 id="4-返回类型推导"><a href="#4-返回类型推导" class="headerlink" title="4 返回类型推导"></a>4 返回类型推导</h2><p>C++14标准支持对返回类型声明为auto的推导。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2)</span> </span>&#123; <span class="hljs-keyword">return</span> a1 + a2; &#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，如果函数中有多个返回语句，需要保证每个返回语句返回的类型是一致的。</p><h2 id="5-lambda表达式中使用auto类型推导"><a href="#5-lambda表达式中使用auto类型推导" class="headerlink" title="5 lambda表达式中使用auto类型推导"></a>5 lambda表达式中使用auto类型推导</h2><p>在C++14标准中我们还可以把auto写到lambda表达式的形参中，这样就得到了一个泛型的lambda表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> l = [](<span class="hljs-keyword">auto</span> a1, <span class="hljs-keyword">auto</span> a2) &#123; <span class="hljs-keyword">return</span> a1 + a2; &#125;;<br><span class="hljs-keyword">auto</span> retval = <span class="hljs-built_in">l</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5.0</span>);<br></code></pre></td></tr></table></figure><p>ambda表达式返回auto引用的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> l = [](<span class="hljs-type">int</span> &amp;i)-&gt;<span class="hljs-keyword">auto</span>&amp; &#123; <span class="hljs-keyword">return</span> i; &#125;;<br><span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> &amp;x2 = <span class="hljs-built_in">l</span>(x1);<br><span class="hljs-built_in">assert</span>(&amp;x1 == &amp;x2);    <span class="hljs-comment">// 有相同的内存地址</span><br></code></pre></td></tr></table></figure><h2 id="6-非类型模板形参占位符"><a href="#6-非类型模板形参占位符" class="headerlink" title="6 非类型模板形参占位符"></a>6 非类型模板形参占位符</h2><p>C++17标准对auto关键字又一次进行了扩展，使它可以作为非类型模板形参的占位符。当然，我们必须保证推导出来的类型是可以用作模板形参的，否则无法通过编译.</p><div class="note note-warning">            <p>C++中模板参数不能为double类型。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]2343.裁剪数字后查询第k小的数字</title>
    <link href="/2024/10/08/LC-2343-%E8%A3%81%E5%89%AA%E6%95%B0%E5%AD%97%E5%90%8E%E6%9F%A5%E8%AF%A2%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2024/10/08/LC-2343-%E8%A3%81%E5%89%AA%E6%95%B0%E5%AD%97%E5%90%8E%E6%9F%A5%E8%AF%A2%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个下标从 <strong>0</strong> 开始的字符串数组 <code>nums</code> ，其中每个字符串 <strong>长度相等</strong> 且只包含数字。</p><p>再给你一个下标从 <strong>0</strong> 开始的二维整数数组 <code>queries</code> ，其中 <code>queries[i] = [ki, trimi]</code> 。对于每个 <code>queries[i]</code> ，你需要：</p><ul><li>将 <code>nums</code> 中每个数字 <strong>裁剪</strong> 到剩下 <strong>最右边</strong> <code>trimi</code> 个数位。</li><li>在裁剪过后的数字中，找到 <code>nums</code> 中第 <code>ki</code> 小数字对应的 <strong>下标</strong> 。如果两个裁剪后数字一样大，那么下标 <strong>更小</strong> 的数字视为更小的数字。</li><li>将 <code>nums</code> 中每个数字恢复到原本字符串。</li></ul><p>请你返回一个长度与 <code>queries</code> 相等的数组 <code>answer</code>，其中 <code>answer[i]</code>是第 <code>i</code> 次查询的结果。</p><p><strong>提示：</strong></p><ul><li>裁剪到剩下最右边 <code>x</code> 个数位的意思是不断删除最左边的数位，直到剩下 <code>x</code> 个数位。</li><li><code>nums</code> 中的字符串可能会有前导 0 。</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><p>依次处理每个query，处理每个query的时候用大顶堆的方式找到第k小的数字。</p><p><strong>重点</strong></p><p>在自定义比较操作的时候，不要使用 <code>substr</code>，<code>substr</code> 会进行拷贝操作，开销较高，应该使用 <code>std::string::compare</code> 对子串进行比较。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">smallestTrimmedNumbers</span><span class="hljs-params">(vector&lt;string&gt;&amp; nums, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp; query : queries)<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">solveQuery</span>(nums, query[<span class="hljs-number">1</span>], query[<span class="hljs-number">0</span>]));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solveQuery</span><span class="hljs-params">(vector&lt;string&gt;&amp; nums, <span class="hljs-type">int</span> trim, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> n = nums[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">auto</span> cmp = [trim, n, &amp;nums](<span class="hljs-type">const</span> <span class="hljs-type">int</span> lhs, <span class="hljs-type">const</span> <span class="hljs-type">int</span> rhs)<br>        &#123;<br>            <span class="hljs-type">int</span> res = nums[lhs].<span class="hljs-built_in">compare</span>(n - trim, trim, nums[rhs], n - trim);<br>            <span class="hljs-keyword">return</span> res &lt; <span class="hljs-number">0</span> || (res == <span class="hljs-number">0</span> &amp;&amp; lhs &lt; rhs);<br>        &#125;;<br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &lt; k) <br>            &#123;<br>                pq.<span class="hljs-built_in">push</span>(i);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cmp</span>(i, pq.<span class="hljs-built_in">top</span>()))<br>            &#123;<br>                pq.<span class="hljs-built_in">pop</span>();<br>                pq.<span class="hljs-built_in">push</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pq.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>假设总共有$m$个query，数字数组大小为$n$，字符串的长度为$s$.</p><p>一个query的时间复杂度为$O(ntrim_ilogk_i).$</p><p>所以总的时间复杂度为$O(n\Sigma_{i&#x3D;1}^mtrim_ilogk_i)$</p><p><strong>空间复杂度</strong>：$O(k).$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]912.排序数组</title>
    <link href="/2024/10/07/LC-912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2024/10/07/LC-912-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p>你必须在 <strong>不使用任何内置函数</strong> 的情况下解决问题，时间复杂度为 <code>O(nlog(n))</code>，并且空间复杂度尽可能小。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">buildHeap</span>(nums);<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[n - <span class="hljs-number">1</span> - i]);<br>            <span class="hljs-built_in">heapAdjust</span>(nums, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span> - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapAdjust</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-built_in">left</span>(k);<br>        <span class="hljs-keyword">while</span> (i &lt; n)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; nums[i] &lt; nums[i<span class="hljs-number">+1</span>])++i;<br>            <span class="hljs-keyword">if</span> (nums[k] &gt;= nums[i]) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-built_in">swap</span>(nums[k], nums[i]);<br>            k = i;<br>            i = <span class="hljs-built_in">left</span>(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>        &#123;<br>            <span class="hljs-built_in">heapAdjust</span>(nums, i, nums.<span class="hljs-built_in">size</span>());<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(nlogn).$</p><p><strong>空间复杂度：</strong>$O(1).$</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">quickSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> pivot_idx = <span class="hljs-built_in">partition</span>(nums, low, high);<br>        <span class="hljs-built_in">quickSort</span>(nums, low, pivot_idx - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">quickSort</span>(nums, pivot_idx + <span class="hljs-number">1</span>, high);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">swap</span>(nums[low], nums[low + <span class="hljs-built_in">rand</span>() % (high - low + <span class="hljs-number">1</span>)]);<br>        <span class="hljs-type">int</span> pivot = nums[low];<br>        <span class="hljs-type">int</span> l = low + <span class="hljs-number">1</span>, r = high;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[l] &lt; pivot) ++l;<br>            <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[r] &gt; pivot) --r;<br>            <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-built_in">swap</span>(nums[l], nums[r]);<br>            ++l; --r;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[low], nums[r]);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$平均O(nlogn),最坏O(n^2).$</p><p><strong>空间复杂度：</strong>$平均O(logn)，最坏O(n).$</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-built_in">mergeSort</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (low &gt;= high) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> m = low + ((high - low) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">mergeSort</span>(nums, low, m);<br>        <span class="hljs-built_in">mergeSort</span>(nums, m<span class="hljs-number">+1</span>, high);<br>        <span class="hljs-built_in">merge</span>(nums, low, m, high);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(nums.begin() + low, nums.begin() + mid + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-type">int</span> i, j, k;<br>        <span class="hljs-keyword">for</span> (k = low, i = <span class="hljs-number">0</span>, j = mid + <span class="hljs-number">1</span>; i &lt; buffer.<span class="hljs-built_in">size</span>() &amp;&amp; j &lt;= high; ++k)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (buffer[i] &lt;= nums[j]) nums[k] = buffer[i++];<br>            <span class="hljs-keyword">else</span> nums[k] = nums[j++];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &lt; buffer.<span class="hljs-built_in">size</span>()) nums[k++] = buffer[i++];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(nlogn).$</p><p><strong>空间复杂度：</strong>$O(n).$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]215.数组中的第k个最大元素</title>
    <link href="/2024/10/06/LC-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/"/>
    <url>/2024/10/06/LC-215-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h4><p>经典算法，寻找第k个元素。可以借用快速排序的划分操作，每次划分操作将一个枢轴元素放置到它排好序后的正确位置上，且所有小于等于枢轴元素的元素都在该位置之前，所有大于等于枢轴元素的元素都在该位置之后。如果这个位置等于k，则我们直接返回该位置上的值即可；如果这个位置大于k，说明我们要找到的元素一定在枢轴元素之前，递归的求解一个更小的子问题即可；如果这个位置小于k，同理。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findKthElement</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">size</span>() - k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> pivot_idx = <span class="hljs-built_in">partition</span>(nums, low, high);<br>        <span class="hljs-keyword">if</span> (pivot_idx == k) <span class="hljs-keyword">return</span> nums[k];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pivot_idx &gt; k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findKthElement</span>(nums, low, pivot_idx - <span class="hljs-number">1</span>, k);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">findKthElement</span>(nums, pivot_idx + <span class="hljs-number">1</span>, high, k);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> pivot = nums[low];<br>        <span class="hljs-type">int</span> l = low + <span class="hljs-number">1</span>, r = high;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[l] &lt; pivot) ++l;<br>            <span class="hljs-keyword">while</span> (l &lt;= r &amp;&amp; nums[r] &gt; pivot) --r;<br>            <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-built_in">swap</span>(nums[l], nums[r]);<br>            ++l; --r;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(nums[low], nums[r]);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注意代码中的partition算法，该算法将区间$[low,high]$划分为两个区间，一个区间是$[low + 1, l)$，此区间满足任意元素都严格小于pivot，另一个区间是$(r, high]$，此区间满足任意元素都严格大于pivot。当跳出循环的时候，有两种可能：</p><ol><li>$l &#x3D; r$，此时$nums[l] &gt;&#x3D; pivot$且$nums[l] &lt;&#x3D; pivot$。即$nums[l] &#x3D; nums[r] &#x3D; pivot$.</li><li>$l &#x3D; r + 1$, 此时$r &lt; l$，因此$nums[r] &lt; pivot, nums[l] &gt; pivot$.因此$r$是枢轴位置。</li></ol><p> 注意条件中的$l &lt;&#x3D; r$的等号不能省略，这是为了确保当$l &#x3D;&#x3D; r$的时候，仍然会对该位置的元素进行检测，使之满足区间约束条件。反之，如果我们省略等号，那么当$l &#x3D;&#x3D; r$的时候，有可能因为$l &lt;r$这个条件不成立导致循环提前终止，而没有对当前位置的元素进行检测，其有可能不符合区间的约束条件。</p><h4 id="大顶堆"><a href="#大顶堆" class="headerlink" title="大顶堆"></a>大顶堆</h4><p>我们将元素维护在一个大顶堆中，然后依次取出的第k个元素即为我们所求。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">buildHeap</span>(nums, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i)<br>        &#123;<br>            <span class="hljs-built_in">swap</span>(nums[<span class="hljs-number">0</span>], nums[n - i]);<br>            <span class="hljs-built_in">heapAdjust</span>(nums, <span class="hljs-number">0</span>, n - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[n - k];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>        &#123;<br>            <span class="hljs-built_in">heapAdjust</span>(nums, i, n);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heapAdjust</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-built_in">left</span>(k);<br>        <span class="hljs-keyword">while</span> (i &lt; n)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; nums[i + <span class="hljs-number">1</span>] &gt; nums[i])++i;<br>            <span class="hljs-keyword">if</span> (nums[k] &gt;= nums[i]) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-built_in">swap</span>(nums[k], nums[i]);<br>            k = i;<br>            i = <span class="hljs-built_in">left</span>(k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">left</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>; &#125;<br>&#125;;<br><br><span class="hljs-comment">// c++标准库算法实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">make_heap</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>        &#123;<br>            <span class="hljs-built_in">pop_heap</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>() - i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[n - k];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>建堆的时间复杂度是$O(n)$，每一次删除一个元素的时间复杂度是$O(logn)$，因此总的时间复杂度是$O(n + klogn).$ </p><p><strong>空间复杂度</strong></p><p>$O(1).$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>分治算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]191.位1的个数</title>
    <link href="/2024/10/06/LC-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2024/10/06/LC-191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="逐位数"><a href="#逐位数" class="headerlink" title="逐位数"></a>逐位数</h4><p>这题比较简单，直接看代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> hmw = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-built_in">sizeof</span>(n) * <span class="hljs-number">8</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>; ++i, n &gt;&gt;= <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) hmw += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> hmw;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(logn).$</p><p><strong>空间复杂度：</strong>$O(1).$</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>有两种优化方式</p><ol><li><p>$n &amp; (n - 1)$. 通过这个式子，可以将$n$的最低的1置0.</p><p>证明: 对于任意$n &#x3D; a_la_{l-1}…a_k100…00,n-1&#x3D;a_la_{l-1}…a_k000…00$，</p><p>则$n&amp;(n-1) &#x3D; a_la_{l-1}…a{k}000…00$.即最低的1置0.</p></li><li><p>$n&amp;(-n)$.通过这个式子，可以取得$n$的最低的1的值.</p><p>证明：对于任意$n&#x3D;a_la_{l-1}…a_k100…00,$</p><p>$-n &#x3D; \overline{a_la_{l-1}…a_k}011…11 + 1 $</p><p>​       $&#x3D; \overline{a_la_{l-1}…a_k}100…00$</p><p>所以$n&amp;(-n)$等于$n$的最低的1的值.</p></li></ol><p>通过上面两个式子，我们可以对算法进行优化，使得我们算法循环的次数严格的等于$n$中1的个数。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 优化方式1</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> hmw = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            ++hmw;<br>            n = (n &amp; (n - <span class="hljs-number">1</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> hmw;<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 优化方式2</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">size_t</span> hmw = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            ++hmw;<br>            n -= (n &amp; (-n));<br>        &#125;<br>        <span class="hljs-keyword">return</span> hmw;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(logn).$</p><p><strong>空间复杂度：</strong>$O(1).$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]190.颠倒二进制位</title>
    <link href="/2024/10/06/LC-190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/"/>
    <url>/2024/10/06/LC-190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>颠倒给定的 32 位无符号整数的二进制位。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="按位颠倒"><a href="#按位颠倒" class="headerlink" title="按位颠倒"></a>按位颠倒</h4><p>我们从低到高依次取给定数的每一个二进制位$i$，将其放置在$31 - i$的位置上即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">uint32_t</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span> &amp;&amp; n &gt; <span class="hljs-number">0</span>; ++i, n &gt;&gt;= <span class="hljs-number">1</span>)<br>        &#123;<br>            ans = ans | ((n &amp; <span class="hljs-number">1</span>) &lt;&lt; (<span class="hljs-number">31</span> - i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：</p><p>因为每次$n$都减小为原来的一半，所以时间复杂度为$O(logn).$</p><p><strong>空间复杂度：</strong></p><p>$O(1).$</p><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>分治只需要分别将左半和右半颠倒，然后左半和右半在整体颠倒即可。采用自底向上的方式，首先两两一组，交换相邻的两位，然后四个四个一组，交换相邻的左半和右半，依次类推。</p><p>编码的时候，我们采用掩码的技巧进行编码，方便我们进行颠倒操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> M1 = <span class="hljs-number">0x55555555</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> M2 = <span class="hljs-number">0x33333333</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> M3 = <span class="hljs-number">0x0f0f0f0f</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> M4 = <span class="hljs-number">0x00ff00ff</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        n = (n &gt;&gt; <span class="hljs-number">1</span>) &amp; M1 | (n &amp; M1) &lt;&lt; <span class="hljs-number">1</span>;<br>        n = (n &gt;&gt; <span class="hljs-number">2</span>) &amp; M2 | (n &amp; M2) &lt;&lt; <span class="hljs-number">2</span>;<br>        n = (n &gt;&gt; <span class="hljs-number">4</span>) &amp; M3 | (n &amp; M3) &lt;&lt; <span class="hljs-number">4</span>;<br>        n = (n &gt;&gt; <span class="hljs-number">8</span>) &amp; M4 | (n &amp; M4) &lt;&lt; <span class="hljs-number">8</span>;<br>        <span class="hljs-keyword">return</span> (n &gt;&gt; <span class="hljs-number">16</span>) | (n &lt;&lt; <span class="hljs-number">16</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong>$O(1).$</p><p><strong>空间复杂度：</strong>$O(1)$.</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>分治算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]109.有序链表转换二叉搜索树</title>
    <link href="/2024/10/06/LC-109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2024/10/06/LC-109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个单链表的头节点  <code>head</code> ，其中的元素 <strong>按升序排序</strong> ，将其转换为平衡二叉搜索树。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>我们将链表中间偏左的结点$m*$作为根节点构建BST，由此将原问题规约为两个规模更小的子问题，分别递归求解，得到左子树和右子树，将其和根结点组合后返回即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">findMid</span><span class="hljs-params">(ListNode *head, ListNode *end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        ListNode *slow = head, *fast = head;<br>        <span class="hljs-keyword">while</span> (fast-&gt;next != end &amp;&amp; fast-&gt;next-&gt;next != end)<br>        &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <span class="hljs-function">TreeNode *<span class="hljs-title">buildBST</span><span class="hljs-params">(ListNode *head, ListNode *end)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == end) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">auto</span> mid = <span class="hljs-built_in">findMid</span>(head, end);<br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(mid-&gt;val);<br>        root-&gt;left = <span class="hljs-built_in">buildBST</span>(head, mid);<br>        root-&gt;right = <span class="hljs-built_in">buildBST</span>(mid-&gt;next, end);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildBST</span>(head, <span class="hljs-literal">nullptr</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>每次递归的时候，为了找到中间的结点，我们需要$O(n)$的时间。</p><p>由此得到递推方程$W(n) &#x3D; 2W(n&#x2F;2) + O(n).$</p><p>由主定理，解得$W(n) &#x3D; \Theta(nlogn).$</p><p><strong>空间复杂度</strong></p><p>空间复杂度为递归深度$O(logn).$</p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>可以看到，由于链表不具有随机访问的能力，我们为了找到中间结点，需要花费$O(n)$的时间。</p><p>为了减少这个时间，一种可能的方法是以空间换时间，将链表中的元素存储进数组中，这样就可以在$O(1)$的时间内访问到中间结点了，但是这样会导致空间复杂度变为$O(n)$.</p><p>那有什么办法可以既保证空间复杂度不改变，又能够降低时间复杂度呢？</p><p>观察建树的过程，我们先初始化根结点，然后去递归的建立左子树和右子树，但建立左子树的过程中，根结点的唯一作用就是作为边界，实际只会用到根节点左边的结点。因此，我们可以用下标来代替根节点，先建立左子树，然后建立根结点，之后再建立右子树。这个过程很类似中序遍历的过程，因此我们可以再每次递归的时候，将头结点后移，这样在递归处理完左子树之后，头结点的位置刚好指向我们需要的中间结点的位置，从而无需花费$O(n)$的时间复杂度去定位中间节点。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(ListNode *head)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (head) <br>        &#123;<br>            ++length;<br>            head = head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br>    <span class="hljs-comment">// [l, r]</span><br>    <span class="hljs-function">TreeNode *<span class="hljs-title">buildBST</span><span class="hljs-params">(ListNode *&amp;head, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>();<br>        <span class="hljs-type">int</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        root-&gt;left = <span class="hljs-built_in">buildBST</span>(head, l, m - <span class="hljs-number">1</span>);<br>        root-&gt;val = head-&gt;val;<br>        head = head-&gt;next;<br>        root-&gt;right = <span class="hljs-built_in">buildBST</span>(head, m + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">sortedListToBST</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length = <span class="hljs-built_in">getLength</span>(head);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildBST</span>(head, <span class="hljs-number">0</span>, length - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>递推方程$W(n) &#x3D; 2W(n&#x2F;2) + O(1).$</p><p>由主定理，$W(n) &#x3D; \Theta(n).$</p><p><strong>空间复杂度</strong> </p><p>空间复杂度等于递归深度$O(logn).$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>分治算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]105.从前序与中序遍历序列构造二叉树</title>
    <link href="/2024/10/06/LC-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2024/10/06/LC-105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先序序列的第一个元素是树的根，在中序序列中定位到这个元素，该元素的左边都是左子树中的结点，右边都是右子树中的结点，据此，可以将问题规约为两个更小的子问题，递归求解。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span><br><span class="hljs-comment"> * right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTreeHelper</span>(preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>,<br>                               inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTreeHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">size_t</span> l1, <span class="hljs-type">size_t</span> r1,</span></span><br><span class="hljs-params"><span class="hljs-function">                              vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">size_t</span> l2, <span class="hljs-type">size_t</span> r2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 &gt; r1 || l2 &gt; r2) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (l1 == r1)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[l1]);<br>        <span class="hljs-keyword">auto</span> root_iter = <span class="hljs-built_in">find</span>(inorder.<span class="hljs-built_in">cbegin</span>(), inorder.<span class="hljs-built_in">cend</span>(), preorder[l1]);<br>        <span class="hljs-type">size_t</span> root_pos = root_iter - inorder.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-type">size_t</span> left_size = root_pos - l2, right_size = r2 - root_pos;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[l1]);<br>        root-&gt;left = <span class="hljs-built_in">buildTreeHelper</span>(preorder, l1 + <span class="hljs-number">1</span>, l1 + left_size, inorder,<br>                                     l2, root_pos - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">buildTreeHelper</span>(preorder, l1 + left_size + <span class="hljs-number">1</span>, r1, inorder,<br>                                      root_pos + <span class="hljs-number">1</span>, r2);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>可以得到平均时间复杂度的递推方程$A(n) &#x3D; \frac{2}{n} \Sigma_{i&#x3D;1}^{n-1}A(i) + O(n).$</p><p>解得$A(n) &#x3D; \Theta(nlogn).$</p><p><strong>优化</strong>：</p><p>如果我们在处理之前，先将indorder数组的值和其下表建立一个哈希映射，那么我们每次递归的时候平均只需要$O(1)$的时间就可以在inorder中找到树的根。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != inorder.<span class="hljs-built_in">size</span>(); ++i)<br>            val_to_posi_[inorder[i]] = i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">buildTreeHelper</span>(preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>,<br>                               inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTreeHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, <span class="hljs-type">size_t</span> l1, <span class="hljs-type">size_t</span> r1,</span></span><br><span class="hljs-params"><span class="hljs-function">                              vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder, <span class="hljs-type">size_t</span> l2, <span class="hljs-type">size_t</span> r2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l1 &gt; r1 || l2 &gt; r2) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (l1 == r1)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[l1]);<br>        <span class="hljs-type">size_t</span> root_pos = val_to_posi_[preorder[l1]];<br>        <span class="hljs-type">size_t</span> left_size = root_pos - l2, right_size = r2 - root_pos;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[l1]);<br>        root-&gt;left = <span class="hljs-built_in">buildTreeHelper</span>(preorder, l1 + <span class="hljs-number">1</span>, l1 + left_size, inorder,<br>                                     l2, root_pos - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">buildTreeHelper</span>(preorder, l1 + left_size + <span class="hljs-number">1</span>, r1, inorder,<br>                                      root_pos + <span class="hljs-number">1</span>, r2);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>&gt; val_to_posi_;<br>&#125;;<br></code></pre></td></tr></table></figure><p>时间复杂度：</p><p>优化后的递推方程为$A(n) &#x3D; \frac{2}{n} \Sigma_{i&#x3D;1}^{n-1}A(i) + O(1).$</p><p>解得$A(n) &#x3D; \Theta(n).$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>分治算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]53.最大子数组和</title>
    <link href="/2024/10/06/LC-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/"/>
    <url>/2024/10/06/LC-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>子数组是数组中的一个连续部分。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p>用 <code>max</code> 维护最大子数组和，<code>cur_b</code> 维护当前子数组的起始位置，<code>cur</code> 维护当前子数组的和，<code>i</code> 维护当前遍历的位置，每遍历到一个位置，我们将当前位置的值加到 <code>cur</code> 上，然后判断 <code>cur</code> 是否小于 <code>max</code> ，如果大于 <code>max</code> ，则更新 <code>max</code> ，之后再判断 <code>cur</code> 是否小于 <code>0</code> ，如果 <code>cur</code> 已经小于 <code>0</code> 了，则更新 <code>cur_b</code> 为 <code>i+1</code> ，然后继续遍历。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> max = numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">min</span>(), cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">size_t</span> cur_b = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != nums.<span class="hljs-built_in">size</span>(); ++i)<br>        &#123;<br>            cur += nums[i];<br>            <span class="hljs-keyword">if</span> (cur &gt; max) max = cur;<br>            <span class="hljs-keyword">if</span> (cur &lt; <span class="hljs-number">0</span>) <br>            &#123;<br>                cur_b = i + <span class="hljs-number">1</span>;<br>                cur = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：$O(n)$.</p><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>参考leetcode官方题解<a href="https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/?envType=problem-list-v2&envId=divide-and-conquer">53. 最大子数组和 - 力扣（LeetCode）</a>。</p><p>首先约定对于区间$[l,r]$，$[l, m]$为它的左子区间，$[m + 1, r]$为它的右子区间，其中$m &#x3D; (l + r) &#x2F; 2$.</p><p>为了求得区间$[l,r]$的最大子数组和，我们可以递归的去求它的左右子区间的最大子数组和，然后想办法获得当前区间的最大子数组和，当前区间的最大子数组和有三种情况：</p><ol><li>区间$[l,r]$的最大子数组和等于其左子区间的最大子数组和。</li><li>区间$[l,r]$的最大子数组和等于其右子区间的最大子数组和。</li><li>区间$[l,r]$的最大子数组和为某个跨越左右子区间的子数组的和。</li></ol><p>为了处理情况3，对于每个区间，我们需要维护两个变量$lsum$和$rsum$，其中$lsum$维护了当前区间以$l$为起点的最大子数组和，$rsum$维护了当前区间以$r$为终点的最大子数组和。</p><p>有了这两个变量，我们就可以很方便的处理情况3了。即当前区间的最大子数组和应该是其左区间的最大子数组和，右区间的最大子数组和，以及左区间的$rsum$加右区间的$lsum$，这三者取大。</p><p> 那我们应该如何维护这两个变量呢？不难发现，区间$[l,r]$的$lsum$应该是其左区间的$lsum$和左区间的和加右区间的$lsum$，这两者取大；同理$rsum$应该是右区间的$rsum$和右区间的和加左区间的$rsum$，这两者取大。为了方便，我们额外维护一个变量$isum$用来记录区间和。同时，我们用变量$msum$来维护当前区间的最大子数组和。<br>$$<br>\begin{align}<br>    &amp; msum &#x3D; max(l.msum, r.msum, l.rsum + r.lsum) \\<br>    &amp; isum &#x3D; l.isum + r.isum \\<br>    &amp; lsum &#x3D; max(l.lsum, l.isum + r.lsum) \\<br>    &amp; rsum &#x3D; max(r.rsum, r.isum + l.rsum)<br>\end{align}<br>$$<br><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Status</span><br>    &#123;<br>        <span class="hljs-type">int</span> lsum, rsum;<br>        <span class="hljs-type">int</span> isum, msum;<br>    &#125;;<br>    <span class="hljs-function">Status <span class="hljs-title">maxSubArrayHelper</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">size_t</span> l, <span class="hljs-type">size_t</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> &#123;nums[l], nums[l], nums[l], nums[l]&#125;;<br>        <span class="hljs-type">size_t</span> m = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">auto</span> lstatus = <span class="hljs-built_in">maxSubArrayHelper</span>(nums, l, m);<br>        <span class="hljs-keyword">auto</span> rstatus = <span class="hljs-built_in">maxSubArrayHelper</span>(nums, m + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-type">int</span> isum = lstatus.isum + rstatus.isum;<br>        <span class="hljs-type">int</span> lsum = <span class="hljs-built_in">max</span>(lstatus.lsum, lstatus.isum + rstatus.lsum);<br>        <span class="hljs-type">int</span> rsum = <span class="hljs-built_in">max</span>(rstatus.rsum, rstatus.isum + lstatus.rsum);<br>        <span class="hljs-type">int</span> msum = <span class="hljs-built_in">max</span>(lstatus.rsum + rstatus.lsum, <br>                       <span class="hljs-built_in">max</span>(lstatus.msum, rstatus.msum));<br>        <span class="hljs-keyword">return</span> &#123;lsum, rsum, isum, msum&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> status = <span class="hljs-built_in">maxSubArrayHelper</span>(nums, <span class="hljs-number">0</span>, nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> status.msum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong>：</p><p>递推方程：$W(n) &#x3D; 2W(n&#x2F;2) + O(1)$</p><p>由主定理，解得$W(n) &#x3D; \Theta(n)$.</p><p><strong>空间复杂度</strong>：</p><p>因为采用了递归，所以空间复杂度为递归深度$O(logn)$.</p><blockquote><p>「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？</p><p>对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间 [0,n−1]，还可以用于解决任意的子区间 [l,r] 的问题。如果我们把 [0,n−1] 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一棵真正的树之后，我们就可以在 O(logn) 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(logn) 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——线段树。</p><p>作者：力扣官方题解<br>链接：<a href="https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/">https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/</a><br>来源：力扣（LeetCode）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]类型极端值</title>
    <link href="/2024/10/06/C-%E7%B1%BB%E5%9E%8B%E6%9E%81%E7%AB%AF%E5%80%BC/"/>
    <url>/2024/10/06/C-%E7%B1%BB%E5%9E%8B%E6%9E%81%E7%AB%AF%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>在 C++ 中，不同类型有各自的极端值，包括最小值、最大值和表示特殊情况的值（如无穷大、未定义值等）。这些极端值在算法和编程中经常被使用，比如设置边界条件、初始化变量等。下面将介绍各个基本类型的极端值及其使用方法。</p><h3 id="1-整型类型"><a href="#1-整型类型" class="headerlink" title="1. 整型类型"></a>1. <strong>整型类型</strong></h3><h4 id="常见的整型类型"><a href="#常见的整型类型" class="headerlink" title="常见的整型类型"></a>常见的整型类型</h4><ul><li><code>int</code>：标准整型</li><li><code>long</code>：较大的整型</li><li><code>long long</code>：更大的整型</li><li><code>unsigned int</code>：无符号整型，不能表示负数</li><li><code>char</code>：字符类型，本质上是一个 1 字节的整数</li></ul><h4 id="获取整型极端值"><a href="#获取整型极端值" class="headerlink" title="获取整型极端值"></a>获取整型极端值</h4><p>在 C++ 中，可以通过 <code>limits</code> 头文件中的 <code>std::numeric_limits</code> 类来获取整型（以及其他类型）的极端值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span>  <span class="hljs-comment">// 头文件</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int 的最小值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">min</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int 的最大值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">max</span>() &lt;&lt; std::endl;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;unsigned int 的最大值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">max</span>() &lt;&lt; std::endl;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;long long 的最小值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;::<span class="hljs-built_in">min</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;long long 的最大值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;::<span class="hljs-built_in">max</span>() &lt;&lt; std::endl;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;char 的最小值: &quot;</span> &lt;&lt; +std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::<span class="hljs-built_in">min</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;char 的最大值: &quot;</span> &lt;&lt; +std::numeric_limits&lt;<span class="hljs-type">char</span>&gt;::<span class="hljs-built_in">max</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 使用 + 强制转换为 int 类型输出</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="整型类型的极端值总结"><a href="#整型类型的极端值总结" class="headerlink" title="整型类型的极端值总结"></a>整型类型的极端值总结</h4><ul><li><code>std::numeric_limits&lt;int&gt;::min()</code>：返回 <code>int</code> 类型的最小值（例如 <code>-2147483648</code>）。</li><li><code>std::numeric_limits&lt;int&gt;::max()</code>：返回 <code>int</code> 类型的最大值（例如 <code>2147483647</code>）。</li><li><code>std::numeric_limits&lt;unsigned int&gt;::max()</code>：返回无符号整型的最大值（例如 <code>4294967295</code>）。</li><li><code>std::numeric_limits&lt;long long&gt;::min()</code> 和 <code>max()</code>：对于 <code>long long</code> 类型，返回最小和最大值。</li><li><code>std::numeric_limits&lt;char&gt;::min()</code> 和 <code>max()</code>：返回 <code>char</code> 类型的最小值和最大值（-128 到 127）。</li></ul><p>这些极端值通常用于初始化边界值或限制输入值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> largest = std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">min</span>();  <span class="hljs-comment">// 初始化为最小值，保证接下来的数都比它大</span><br></code></pre></td></tr></table></figure><h3 id="2-浮点类型"><a href="#2-浮点类型" class="headerlink" title="2. 浮点类型"></a>2. <strong>浮点类型</strong></h3><h4 id="常见的浮点类型"><a href="#常见的浮点类型" class="headerlink" title="常见的浮点类型"></a>常见的浮点类型</h4><ul><li><code>float</code>：单精度浮点数</li><li><code>double</code>：双精度浮点数</li><li><code>long double</code>：扩展精度浮点数</li></ul><h4 id="获取浮点类型的极端值"><a href="#获取浮点类型的极端值" class="headerlink" title="获取浮点类型的极端值"></a>获取浮点类型的极端值</h4><p>浮点类型同样可以使用 <code>std::numeric_limits</code> 来获取其极端值，并且还可以获取特殊值如无穷大和非数值（NaN）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;float 的最小值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">min</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;float 的最大值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>() &lt;&lt; std::endl;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;double 的最小值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">double</span>&gt;::<span class="hljs-built_in">min</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;double 的最大值: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">double</span>&gt;::<span class="hljs-built_in">max</span>() &lt;&lt; std::endl;<br>    <br>    <span class="hljs-comment">// 特殊值</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;float 无穷大: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">infinity</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;float NaN（非数值）: &quot;</span> &lt;&lt; std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">quiet_NaN</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="浮点类型的极端值总结"><a href="#浮点类型的极端值总结" class="headerlink" title="浮点类型的极端值总结"></a>浮点类型的极端值总结</h4><ul><li><code>std::numeric_limits&lt;float&gt;::min()</code>：返回 <code>float</code> 类型的最小正数（注意是正数）。</li><li><code>std::numeric_limits&lt;float&gt;::max()</code>：返回 <code>float</code> 类型的最大值。</li><li><code>std::numeric_limits&lt;float&gt;::lowest()</code>：返回 <code>float</code> 类型的负数最小值。</li><li><code>std::numeric_limits&lt;float&gt;::infinity()</code>：返回正无穷大。</li><li><code>std::numeric_limits&lt;float&gt;::quiet_NaN()</code>：返回非数值（NaN）。</li></ul><p>浮点数的这些值通常用于数值算法中的边界检测，尤其是 <code>NaN</code> 和 <code>infinity</code>，它们可以用来检测非法操作或溢出情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (result == std::numeric_limits&lt;<span class="hljs-type">double</span>&gt;::<span class="hljs-built_in">infinity</span>()) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Overflow detected!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-布尔类型"><a href="#3-布尔类型" class="headerlink" title="3. 布尔类型"></a>3. <strong>布尔类型</strong></h3><p>布尔类型的极端值相对简单，它只有两个值：</p><ul><li><code>true</code></li><li><code>false</code></li></ul><h3 id="4-特殊的极端值"><a href="#4-特殊的极端值" class="headerlink" title="4. 特殊的极端值"></a>4. <strong>特殊的极端值</strong></h3><h4 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a><code>nullptr</code></h4><p>对于指针类型，<code>nullptr</code> 表示空指针，作为指针的极端值使用。在 C++11 之前，通常使用 <code>NULL</code>，但 <code>nullptr</code> 是更推荐的方式，因为它具有更好的类型安全性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* ptr = <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 初始化为空指针</span><br></code></pre></td></tr></table></figure><h4 id="size-t"><a href="#size-t" class="headerlink" title="size_t"></a><code>size_t</code></h4><p><code>size_t</code> 是一个无符号整数类型，常用于表示数组下标或大小。它的极端值可以通过 <code>std::numeric_limits&lt;size_t&gt;::max()</code> 获取。通常用来表示不存在的索引值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">size_t</span> invalidIndex = std::numeric_limits&lt;<span class="hljs-type">size_t</span>&gt;::<span class="hljs-built_in">max</span>();<br></code></pre></td></tr></table></figure><h3 id="5-如何使用极端值"><a href="#5-如何使用极端值" class="headerlink" title="5. 如何使用极端值"></a>5. <strong>如何使用极端值</strong></h3><p>极端值在很多情况下非常有用，比如：</p><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. <strong>初始化</strong></h4><p>初始化变量时，可以使用最小值和最大值作为起始条件。例如，寻找最大值时，将变量初始化为最小值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> maxValue = std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">min</span>();<br></code></pre></td></tr></table></figure><h4 id="2-边界检测"><a href="#2-边界检测" class="headerlink" title="2. 边界检测"></a>2. <strong>边界检测</strong></h4><p>通过判断值是否接近最大或最小值，可以检测出溢出、无效输入等异常情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (someValue &gt; std::numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>    <span class="hljs-comment">// 处理溢出</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-浮点数异常处理"><a href="#3-浮点数异常处理" class="headerlink" title="3. 浮点数异常处理"></a>3. <strong>浮点数异常处理</strong></h4><p>在浮点数运算中，检测 <code>NaN</code> 和无穷大是常见的需求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> result = <span class="hljs-built_in">someComputation</span>();<br><span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">isnan</span>(result)) &#123;<br>    <span class="hljs-comment">// 处理非数值情况</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>C++ 提供了标准的 <code>std::numeric_limits</code> 类来获取各种数据类型的极端值，包括整型、浮点型、布尔型、指针等。</li><li>这些极端值对于边界检查、初始化和异常处理非常有用，可以帮助编写更健壮的代码。</li><li>了解并善用这些极端值对于编写健壮的算法和处理极端情况非常重要。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]优先队列</title>
    <link href="/2024/10/05/C-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2024/10/05/C-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>C++ 中的 <strong>优先队列</strong>（<code>priority_queue</code>）是一个容器适配器，用来管理带优先级的队列，内部采用<strong>堆</strong>（通常是<strong>二叉堆</strong>）来维护元素的顺序。优先队列保证每次取出的元素是队列中优先级最高的元素。</p><span id="more"></span><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><p>优先队列是一种特殊的队列，元素之间有优先级关系。默认情况下，优先队列中的元素是<strong>大顶堆</strong>，即每次出队的元素是优先级最高（值最大）的元素。</p><h3 id="2-常用操作"><a href="#2-常用操作" class="headerlink" title="2. 常用操作"></a>2. <strong>常用操作</strong></h3><p>C++ 提供了标准库中的 <code>priority_queue</code> 类，常见的操作如下：</p><ul><li><strong><code>push()</code></strong>: 将元素插入队列。</li><li><strong><code>pop()</code></strong>: 移除队列中优先级最高的元素。</li><li><strong><code>top()</code></strong>: 返回队列中优先级最高的元素，但不移除。</li><li><strong><code>empty()</code></strong>: 判断队列是否为空。</li><li><strong><code>size()</code></strong>: 返回队列中元素的数量。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Top element: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 30</span><br>    pq.<span class="hljs-built_in">pop</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Top element after pop: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 20</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-自定义比较函数"><a href="#3-自定义比较函数" class="headerlink" title="3. 自定义比较函数"></a>3. <strong>自定义比较函数</strong></h3><p>默认情况下，<code>priority_queue</code> 是一个<strong>大顶堆</strong>，即最大的元素优先出队。如果需要自定义优先级（例如实现<strong>小顶堆</strong>或自定义比较逻辑），可以通过传递比较函数或者仿函数来实现。</p><ul><li><strong>小顶堆实现</strong>（使用内置比较器 <code>std::greater&lt;T&gt;</code>）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;<span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;, std::greater&lt;<span class="hljs-type">int</span>&gt;&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">10</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">30</span>);<br>    pq.<span class="hljs-built_in">push</span>(<span class="hljs-number">20</span>);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Top element: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 10</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>自定义结构体的比较</strong>：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    std::string name;<br>    <br>    <span class="hljs-comment">// 自定义比较函数</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Task&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> priority &lt; other.priority;  <span class="hljs-comment">// 优先级低的任务放在前面</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::priority_queue&lt;Task&gt; pq;<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Task1&quot;</span>&#125;);<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Task3&quot;</span>&#125;);<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Task2&quot;</span>&#125;);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Top task: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().name &lt;&lt; std::endl;  <span class="hljs-comment">// 输出 Task3</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>仿函数</strong></li></ul><p>在 C++ 中，除了可以使用内置的比较函数（如 <code>std::greater&lt;T&gt;</code>），还可以通过自定义的<strong>仿函数</strong>来实现优先队列的自定义比较逻辑。</p><p><strong>什么是仿函数？</strong></p><p><strong>仿函数</strong>（Functor）是指像函数一样使用的对象。它是通过在类中重载 <code>operator()</code> 运算符实现的。当一个对象实现了这个运算符，它就可以像函数一样被调用。仿函数的优势在于它可以保存状态，并且可以在优先队列等数据结构中提供灵活的自定义比较逻辑。</p><p><strong>使用仿函数实现自定义比较逻辑</strong></p><p>在优先队列中，我们可以通过仿函数来自定义优先级的比较规则，例如可以根据某个属性排序，或者复杂的多层次比较。</p><p><strong>示例：自定义仿函数排序</strong></p><p>假设我们有一个任务结构体 <code>Task</code>，其中有 <code>priority</code> 和 <code>name</code> 两个成员。我们希望根据 <code>priority</code> 来定义优先队列的顺序，但我们想要用仿函数而不是结构体中的 <code>&lt;</code> 运算符来进行比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 任务结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    std::string name;<br>&#125;;<br><br><span class="hljs-comment">// 自定义仿函数，用于比较 Task 的优先级</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TaskCompare</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Task&amp; t1, <span class="hljs-type">const</span> Task&amp; t2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> t<span class="hljs-number">1.</span>priority &lt; t<span class="hljs-number">2.</span>priority;  <span class="hljs-comment">// 优先级低的任务排在队列后面</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用仿函数 TaskCompare 作为优先队列的比较函数</span><br>    std::priority_queue&lt;Task, std::vector&lt;Task&gt;, TaskCompare&gt; pq;<br><br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Task1&quot;</span>&#125;);<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Task3&quot;</span>&#125;);<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Task2&quot;</span>&#125;);<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Top task: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">&quot; with priority &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().priority &lt;&lt; std::endl;<br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>仿函数与函数指针的区别</strong></p><p>仿函数与传统的函数指针相比有如下优点：</p><ol><li><strong>状态保持</strong>：仿函数可以携带状态（通过成员变量），而函数指针只能调用不带状态的函数。</li><li><strong>内联优化</strong>：编译器通常能够将仿函数内联，从而提高运行时效率，而函数指针的调用需要通过指针间接调用，效率较低。</li></ol><p><strong>示例：带状态的仿函数</strong></p><p>我们可以通过仿函数保存一些额外的状态信息。例如，假设我们想要自定义优先队列的顺序，同时根据一个给定的阈值来动态决定任务的优先级比较。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 任务结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    std::string name;<br>&#125;;<br><br><span class="hljs-comment">// 带状态的仿函数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DynamicTaskCompare</span> &#123;<br>    <span class="hljs-type">int</span> threshold;  <span class="hljs-comment">// 比较任务优先级的阈值</span><br>    <br>    <span class="hljs-built_in">DynamicTaskCompare</span>(<span class="hljs-type">int</span> t) : <span class="hljs-built_in">threshold</span>(t) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> Task&amp; t1, <span class="hljs-type">const</span> Task&amp; t2)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (t<span class="hljs-number">1.</span>priority &gt;= threshold &amp;&amp; t<span class="hljs-number">2.</span>priority &lt; threshold) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// t1 优先</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (t<span class="hljs-number">1.</span>priority &lt; threshold &amp;&amp; t<span class="hljs-number">2.</span>priority &gt;= threshold) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// t2 优先</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> t<span class="hljs-number">1.</span>priority &lt; t<span class="hljs-number">2.</span>priority;  <span class="hljs-comment">// 优先级大的任务排在前面</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用带状态的仿函数进行优先级比较</span><br>    std::priority_queue&lt;Task, std::vector&lt;Task&gt;, DynamicTaskCompare&gt; <span class="hljs-built_in">pq</span>(<span class="hljs-built_in">DynamicTaskCompare</span>(<span class="hljs-number">2</span>));<br>    <br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Task1&quot;</span>&#125;);<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Task3&quot;</span>&#125;);<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Task2&quot;</span>&#125;);<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Top task: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">&quot; with priority &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().priority &lt;&lt; std::endl;<br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>DynamicTaskCompare</code> 仿函数通过 <code>threshold</code> 这个状态来动态决定任务的优先级。这个特性在某些动态排序场景下非常有用。</p><p><strong>仿函数与 Lambda 表达式</strong></p><p>C++11 引入了 <strong>Lambda 表达式</strong>，它可以提供类似仿函数的功能，并且代码更加简洁。如果比较逻辑非常简单，可以使用 Lambda 表达式代替仿函数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-type">int</span> priority;<br>    std::string name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> compare = [](<span class="hljs-type">const</span> Task&amp; t1, <span class="hljs-type">const</span> Task&amp; t2) &#123;<br>        <span class="hljs-keyword">return</span> t<span class="hljs-number">1.</span>priority &lt; t<span class="hljs-number">2.</span>priority;  <span class="hljs-comment">// 优先级低的任务排在队列后面</span><br>    &#125;;<br><br>    std::priority_queue&lt;Task, std::vector&lt;Task&gt;, <span class="hljs-keyword">decltype</span>(compare)&gt; <span class="hljs-built_in">pq</span>(compare);<br><br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Task1&quot;</span>&#125;);<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Task3&quot;</span>&#125;);<br>    pq.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Task2&quot;</span>&#125;);<br><br>    <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Top task: &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().name &lt;&lt; <span class="hljs-string">&quot; with priority &quot;</span> &lt;&lt; pq.<span class="hljs-built_in">top</span>().priority &lt;&lt; std::endl;<br>        pq.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-底层实现"><a href="#4-底层实现" class="headerlink" title="4. 底层实现"></a>4. <strong>底层实现</strong></h3><p><code>priority_queue</code> 的底层实现通常依赖于<strong>堆</strong>，具体来说是 <strong>二叉堆</strong>。C++ 标准库使用 <strong><code>std::vector</code></strong> 作为底层存储容器来保存元素，并通过堆的操作来保持优先队列的性质。</p><ul><li><strong>堆操作</strong>：<ul><li>插入元素时，会调用堆的 <strong>上浮操作</strong>，确保新元素插入后堆的结构保持完整。</li><li>删除最大（或最小）元素时，会调用 <strong>下沉操作</strong>，将堆顶元素与子节点交换，确保堆的有序性。</li></ul></li></ul><p>C++ 标准库提供了用于堆操作的算法：</p><ul><li><p><strong><code>std::make_heap</code></strong>: 将范围内的元素构造成堆。</p><ul><li><p><strong>功能</strong>：将一个无序的范围转换为一个堆。默认情况下，它创建一个 <strong>最大堆</strong>（即堆顶是最大值），但也可以通过传递自定义比较器创建最小堆或其他类型的堆。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make_heap</span><span class="hljs-params">(RandomIt first, RandomIt last)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><p><code>first</code> 和 <code>last</code> 指向范围的起始和结束，表示要构建堆的范围。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;;<br>    <br>    <span class="hljs-comment">// 构建一个最大堆</span><br>    std::<span class="hljs-built_in">make_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Max heap: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : v) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 9 6 5 5 1 4 2 1 3</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>std::push_heap</code></strong>: 向堆中插入元素。</p><ul><li><p><strong>功能</strong>：在一个堆中插入新元素（即将新元素添加到容器末尾后，通过 <code>push_heap</code> 调整容器使其重新成为合法的堆结构）。使用时，必须先把新元素手动插入到容器末尾，再调用 <code>push_heap</code>。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_heap</span><span class="hljs-params">(RandomIt first, RandomIt last)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><p><code>first</code> 和 <code>last</code> 指向堆的起始和结束，其中 <code>last</code> 为新插入的元素的下一个位置。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;;<br>    std::<span class="hljs-built_in">make_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">// 移除堆顶元素</span><br>    std::<span class="hljs-built_in">pop_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 9 被移动到末尾</span><br>    v.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 实际移除该元素</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Heap after pop: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : v) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 6 5 5 3 1 4 2 1</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>std::pop_heap</code></strong>: 从堆中删除元素。</p><ul><li><p><strong>功能</strong>：将堆顶元素移到容器的末尾，同时保持其他元素的堆结构（即重新调整剩余元素成为一个合法的堆）。注意，<code>pop_heap</code> 只是将堆顶元素移到末尾，不会从容器中移除它，必须手动使用 <code>container.pop_back()</code>。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop_heap</span><span class="hljs-params">(RandomIt first, RandomIt last)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><p><code>first</code> 和 <code>last</code> 指向堆的起始和结束，<code>last</code> 指向的元素将是新堆顶元素后的第一个非堆元素（即末尾元素）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;;<br>    std::<span class="hljs-built_in">make_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">// 移除堆顶元素</span><br>    std::<span class="hljs-built_in">pop_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());  <span class="hljs-comment">// 9 被移动到末尾</span><br>    v.<span class="hljs-built_in">pop_back</span>();  <span class="hljs-comment">// 实际移除该元素</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Heap after pop: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : v) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 6 5 5 3 1 4 2 1</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong><code>std::sort_heap</code></strong>: 对堆中的元素进行排序。</p><ul><li><p><strong>功能</strong>：对一个堆进行排序。注意，调用 <code>sort_heap</code> 后，堆结构将被破坏，但数组会按升序排序（默认情况下）。这就是堆排序的关键步骤。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort_heap</span><span class="hljs-params">(RandomIt first, RandomIt last)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><p><code>first</code> 和 <code>last</code> 指向堆的起始和结束。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;;<br>    std::<span class="hljs-built_in">make_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>    <br>    <span class="hljs-comment">// 对堆进行排序</span><br>    std::<span class="hljs-built_in">sort_heap</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sorted heap: &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : v) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;  <span class="hljs-comment">// 输出: 1 1 2 3 4 5 5 6 9</span><br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="5-性能分析"><a href="#5-性能分析" class="headerlink" title="5. 性能分析"></a>5. <strong>性能分析</strong></h3><p><code>priority_queue</code> 的时间复杂度与其底层堆实现直接相关。由于使用堆结构，以下是常见操作的时间复杂度：</p><ul><li><strong>插入元素（push）</strong>: O(log n)，因为需要进行上浮操作。</li><li><strong>取最大&#x2F;最小元素（top）</strong>: O(1)，只需返回堆顶元素。</li><li><strong>删除最大&#x2F;最小元素（pop）</strong>: O(log n)，因为需要进行下沉操作。</li></ul><p>由于 <code>priority_queue</code> 是基于二叉堆的实现，因此它具有较高的效率，适合用于需要频繁插入和删除最大（最小）元素的场景。</p><p>在分析 C++ 中与堆操作相关的 <code>make_heap</code>、<code>pop_heap</code>、<code>push_heap</code> 和 <code>sort_heap</code> 函数的性能时，主要考虑堆的性质和这些操作的时间复杂度。堆是一棵完全二叉树，通常使用数组来实现，堆的高度是 <code>O(log n)</code>，其中 <code>n</code> 是堆中元素的个数。</p><ol><li><strong><code>make_heap</code> 的性能分析</strong></li></ol><ul><li><strong>功能</strong>：<code>make_heap</code> 函数将一个无序的序列转化为一个合法的堆。</li><li><strong>时间复杂度</strong>：<code>O(n)</code>。</li></ul><p>虽然每次插入一个元素到堆的复杂度为 <code>O(log n)</code>，看似将 <code>n</code> 个元素插入到堆中会导致 <code>O(n log n)</code> 的时间复杂度。然而，<code>make_heap</code> 使用了一种自底向上的建堆方法，其时间复杂度为 <code>O(n)</code>。</p><p><strong>分析</strong>：</p><ul><li>自顶向下插入的复杂度为 <code>O(n log n)</code>，但 <code>make_heap</code> 采用的是自底向上的建堆方法，它从堆的最后一个非叶子节点开始，逐步调整子堆的顺序，最终构建出一个完整的堆。</li><li>每个节点的调整最多移动 <code>log n</code> 步，但较低层的节点数量多，且调整所需的移动步数较少，因此整体复杂度是线性的，即 <code>O(n)</code>。</li></ul><ol start="2"><li><strong><code>pop_heap</code> 的性能分析</strong></li></ol><ul><li><strong>功能</strong>：<code>pop_heap</code> 将堆顶元素（最大或最小值）移动到序列的末尾，同时保持剩余序列的堆结构。</li><li><strong>时间复杂度</strong>：<code>O(log n)</code>。</li></ul><p><strong>分析</strong>：</p><ul><li><code>pop_heap</code> 先将堆顶元素与最后一个元素交换，然后对交换后的堆（除去最后一个元素）进行下沉操作（即调整堆），从根节点开始逐层向下调整，以保持堆的性质。</li><li>下沉操作的最坏情况下需要进行 <code>log n</code> 次比较和交换操作，因此时间复杂度为 <code>O(log n)</code>。</li></ul><ol start="3"><li><strong><code>push_heap</code> 的性能分析</strong></li></ol><ul><li><strong>功能</strong>：<code>push_heap</code> 在序列的末尾插入一个新元素，并调整序列使其仍然满足堆的性质。</li><li><strong>时间复杂度</strong>：<code>O(log n)</code>。</li></ul><p><strong>分析</strong>：</p><ul><li>当将一个新元素添加到堆中时，它首先被插入到堆的末尾。然后通过上浮操作，将该元素向上移动，直到满足堆的性质。</li><li>上浮操作在最坏情况下可能需要从堆的底部移动到根节点，这需要最多 <code>log n</code> 步操作，因此时间复杂度为 <code>O(log n)</code>。</li></ul><ol start="4"><li><strong><code>sort_heap</code> 的性能分析</strong></li></ol><ul><li><strong>功能</strong>：<code>sort_heap</code> 将堆排序为一个有序数组。它通过依次调用 <code>pop_heap</code>，将堆顶元素移到序列末尾，并调整剩余序列为一个合法的堆，最终完成排序。</li><li><strong>时间复杂度</strong>：<code>O(n log n)</code>。</li></ul><p><strong>分析</strong>：</p><ul><li>堆排序是通过重复调用 <code>pop_heap</code> 实现的，<code>pop_heap</code> 每次将堆顶元素移动到末尾，然后调整剩余的堆，复杂度为 <code>O(log n)</code>。</li><li>因为 <code>sort_heap</code> 需要对 <code>n</code> 个元素依次调用 <code>pop_heap</code>，因此总的时间复杂度为 <code>O(n log n)</code>。</li></ul><h3 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6. 使用场景"></a>6. <strong>使用场景</strong></h3><p>优先队列广泛用于以下场景：</p><ul><li><strong>任务调度</strong>：根据优先级安排任务执行顺序。</li><li><strong>图算法</strong>：如 Dijkstra 最短路径算法、A* 搜索算法等。</li><li><strong>事件驱动模拟</strong>：处理时间敏感的事件。</li><li><strong>动态排序问题</strong>：实时获取最大或最小元素的情况。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]23.合并k个升序链表</title>
    <link href="/2024/10/05/LC-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2024/10/05/LC-23-%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h4><p>将k个链表两两配对合并为一个更长的有序链表，将原问题规约为规模更小的子问题。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode *h1, ListNode *h2)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (h1 == <span class="hljs-literal">nullptr</span> || h2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> h1 ? h1 : h2;<br>        ListNode dummy, *tail = &amp;dummy;<br>        <span class="hljs-keyword">while</span> (h1 &amp;&amp; h2)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (h1-&gt;val &lt;= h2-&gt;val)<br>            &#123;<br>                tail-&gt;next = h1;<br>                h1 = h1-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                tail-&gt;next = h2;<br>                h2 = h2-&gt;next;<br>            &#125;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = h1 ? h1 : h2;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>    <span class="hljs-comment">// [l,r]</span><br>    <span class="hljs-function">ListNode *<span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;ListNode*&gt; &amp;lists, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> lists[l];<br>        <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(<span class="hljs-built_in">merge</span>(lists, l, mid), <span class="hljs-built_in">merge</span>(lists, mid + <span class="hljs-number">1</span>, r));<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(lists, <span class="hljs-number">0</span>, lists.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>注意39行计算中位数的方法，通常的方法是 <code>(l + r) / 2</code> ，这种方法在l和r过大的时候可能会发生溢出的问题，因此更好的方法是 <code>l + ((r - l) &gt;&gt; 1)</code> ，需要特别注意的是注意后面的括号不要省略，因为加法的优先级更高。</p>          </div><p><strong>时间复杂度</strong></p><p>递推方程：$W(k) &#x3D; W(k&#x2F;2) + k&#x2F;2 \times 2n, 其中n为每个链表的平均长度.$</p><p>解这个递推方程可以得到$W(k) &#x3D; O(knlogk).$</p><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a><a href="https://erlsrnby04.github.io/2024/10/05/C-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/">优先队列</a></h4><p>另一种思路是将k个链表的头结点通过一个小顶堆来维护，每次取出最小的结点，然后将该结点下一个结点重新插入小顶堆中。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> cmp = [](<span class="hljs-type">const</span> ListNode *lhs, <span class="hljs-type">const</span> ListNode *rhs)<br>        &#123;<br>            <span class="hljs-keyword">return</span> lhs-&gt;val &gt; rhs-&gt;val;<br>        &#125;;<br>        priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br>        ListNode dummy, *tail = &amp;dummy;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> list : lists) <br>            <span class="hljs-keyword">if</span> (list) pq.<span class="hljs-built_in">push</span>(list);<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            tail-&gt;next = pq.<span class="hljs-built_in">top</span>(); pq.<span class="hljs-built_in">pop</span>();<br>            tail = tail-&gt;next;<br>            <span class="hljs-keyword">if</span> (tail-&gt;next) pq.<span class="hljs-built_in">push</span>(tail-&gt;next);<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度</strong></p><p>小顶堆中插入和删除操作的时间复杂度都是$O(logk)$，所有结点都需要进队一次，出队一次，因此算法的时间复杂度是$O(knlogk)$，和分治算法的时间复杂度一样。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>分治算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[LC]4.寻找两个正序数组的中位数</title>
    <link href="/2024/10/05/LC-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <url>/2024/10/05/LC-4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h4><p>直接归并两个有序数组，然后求中位数即可</p><p><strong>时间复杂度</strong> ：$O(m+n)$</p><h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>先考虑更一般的问题，找第$k$小的数。</p><p>为了找到第$k$小的数，先考虑$A[k&#x2F;2 - 1]$和$B[k&#x2F;2 - 1]$，这分为三种情况：</p><ol><li><p>$A[k&#x2F;2 - 1] &lt; B[k&#x2F;2 - 1]$ :</p><p>$命题:A[0,1,…,k&#x2F;2-1]中的数不会是第k小的数$</p><p>$证明:A[k&#x2F;2 - 1]是A[0,1,…,k&#x2F;2-1]中最大的数，$</p><p>$而A[k&#x2F;2-1]之前最多有k&#x2F;2-1+k&#x2F;2-1 &#x3D; k-2个元素,$</p><p>$因此A[k&#x2F;2-1]至多是第k-1小的元素.$</p><p>因此，对于此种情况，我们丢弃$A[0,1,…,k&#x2F;2-1]$中的元素，并相应的更新$k$，求解一个规模更小的子问题.</p></li><li><p>$A[k&#x2F;2 - 1] &gt; B[k &#x2F; 2 -1]$</p><p>同理，对于此种情况，我们丢弃$B[0,1,…,k&#x2F;2-1]$中的元素，并相应的更新$k$.</p></li><li><p>$A[k&#x2F;2-1] &#x3D; B[k&#x2F;2 -1]$</p><p>该情况可以并入情况1.</p></li></ol><p>需要注意的是，我们必须考虑当$k&#x2F;2-1$越界的情况，此时我们取数组最后一个元素即可，更新$k$的时候要相应的修改。</p><p>当$k&#x3D;1$的时候，我们只需要返回两个数组首元素中的较小者即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// k 从1开始</span><br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findKthElement</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, </span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, </span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">size_t</span> k)</span></span><br><span class="hljs-function">    </span>&#123;<br>    <span class="hljs-type">size_t</span> l1 = <span class="hljs-number">0</span>, l2 = <span class="hljs-number">0</span>, m = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>(), n = nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (l1 == m)<br>            <span class="hljs-keyword">return</span> nums2[l2 + k - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (l2 == n)<br>                <span class="hljs-keyword">return</span> nums1[l1 + k - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(nums1[l1], nums2[l2]);<br>        <span class="hljs-type">size_t</span> m1 = <span class="hljs-built_in">min</span>(l1 + k/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">size_t</span> m2 = <span class="hljs-built_in">min</span>(l2 + k/<span class="hljs-number">2</span> - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (nums1[m1] &lt;= nums2[m2])<br>            &#123;<br>                k -= (m1 - l1 + <span class="hljs-number">1</span>);<br>                l1 = m1 + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                k -= (m2 - l2 + <span class="hljs-number">1</span>);<br>                l2 = m2 + <span class="hljs-number">1</span>;<br>            &#125;<br>&#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>      <span class="hljs-type">size_t</span> length = nums<span class="hljs-number">1.</span><span class="hljs-built_in">size</span>() + nums<span class="hljs-number">2.</span><span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">findKthElement</span>(nums1, nums2, length / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">return</span> (<span class="hljs-built_in">findKthElement</span>(nums1, nums2, length / <span class="hljs-number">2</span>) + <br>                    <span class="hljs-built_in">findKthElement</span>(nums1, nums2, length / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>    <br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>时间复杂度：</strong></p><p>因为每次$k$都会减少一半，所以时间复杂度为$O(logk) &#x3D; O(log(m+n)).$</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>分治算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>leetcode</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Lab3 page tables</title>
    <link href="/2024/10/05/MIT-6-1810-Lab3-page-tables/"/>
    <url>/2024/10/05/MIT-6-1810-Lab3-page-tables/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Inspect-a-user-process-page-table-easy"><a href="#1-Inspect-a-user-process-page-table-easy" class="headerlink" title="1 Inspect a user-process page table (easy)"></a>1 Inspect a user-process page table (<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">easy</a>)</h2><p><img src="/../images/MIT-6-1810-Lab3-page-tables/image-20241005151513827.png"></p><p><img src="/../images/MIT-6-1810-Lab3-page-tables/image-20241005151435200.png"></p><table><thead><tr><th>PTE</th><th>逻辑内容</th><th>权限位</th></tr></thead><tbody><tr><td>va 0x0 pte 0x21FC885B pa 0x87F22000 perm 0x5B</td><td>text</td><td>AUXRV</td></tr><tr><td>va 0x1000 pte 0x21FC7C17 pa 0x87F1F000 perm 0x17</td><td>data</td><td>UWRV</td></tr><tr><td>va 0x2000 pte 0x21FC7807 pa 0x87F1E000 perm 0x7</td><td>guard page</td><td>WRV</td></tr><tr><td>va 0x3000 pte 0x21FC74D7 pa 0x87F1D000 perm 0xD7</td><td>stack</td><td>DAUWRV</td></tr><tr><td>va 0x4000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0x5000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0x6000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0x7000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0x8000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0x9000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFF6000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFF7000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFF8000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFF9000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFFA000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFFB000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFFC000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFFD000 pte 0x0 pa 0x0 perm 0x0</td><td>unused</td><td></td></tr><tr><td>va 0xFFFFE000 pte 0x21FD08C7 pa 0x87F42000 perm 0xC7</td><td>trapframe</td><td>DAWRV</td></tr><tr><td>va 0xFFFFF000 pte 0x2000184B pa 0x80006000 perm 0x4B</td><td>trampoline</td><td>AXRV</td></tr></tbody></table><h2 id="2-Speed-up-system-calls-easy"><a href="#2-Speed-up-system-calls-easy" class="headerlink" title="2 Speed up system calls (easy)"></a>2 Speed up system calls (<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">easy</a>)</h2><p>Some operating systems (e.g., Linux) speed up certain system calls by sharing data in a read-only region between userspace and the kernel. This eliminates the need for kernel crossings when performing these system calls. To help you learn how to insert mappings into a page table, your first task is to implement this optimization for the <code>getpid()</code> system call in xv6.</p><div class="note note-primary">            <p>When each process is created, map one read-only page at USYSCALL (a virtual address defined in <code>memlayout.h</code>). At the start of this page, store a <code>struct usyscall</code> (also defined in <code>memlayout.h</code>), and initialize it to store the PID of the current process. For this lab, <code>ugetpid()</code> has been provided on the userspace side and will automatically use the USYSCALL mapping. You will receive full credit for this part of the lab if the <code>ugetpid</code> test case passes when running <code>pgtbltest</code>.</p>          </div><p>这道题目要求我们在创建一个进程的时候，将一个只读的物理页映射到虚拟地址 <code>USYSCALL</code> ，这样可以在内核和用户空间之间共享一些数据（内核将指定的数据暴露给用户，使得可以在用户空间内访问）。通过在用户空间提供相应的接口，可以完成一些简单的系统调用而无需进行用户到内核的切换。</p><p>大致的思路如下：</p><p>在创建进程的时候申请物理内存，销毁进程的时候释放物理内存，创建页表的时候进行映射，销毁页表的时候取消映射。</p><ol><li><p>在proc结构体中添加一个 <code>struct usyscall *usyscall</code> 用来存放该页面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>    <br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span> *<span class="hljs-title">usyscall</span>;</span>   <span class="hljs-comment">// shared data between kernel and user</span><br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在创建进程的过程中，申请一个物理页，参考trapframe.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/proc.c</span><br><br><span class="hljs-comment">// Allocate a usyscall page.</span><br><span class="hljs-comment">// Look in the process table for an UNUSED proc.</span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,</span><br><span class="hljs-comment">// and return with p-&gt;lock held.</span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <br><span class="hljs-comment">// Allocate a usyscall page</span><br>    <span class="hljs-keyword">if</span>((p-&gt;usyscall = (<span class="hljs-keyword">struct</span> usyscall *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>        freeproc(p);<br>        release(&amp;p-&gt;lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    p-&gt;usyscall-&gt;pid = p-&gt;pid;<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在创建页表时将该物理页映射到虚拟地址 <code>USYSCALL</code>，权限位设置为 <code>PTE_U | PTE_R</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/proc.c</span><br><br><span class="hljs-comment">// Create a user page table for a given process, with no user memory,</span><br><span class="hljs-comment">// but with trampoline and trapframe pages.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// map the usyscall page just below the trapframe page </span><br>    <span class="hljs-keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,<br>              (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="hljs-number">0</span>)&#123;<br>        uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        uvmunmap(pagetable, TRAPFRAME, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        uvmfree(pagetable, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>释放页表的时候取消映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//kernel/proc.c</span><br><br><span class="hljs-comment">// Free a process&#x27;s page table, and free the</span><br><span class="hljs-comment">// physical memory it refers to.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">proc_freepagetable</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 sz)</span><br>&#123;<br>  uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmunmap(pagetable, TRAPFRAME, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmunmap(pagetable, USYSCALL, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmfree(pagetable, sz);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在销毁进程的时候，将该页内存释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// free a proc structure and the data hanging from it,</span><br><span class="hljs-comment">// including user pages.</span><br><span class="hljs-comment">// p-&gt;lock must be held.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">freeproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br><span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-keyword">if</span>(p-&gt;usyscall)<br>    kfree((<span class="hljs-type">void</span>*)p-&gt;usyscall);<br>    p-&gt;usyscall = <span class="hljs-number">0</span>;<br>   <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-Print-a-page-table-easy"><a href="#3-Print-a-page-table-easy" class="headerlink" title="3 Print a page table (easy)"></a>3 Print a page table (<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">easy</a>)</h2><div class="note note-primary">            <p>We added a system call <code>kpgtbl()</code>, which calls <code>vmprint()</code> in <code>vm.c</code>. It takes a <code>pagetable_t</code> argument, and your job is to print that pagetable in the format described below.</p>          </div><p>这题通过递归实现，参考freewalk。注意虚拟地址va，当遍历3级页表的时候，每遍历一个页表项，va变化<code>512*512*PGSIZE</code>，2级1级以此类推。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">vmprinthelper</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, <span class="hljs-type">int</span> level, uint64 va)</span><br>&#123;<br>  uint64 sz = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (level == <span class="hljs-number">2</span>) sz = <span class="hljs-number">512</span> * <span class="hljs-number">512</span> * PGSIZE;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (level == <span class="hljs-number">1</span>) sz = <span class="hljs-number">512</span> * PGSIZE;<br>  <span class="hljs-keyword">else</span> sz = PGSIZE;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++, va += sz)&#123;<br>    <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>    <span class="hljs-keyword">if</span> ((pte &amp; PTE_V) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span> - level; ++j) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; ..&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p: &quot;</span>, (<span class="hljs-type">void</span>*)va);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pte %p pa %p\n&quot;</span>, (<span class="hljs-type">void</span>*)pte, (<span class="hljs-type">void</span>*)PTE2PA(pte));<br>    <span class="hljs-keyword">if</span> ((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)<br>      vmprinthelper((<span class="hljs-type">void</span>*)PTE2PA(pte), level - <span class="hljs-number">1</span>, va);<br>  &#125;<br>&#125;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span> &#123;<br>  <span class="hljs-comment">// your code here</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>  vmprinthelper(pagetable, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Use-superpages-moderate-hard"><a href="#4-Use-superpages-moderate-hard" class="headerlink" title="4 Use superpages (moderate)&#x2F;(hard)"></a>4 Use superpages (<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">moderate</a>)&#x2F;(<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">hard</a>)</h2><div class="note note-primary">            <p>Your job is to modify the xv6 kernel to use superpages. In particular, if a user program calls sbrk() with a size of 2 megabytes or more, and the newly created address range includes one or more areas that are two-megabyte-aligned and at least two megabytes in size, the kernel should use a single superpage (instead of hundreds of ordinary pages). You will receive full credit for this part of the lab if the <code>superpg_test</code> test case passes when running <code>pgtbltest</code>.</p>          </div><p>本题要求实现superpage</p><ul><li><p>修改内存布局，在可供分配的物理内存中预留出一块区域用于superpage</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// memlayout.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> KERNBASE 0x80000000L</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SUPERBASE (KERNBASE + 112*1024*1024)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHYSTOP (KERNBASE + 128*1024*1024)</span><br></code></pre></td></tr></table></figure></li><li><p>修改kallo.c中的代码，在初始化 <code>kmem</code> 的时候预留出一定物理空间给superpage</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kallo.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kinit</span><span class="hljs-params">()</span><br>&#123;<br>  initlock(&amp;kmem.lock, <span class="hljs-string">&quot;kmem&quot;</span>);<br>  freerange(end, (<span class="hljs-type">void</span>*)SUPERBASE);<br>  superinit();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>增加一个 <code>supermem</code> 链表，用于管理所有空闲的superpage，并进行相应的初始化工作（参考kmem）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kalloc.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">freelist</span>;</span><br>&#125; kmem, supermem;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">superinit</span><span class="hljs-params">()</span><br>&#123;<br>  initlock(&amp;supermem.lock, <span class="hljs-string">&quot;supermem&quot;</span>);<br>  <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*) SUPERPGROUNDUP(SUPERBASE);<br>  <span class="hljs-keyword">for</span> (; p + SUPERPGSIZE &lt;= (<span class="hljs-type">char</span>*)PHYSTOP; p += SUPERPGSIZE)<br>    superfree(p);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加 <code>superalloc</code> 和 <code>superfree</code> 函数，用于分配和释放superpage</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">superfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % SUPERPGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; (<span class="hljs-type">char</span>*)SUPERBASE || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;superfree&quot;</span>);<br><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, SUPERPGSIZE);<br><br>  r = (<span class="hljs-keyword">struct</span> run*)pa;<br><br>  acquire(&amp;supermem.lock);<br>  r-&gt;next = supermem.freelist;<br>  supermem.freelist = r;<br>  release(&amp;supermem.lock);<br>&#125;<br><br><span class="hljs-comment">// Allocate one 2MB page of physical memory.</span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.</span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">superalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  acquire(&amp;supermem.lock);<br>  r = supermem.freelist;<br>  <span class="hljs-keyword">if</span>(r)<br>    supermem.freelist = r-&gt;next;<br>  release(&amp;supermem.lock);<br><br>  <span class="hljs-keyword">if</span>(r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, SUPERPGSIZE); <span class="hljs-comment">// fill with junk</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用户在调用 <code>sbrk</code> 系统调用的时候，实际会去调用 <code>uvmalloc</code> 函数，因此，我们需要修改 <code>uvmalloc</code> 函数，根据参数进行不同的分配策略。具体的，我们先分配普通的page，直到虚拟地址对齐到了2MB的位置上，然后我们尽可能多的分配superpage，最后有可能还会剩下一些需要分配的内存，但是不足一个superpage，或者我们已经没有superpage可供分配了，我们继续分配普通的page，直到满足用户需求。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate PTEs and physical memory to grow process from oldsz to</span><br><span class="hljs-comment">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span><br>uint64<br><span class="hljs-title function_">uvmalloc</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 oldsz, uint64 newsz, <span class="hljs-type">int</span> xperm)</span><br>&#123;<br>  <span class="hljs-type">char</span> *mem;<br>  uint64 a;<br>  <span class="hljs-type">int</span> sz;<br><br>  <span class="hljs-keyword">if</span>(newsz &lt; oldsz)<br>    <span class="hljs-keyword">return</span> oldsz;<br>  <span class="hljs-comment">// page ... page superpage ... superpage page ... page</span><br>  oldsz = PGROUNDUP(oldsz);<br>  <br>  <span class="hljs-comment">// 分配page直到对齐</span><br>  <span class="hljs-keyword">for</span>(a = oldsz; a &lt; SUPERPGROUNDUP(oldsz) &amp;&amp; a &lt; newsz; a += sz)&#123;<br>    sz = PGSIZE;<br>    mem = kalloc();<br>    <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LAB_SYSCALL</span><br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, sz);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">if</span>(mappages(pagetable, a, sz, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="hljs-number">0</span>)&#123;<br>      kfree(mem);<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 尽可能多的分配superpage</span><br>  <span class="hljs-keyword">for</span> (; a + SUPERPGSIZE &lt; newsz; a += sz)<br>  &#123;<br>    sz = SUPERPGSIZE;<br>    mem = superalloc();<br>    <span class="hljs-keyword">if</span> (mem == <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, sz);<br>    <span class="hljs-keyword">if</span> (mappages(pagetable, a, sz, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="hljs-number">0</span>)&#123;<br>      superfree(mem);<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 为剩余内存分配page</span><br>  <span class="hljs-keyword">for</span>(; a &lt; newsz; a += sz)&#123;<br>    sz = PGSIZE;<br>    mem = kalloc();<br>    <span class="hljs-keyword">if</span>(mem == <span class="hljs-number">0</span>)&#123;<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(mem, <span class="hljs-number">0</span>, sz);<br>    <span class="hljs-keyword">if</span>(mappages(pagetable, a, sz, (uint64)mem, PTE_R|PTE_U|xperm) != <span class="hljs-number">0</span>)&#123;<br>      kfree(mem);<br>      uvmdealloc(pagetable, a, oldsz);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> newsz;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>uvmalloc</code> 中申请到内存之后，我们需要在页表中添加对应的页表项。superpage只需要在一级页表中设置即可，因为一个一级页表对应512个页，即2MB。因此，我们需要修改 <code>mappages</code> 函数，来进行相应的映射。我们根据pa的值来区分当前映射的是page还是superpage，并且我们需要相应的 <code>superwalk</code> 来获取<code>superpage</code> 对应的页表项，<code>walk</code> 获得的页表项是0级页表中的，<code>superwalk</code> 获得1级页表中的页表项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">pte_t</span> *<br><span class="hljs-title function_">superwalk</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, <span class="hljs-type">int</span> alloc)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(va &gt;= MAXVA)<br>    panic(<span class="hljs-string">&quot;superwalk&quot;</span>);<br><br>  <span class="hljs-type">pte_t</span> *pte = &amp;pagetable[PX(<span class="hljs-number">2</span>, va)];<br>  <span class="hljs-keyword">if</span>(*pte &amp; PTE_V) &#123;<br>    pagetable = (<span class="hljs-type">pagetable_t</span>)PTE2PA(*pte);<br>    <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">1</span>, va)];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span>(!alloc || (pagetable = (<span class="hljs-type">pde_t</span>*)kalloc()) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(pagetable, <span class="hljs-number">0</span>, PGSIZE);<br>    *pte = PA2PTE(pagetable) | PTE_V;<br>    <span class="hljs-keyword">return</span> &amp;pagetable[PX(<span class="hljs-number">1</span>, va)];<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Create PTEs for virtual addresses starting at va that refer to</span><br><span class="hljs-comment">// physical addresses starting at pa.</span><br><span class="hljs-comment">// va and size MUST be page-aligned.</span><br><span class="hljs-comment">// Returns 0 on success, -1 if walk() couldn&#x27;t</span><br><span class="hljs-comment">// allocate a needed page-table page.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">mappages</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 size, uint64 pa, <span class="hljs-type">int</span> perm)</span><br>&#123;<br>  uint64 a, last;<br>  uint64 pgsize;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  <span class="hljs-keyword">if</span> (pa &gt;= SUPERBASE) pgsize = SUPERPGSIZE;<br>  <span class="hljs-keyword">else</span> pgsize = PGSIZE;<br>  <span class="hljs-keyword">if</span>((va % pgsize) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: va not aligned&quot;</span>);<br><br>  <span class="hljs-keyword">if</span>((size % pgsize) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: size not aligned&quot;</span>);<br><br>  <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;mappages: size&quot;</span>);<br>  <br>  a = va;<br>  last = va + size - pgsize;<br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-keyword">if</span>(pgsize == PGSIZE &amp;&amp; (pte = walk(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (pgsize == SUPERPGSIZE &amp;&amp; (pte = superwalk(pagetable, a, <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span>(*pte &amp; PTE_V)<br>      panic(<span class="hljs-string">&quot;mappages: remap&quot;</span>);<br>    *pte = PA2PTE(pa) | perm | PTE_V;<br>    <span class="hljs-keyword">if</span>(a == last)<br>      <span class="hljs-keyword">break</span>;<br>    a += pgsize;<br>    pa += pgsize;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>分配完了内存，我们也需要处理释放内存。释放内存调用 <code>uvmdealloc</code> ，该函数调用 <code>uvmunmap</code> 函数去进行实际的释放操作。我们同样根据获得的pa来判断当前释放的是page还是superpage。这里获取va对应的页表项可以统一用 <code>walk</code> ，因为 <code>walk</code> 遇到叶子结点的时候会直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Remove npages of mappings starting from va. va must be</span><br><span class="hljs-comment">// page-aligned. The mappings must exist.</span><br><span class="hljs-comment">// Optionally free the physical memory.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uvmunmap</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 va, uint64 npages, <span class="hljs-type">int</span> do_free)</span><br>&#123;<br>  uint64 a;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  <span class="hljs-type">int</span> sz;<br><br>  <span class="hljs-keyword">if</span>((va % PGSIZE) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;uvmunmap: not aligned&quot;</span>);<br><br>  <span class="hljs-keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += sz)&#123;<br>    sz = PGSIZE;<br>    <span class="hljs-keyword">if</span>((pte = walk(pagetable, a, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmunmap: walk&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;va=%ld pte=%ld\n&quot;</span>, a, *pte);<br>      panic(<span class="hljs-string">&quot;uvmunmap: not mapped&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)<br>      panic(<span class="hljs-string">&quot;uvmunmap: not a leaf&quot;</span>);<br>    uint64 pa = PTE2PA(*pte);<br>    <span class="hljs-keyword">if</span> (pa &gt;= SUPERBASE)&#123;<br>      a += SUPERPGSIZE;<br>      a -= sz;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(do_free)&#123;<br>      uint64 pa = PTE2PA(*pte);<br>      <span class="hljs-keyword">if</span> (pa &gt;= SUPERBASE) superfree((<span class="hljs-type">void</span>*)pa);<br>      <span class="hljs-keyword">else</span> kfree((<span class="hljs-type">void</span>*)pa);<br>    &#125;<br>    *pte = <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行 <code>fork</code> 的时候会拷贝内存，调用的是 <code>uvmcopy</code> ，因此我们需要进行相应的修改。其实就是遍历父进程用户空间的内存，根据内存的pa判断该页是page还是superpage，然后进行相应的申请并复制，最后在新进程的页表中添加相应的页表项即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Given a parent process&#x27;s page table, copy</span><br><span class="hljs-comment">// its memory into a child&#x27;s page table.</span><br><span class="hljs-comment">// Copies both the page table and the</span><br><span class="hljs-comment">// physical memory.</span><br><span class="hljs-comment">// returns 0 on success, -1 on failure.</span><br><span class="hljs-comment">// frees any allocated pages on failure.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">uvmcopy</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> old, <span class="hljs-type">pagetable_t</span> new, uint64 sz)</span><br>&#123;<br>  <span class="hljs-type">pte_t</span> *pte;<br>  uint64 pa, i;<br>  uint flags;<br>  <span class="hljs-type">char</span> *mem;<br>  <span class="hljs-type">int</span> szinc;<br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; sz; i += szinc)&#123;<br>    szinc = PGSIZE;<br>    <span class="hljs-keyword">if</span>((pte = walk(old, i, <span class="hljs-number">0</span>)) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: pte should exist&quot;</span>);<br>    <span class="hljs-keyword">if</span>((*pte &amp; PTE_V) == <span class="hljs-number">0</span>)<br>      panic(<span class="hljs-string">&quot;uvmcopy: page not present&quot;</span>);<br>    pa = PTE2PA(*pte);<br>    flags = PTE_FLAGS(*pte);<br>    <span class="hljs-keyword">if</span> (pa &gt;= SUPERBASE)&#123;<br>      szinc = SUPERPGSIZE;<br>      <span class="hljs-keyword">if</span> ((mem = superalloc()) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((mem = kalloc()) == <span class="hljs-number">0</span>) <br>      <span class="hljs-keyword">goto</span> err;<br>    memmove(mem, (<span class="hljs-type">char</span>*)pa, szinc);<br>    <span class="hljs-keyword">if</span>(mappages(new, i, szinc, (uint64)mem, flags) != <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-keyword">if</span> (szinc == PGSIZE) kfree(mem);<br>      <span class="hljs-keyword">else</span> superfree(mem);<br>      <span class="hljs-keyword">goto</span> err;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br> err:<br>  uvmunmap(new, <span class="hljs-number">0</span>, i / PGSIZE, <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-测试结果"><a href="#5-测试结果" class="headerlink" title="5 测试结果"></a>5 测试结果</h2><p><img src="/../images/MIT-6-1810-Lab3-page-tables/image-20241018200421898.png"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Lab2 system calls</title>
    <link href="/2024/10/04/MIT-6-1810-Lab2-system-calls/"/>
    <url>/2024/10/04/MIT-6-1810-Lab2-system-calls/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Using-gdb-easy"><a href="#1-Using-gdb-easy" class="headerlink" title="1 Using gdb(easy)"></a>1 Using gdb(easy)</h2><h3 id="gdb配置"><a href="#gdb配置" class="headerlink" title="gdb配置"></a>gdb配置</h3><p><strong>使用gdb调试</strong></p><ol><li>运行 <code>make qemu-gdb</code> 命令</li><li>另外一个窗口中运行 <code>riscv-64-unknown-elf-gdb kernel/kernel</code> 命令</li><li>然后在gdb环境中运行 <code>(gdb) target remote localhost:26000</code> 命令即可</li></ol><p>3中的端口号在.gdbinit文件中查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># .gdbinit</span><br><span class="hljs-built_in">set</span> confirm off<br><span class="hljs-built_in">set</span> architecture riscv:rv64<br>target remote 127.0.0.1:26000 <span class="hljs-comment"># 如果使用vscode调试 需要删除这行</span><br>symbol-file kernel/kernel<br><span class="hljs-built_in">set</span> disassemble-next-line auto<br><span class="hljs-built_in">set</span> riscv use-compressed-breakpoints <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><p><strong>使用vscode调试</strong></p><ol><li><p>运行 <code>make qemu-gdb</code> 命令</p></li><li><p>将上述.gdbinit文件中的第4行删除</p></li><li><p>配置vscode的launch.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0.2.0&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;configurations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;debug xv6&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cppdbg&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;request&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;launch&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;program&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/kernel/kernel&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;args&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;stopAtEntry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;cwd&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;miDebuggerServerAddress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost:26000&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 按照.gdbinit中的端口号</span><br>            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/opt/riscv/bin/riscv64-unknown-elf-gdb&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// gdb目录</span><br>            <span class="hljs-attr">&quot;environment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;externalConsole&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;MIMode&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;gdb&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;setupCommands&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pretty printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;logging&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-comment">// &quot;engineLogging&quot;: true,</span><br>                <span class="hljs-comment">// &quot;programOutput&quot;: true,</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>点击vscode中的调试，程序到达内核main的地址</p></li><li><p>在vscode底部的调试控制台输入命令 <code>-exec file user/_sleep</code> 切换符号表为sleep.c文件</p></li><li><p>在sleep.c中打断点，进行调试即可</p></li></ol><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li><p>Looking at the backtrace output, which function called <code>syscall</code>?</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004201106119.png"></p><p>从图中可以看到，是usertrap这个函数调用了syscall函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(killed(p))<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sepc, scause, and sstatus,</span><br>    <span class="hljs-comment">// so enable only now that we&#x27;re done with those registers.</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause 0x%lx pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=0x%lx stval=0x%lx\n&quot;</span>, r_sepc(), r_stval());<br>    setkilled(p);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(killed(p))<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  usertrapret();<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中可以看到，usertrap中根据scause寄存器判断trap原因，然后进入不同的分支进行处理。对于系统调用，它调用syscall函数处理。</p></li><li><p>What is the value of <code>p-&gt;trapframe-&gt;a7</code> and what does that value represent? (Hint: look <code>user/initcode.S</code>, the first user program xv6 starts.)</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004202903699.png"></p><p>从图中可以看到，a7寄存器的值是7，这对应的是7号系统调用，即SYS_exec。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># initcode.S<br>la a0, init<br>la a1, argv<br>li a7, SYS_exec<br>ecall<br></code></pre></td></tr></table></figure><p>从initcode.S中可以看到，这段代码将SYS_exec的值载入寄存器a7中，然后执行ecall命令。这表示之后要执行exec系统调用。</p></li><li><p>What was the previous mode that the CPU was in?</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004203351293.png"></p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004203406232.png"></p><p>由图可知，sstatus寄存器的第8位是0，表示之前CPU处于用户模式。</p></li><li><p>Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable <code>num</code>?</p><p>将syscall中的 <code>num = p-&gt;trapframe-&gt;a7</code> 修改为 <code>num = *(int*)0</code> 然后重新运行，结果如下：</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004203951088.png"></p><p>在kernel.asm文件中搜索sepc的值，结果如下：</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004204352232.png"></p><p>可以看到，正是我们修改的指令导致内核panic，变量 <code>num</code> 对应寄存器a3.</p><p>重新运行gdb，在上面sepc指出的指令处打断点，结果如下：</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004205040251.png"></p><p>可以看到，出错的指令正是该条修改过的指令。</p></li><li><p>Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in <code>scause</code> above? (See description of <code>scause</code> in <a href="https://pdos.csail.mit.edu/6.828/2024/labs/n//github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V privileged instructions</a>)</p><p>从下图中可以看到，内核地址空间中的地址0并未进行映射，因此无法进行访问，所以内核出错的原因应该是内存访问错误。</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004205745856.png"></p><p>scause寄存器的值为0xd，查看对应的原因为load page fault，这印证了上述的推理。</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004210005557.png"></p></li><li><p>What is the name of the process that was running when the kernel paniced? What is its process id (<code>pid</code>)?</p><p>从下图中可以看出，进程的名字是initcode，pid为1.</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241004210316235.png"></p></li></ol><h2 id="2-System-call-tracing-moderate"><a href="#2-System-call-tracing-moderate" class="headerlink" title="2 System call tracing (moderate)"></a>2 System call tracing (<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">moderate</a>)</h2><div class="note note-primary">            <p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new <code>trace</code> system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls <code>trace(1 &lt;&lt; SYS_fork)</code>, where <code>SYS_fork</code> is a syscall number from <code>kernel/syscall.h</code>. You have to modify the xv6 kernel to print a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The <code>trace</code> system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p>          </div><p>本题要求添加一个系统调用来跟踪系统调用的顺序。</p><p>为了添加一个系统调用，需要进行一下几步：</p><ol><li><p>在user&#x2F;user.h文件中声明系统调用的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// user/user.h</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">trace</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span>;<br></code></pre></td></tr></table></figure></li><li><p>在user&#x2F;usys.pl添加一个stub，之后makefile会执行perl脚本在user&#x2F;usys.S中生成实际的stub汇编指令。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">// user/usys.pl<br>entry(<span class="hljs-string">&quot;trace&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>在kernel&#x2F;syscall.h中添加系统调用号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/syscall.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_trace  22</span><br></code></pre></td></tr></table></figure></li><li><p>在kernel&#x2F;syscall.c中添加系统调用的外部声明，并修改系统调用表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/syscall.c</span><br><span class="hljs-keyword">extern</span> uint64 <span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>; <span class="hljs-comment">// 外部声明</span><br><br><span class="hljs-type">static</span> <span class="hljs-title function_">uint64</span> <span class="hljs-params">(*syscalls[])</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = &#123; <span class="hljs-comment">// 修改系统调用表</span><br>[SYS_fork]    sys_fork,<br><span class="hljs-comment">// ...</span><br>[SYS_trace]   sys_trace,<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在kernel对应的文件中实现系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/sysproc.c</span><br>uint64<br><span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> mask;<br>  argint(<span class="hljs-number">0</span>, &amp;mask);<br>  myproc()-&gt;tracemask = mask;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>本题涉及的代码不复杂，主要流程如下：</p><ol><li><p>修改proc结构体，在该结构体中添加一个mask变量，用来指示需要跟踪的系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/proc.h</span><br><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-type">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-type">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-type">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-type">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-type">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br>  <span class="hljs-type">int</span> tracemask;               <span class="hljs-comment">// trace mask (debugging)</span><br>&#125;;<br><br></code></pre></td></tr></table></figure></li><li><p>实现sys_trace，将系统调用参数存储到进程的proc结构体中</p><p>如上5所示。</p></li><li><p>修改syscall函数，在系统调用返回之前，根据mask进行相应的输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/syscall.c</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    <span class="hljs-comment">// Use num to lookup the system call function for num, call it,</span><br>    <span class="hljs-comment">// and store its return value in p-&gt;trapframe-&gt;a0</span><br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-number">1</span> &lt;&lt; num) &amp; (p-&gt;tracemask))<br>    &#123;<br>      acquire(&amp;p-&gt;lock);<br>      <span class="hljs-type">int</span> pid = p-&gt;pid;<br>      release(&amp;p-&gt;lock);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %ld\n&quot;</span>, pid, syscallnames[num], p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改fork函数，将mask拷贝到子进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// kernel/proc.c</span><br><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  <span class="hljs-comment">// copy tracemask from the parent;</span><br>  np-&gt;tracemask = p-&gt;tracemask;<br><br>  release(&amp;np-&gt;lock);<br><br>  acquire(&amp;wait_lock);<br>  np-&gt;parent = p;<br>  release(&amp;wait_lock);<br><br>  acquire(&amp;np-&gt;lock);<br>  np-&gt;state = RUNNABLE;<br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>结果如下：</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241005125441092.png"></p><h2 id="3-Attack-xv6-moderate"><a href="#3-Attack-xv6-moderate" class="headerlink" title="3 Attack xv6 (moderate)"></a>3 Attack xv6 (<a href="https://pdos.csail.mit.edu/6.828/2024/labs/guidance.html">moderate</a>)</h2><div class="note note-primary">            <p><code>user/secret.c</code> writes an 8-byte secret in its memory and then exits (which frees its memory). Your goal is to add a few lines of code to <code>user/attack.c</code> to find the secret that a previous execution of <code>secret.c</code> wrote to memory, and write the 8 secret bytes to file descriptor 2. You’ll receive full credit if <code>attacktest</code> prints: “OK: secret is ebb.ebb”. (Note: the secret may be different for each run of <code>attacktest</code>.)</p><p>You are allowed to modify <code>user/attack.c</code>, but you cannot make any other changes: you cannot modify the xv6 kernel sources, secret.c, attacktest.c, etc.</p>          </div><p>本题指出xv6中故意引入了几个bug，在申请内存和释放内存后，故意不清除其中的内容，这样我们可以在一个进程退出后，立即申请到它申请的内存，从而访问到另外进程的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// secret.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: secret the-secret\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-type">char</span> *end = sbrk(PGSIZE*<span class="hljs-number">32</span>);<br>  end = end + <span class="hljs-number">9</span> * PGSIZE;<br>  <span class="hljs-built_in">strcpy</span>(end, <span class="hljs-string">&quot;my very very very secret pw is:   &quot;</span>);<br>  <span class="hljs-built_in">strcpy</span>(end+<span class="hljs-number">32</span>, argv[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，secret.c中申请了32页的内存，然后在第9页中第32字节处写入8个字节的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// attack.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>  <span class="hljs-comment">// your code here.  you should write the secret to fd 2 using write</span><br>  <span class="hljs-comment">// (e.g., write(2, secret, 8)</span><br>  <span class="hljs-type">char</span> *end = sbrk(PGSIZE *<span class="hljs-number">32</span>);<br>  end = end + PGSIZE * <span class="hljs-number">16</span>;<br>  <span class="hljs-type">char</span> secret[<span class="hljs-number">8</span> + <span class="hljs-number">1</span>];<br>  secret[<span class="hljs-number">8</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">strcpy</span>(secret, end + <span class="hljs-number">32</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, secret);<br>  write(<span class="hljs-number">2</span>, secret, <span class="hljs-number">8</span>);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在attack.c中同样申请32页内存，但是如果我们直接查看第9页的内容，发现不对，这是因为xv6管理空闲页是通过 <code>freelist</code> 链表来管理的，当申请内存时，从链表头部取下一个页面，但释放一页内存的时候，使用头插法将内存页插入到链表中，这样就会呈现出栈的性质。接下来，尝试查看第22页的内容，发现仍然不对，最后通过尝试发现，实际的内容在第17页。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Allocate one 4096-byte page of physical memory.</span><br><span class="hljs-comment">// Returns a pointer that the kernel can use.</span><br><span class="hljs-comment">// Returns 0 if the memory cannot be allocated.</span><br><span class="hljs-type">void</span> *<br><span class="hljs-title function_">kalloc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br>  acquire(&amp;kmem.lock);<br>  r = kmem.freelist;<br>  <span class="hljs-keyword">if</span>(r) &#123;<br>    kmem.freelist = r-&gt;next;<br>  &#125;<br>  release(&amp;kmem.lock);<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LAB_SYSCALL</span><br>  <span class="hljs-keyword">if</span>(r)<br>    <span class="hljs-built_in">memset</span>((<span class="hljs-type">char</span>*)r, <span class="hljs-number">5</span>, PGSIZE); <span class="hljs-comment">// fill with junk</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)r;<br>&#125;<br><br><span class="hljs-comment">// Free the page of physical memory pointed at by pa,</span><br><span class="hljs-comment">// which normally should have been returned by a</span><br><span class="hljs-comment">// call to kalloc().  (The exception is when</span><br><span class="hljs-comment">// initializing the allocator; see kinit above.)</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">kfree</span><span class="hljs-params">(<span class="hljs-type">void</span> *pa)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>  <span class="hljs-keyword">if</span>(((uint64)pa % PGSIZE) != <span class="hljs-number">0</span> || (<span class="hljs-type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)<br>    panic(<span class="hljs-string">&quot;kfree&quot;</span>);<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LAB_SYSCALL</span><br>  <span class="hljs-comment">// Fill with junk to catch dangling refs.</span><br>  <span class="hljs-built_in">memset</span>(pa, <span class="hljs-number">1</span>, PGSIZE);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>  <br>  r = (<span class="hljs-keyword">struct</span> run*)pa;<br><br>  acquire(&amp;kmem.lock);<br>  r-&gt;next = kmem.freelist;<br>  kmem.freelist = r;<br>  release(&amp;kmem.lock);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-primary">            <p><code>user/secret.c</code> copies the secret bytes to memory whose address is 32 bytes after the start of a page. Change the 32 to 0 and you should see that your attack doesn’t work anymore; why not?</p>          </div><p>这是因为xv6管理空闲页是通过链表来管理的，它将链表的结点直接存放在空闲页开始的 <code>run</code> 结构体中，因此释放一页内存的时候，总是会修改其0字节处一段空间的内容，用来存放链表结点，所以如果将内容存放在0字节处，一定会被覆盖掉。</p><p>结果：</p><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241005144408816.png"></p><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p><img src="/../images/MIT-6-1810-Lab2-system-calls/image-20241005144503714.png"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]static</title>
    <link href="/2024/10/04/C-static/"/>
    <url>/2024/10/04/C-static/</url>
    
    <content type="html"><![CDATA[<p>在C++中，<code>static</code>变量有不同的用途和作用，取决于它在程序中的声明位置。它可以用于局部变量、类成员变量和全局变量。</p><span id="more"></span><h3 id="1-局部static变量"><a href="#1-局部static变量" class="headerlink" title="1. 局部static变量"></a>1. <strong>局部<code>static</code>变量</strong></h3><p>局部<code>static</code>变量是在函数或代码块中声明的<code>static</code>变量。它与普通局部变量的主要区别是：</p><ul><li><strong>生命周期</strong>：局部<code>static</code>变量的生命周期从第一次执行到该声明开始，直到程序结束。即使函数多次被调用，它的值也会在不同的调用之间保持不变。</li><li><strong>作用域</strong>：它的作用域仅限于函数或代码块，不能被函数外部直接访问。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">example</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 只在第一次调用时初始化</span><br>    count++;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">example</span>();  <span class="hljs-comment">// 输出：1</span><br>    <span class="hljs-built_in">example</span>();  <span class="hljs-comment">// 输出：2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-类的static成员变量"><a href="#2-类的static成员变量" class="headerlink" title="2. 类的static成员变量"></a>2. <strong>类的<code>static</code>成员变量</strong></h3><p>类中的<code>static</code>成员变量是属于整个类的，而不是属于某个对象的。它在所有类的实例间共享，同一个类的所有对象都可以访问这个变量，并且它的值对所有对象都是相同的。</p><ul><li><strong>生命周期</strong>：静态成员变量的生命周期从程序开始，到程序结束。</li><li><strong>访问方式</strong>：可以通过类名或类的对象来访问，但推荐使用类名来访问。</li><li><strong>初始化</strong>：静态成员变量必须在类定义体外进行初始化，不能在类内部直接赋值。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 在类定义外初始化</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::staticVar = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 通过类名访问</span><br>    MyClass obj1, obj2;<br>    std::cout &lt;&lt; obj<span class="hljs-number">1.</span>staticVar &lt;&lt; std::endl;  <span class="hljs-comment">// 输出：10</span><br>    obj<span class="hljs-number">2.</span>staticVar = <span class="hljs-number">20</span>;<br>    std::cout &lt;&lt; obj<span class="hljs-number">1.</span>staticVar &lt;&lt; std::endl;  <span class="hljs-comment">// 输出：20 (共享变量)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-全局static变量或函数"><a href="#3-全局static变量或函数" class="headerlink" title="3. 全局static变量或函数"></a>3. <strong>全局<code>static</code>变量或函数</strong></h3><p>如果在函数外部声明<code>static</code>变量或函数，它的作用域将被限制在定义它的文件中，也就是说，它只能在该文件中访问，不能被其他文件链接或访问。通常，这种用法用于隐藏模块的全局变量，使得它们不会污染其他文件的命名空间。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在file1.cpp中</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> globalStaticVar = <span class="hljs-number">100</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; globalStaticVar &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 在file2.cpp中</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">function</span>();  <span class="hljs-comment">// 输出：100</span><br>    <span class="hljs-comment">// 不能直接访问globalStaticVar，因为它是file1.cpp的静态变量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-类static成员函数"><a href="#4-类static成员函数" class="headerlink" title="4. 类static成员函数"></a>4. <strong>类<code>static</code>成员函数</strong></h3><p>如果在类中声明一个<code>static</code>成员函数，那么该函数可以在没有对象实例的情况下被调用。<code>static</code>成员函数只能访问类的<code>static</code>成员变量或其他<code>static</code>成员函数，不能访问非静态成员。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> staticVar;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">staticFunction</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Static variable: &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> MyClass::staticVar = <span class="hljs-number">42</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass::<span class="hljs-built_in">staticFunction</span>();  <span class="hljs-comment">// 可以在没有对象的情况下调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>局部<code>static</code>变量</strong>：初始化一次，生命周期贯穿整个程序，作用域限于函数内。</li><li><strong>类的<code>static</code>成员变量</strong>：在类的所有对象之间共享，必须在类外进行初始化。</li><li><strong>全局<code>static</code>变量</strong>：作用域限制在定义它的文件中，不会被其他文件访问。</li><li><strong>类的<code>static</code>成员函数</strong>：无需创建对象即可调用，只能访问<code>static</code>成员。</li></ul><p>这些特性使得<code>static</code>关键字在C++中广泛用于控制变量和函数的生命周期、作用域和访问权限。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 16</title>
    <link href="/2024/10/04/C-C-Primer-Chapter-16/"/>
    <url>/2024/10/04/C-C-Primer-Chapter-16/</url>
    
    <content type="html"><![CDATA[<h1 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h1><h2 id="16-1-定义模板"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板</h2><h3 id="16-1-1-函数模板"><a href="#16-1-1-函数模板" class="headerlink" title="16.1.1 函数模板"></a>16.1.1 函数模板</h3><p>一个<strong>函数模板</strong>就是一个公式，可用来生成针对特定类型的函数版本。</p><p>模板定义以关键字template开始，后跟一个模板参数列表（template parameter list），这是一个逗号分隔的一个或多个模板参数（template parameter）的列表，用小于号（&lt;）和大于号（&gt;）包围起来。</p><p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定模板实参（template argument），将其绑定到模板参数上。</p><p><strong>实例化函数模板</strong></p><p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。</p><p>编译器用推断出的模板参数来为我们实例化（instantiate）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新“实例”。</p><p><strong>模板类型参数</strong></p><p>类型参数前必须使用关键字class或typename</p><p><strong>非类型模板参数</strong></p><div class="note note-primary">            <p>非类型模板参数的模板实参必须是常量表达式。</p>          </div><p>除了定义类型参数，还可以在模板中定义非类型参数（nontype parameter）。一个非类型参数表示一个值而非一个类型。我们通过一个特定的类型名而非关键字class或typename来指定非类型参数。</p><p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式（参见2.4.4节，第58页），从而允许编译器在编译时实例化模板。</p><p>例如，我们可以编写一个compare版本处理字符串字面常量。这种字面常量是const char的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用（参见6.2.4节，第195页）。由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度</p><p><img src="/../images/C-C-Primer-Chapter-16/image-20241004124101870.png"></p><p>一个非类型参数可以是一个<strong>整型</strong>，或者是一个指向对象或函数类型的<strong>指针或（左值）引用</strong>。绑定到非类型整型参数的实参必须是一个<strong>常量表达式</strong>。绑定到指针或引用非类型参数的实参必须<strong>具有静态的生存期</strong>（参见第12章，第400页）。</p><p><strong>inline和constexpr的函数模板</strong></p><p>inline或constexpr说明符放在模板参数列表之后，返回类型之前</p><p><strong>编写类型无关的代码</strong></p><p>编写泛型代码的两个重要原则：</p><ul><li>模板中的函数参数是const的引用。（支持不能拷贝的对象，处理大对象时效率更高）</li><li>函数体中的条件判断仅使用&lt;比较运算。（降低对处理类型的要求）</li></ul><p><strong>模板编译</strong></p><p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。</p><p>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</p><p><strong>关键概念：模板和头文件</strong></p><p>模板包含两种名字：</p><ul><li>那些不依赖于模板参数的名字</li><li>那些依赖于模板参数的名字</li></ul><p>当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来保证的。而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的。</p><p>用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p><p>通过组织良好的程序结构，恰当使用头文件，这些要求都很容易满足。模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。</p><p><strong>大多数编译错误在实例化期间报告</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]值初始化和默认初始化</title>
    <link href="/2024/09/30/C-%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2024/09/30/C-%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>在C++中，初始化方式多种多样，其中<strong>值初始化（value initialization）</strong>和<strong>默认初始化（default initialization）</strong>是两种常见的初始化方式。它们之间的主要区别在于是否对变量赋初始值以及如何赋值。</p><h3 id="1-值初始化（Value-Initialization）"><a href="#1-值初始化（Value-Initialization）" class="headerlink" title="1. 值初始化（Value Initialization）"></a>1. <strong>值初始化（Value Initialization）</strong></h3><p>值初始化指的是将变量明确地初始化为零或空值。不同类型的数据会根据其类型被赋予“零值”：</p><ul><li>数值类型（如<code>int</code>、<code>float</code>、<code>double</code>）：初始化为<code>0</code>。</li><li>指针类型：初始化为<code>nullptr</code>。</li><li>用户自定义类类型：调用其默认构造函数（如果存在）。</li></ul><p>值初始化常通过以下方式实现：</p><ul><li><p>使用空的大括号<code>&#123;&#125;</code>或<code>()</code>初始化一个对象时：</p></li><li><p>对于类类型，如果类没有用户定义的构造函数，则成员会进行值初始化。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> printer = [](<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y, <span class="hljs-type">int</span> *p, A a, B b)&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>             &lt;&lt; <span class="hljs-string">&quot;y = &quot;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;p = &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;a.x = &quot;</span> &lt;&lt; a.x &lt;&lt; <span class="hljs-string">&quot; a.y = &quot;</span> &lt;&lt; a.y &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;b.x = &quot;</span> &lt;&lt; b.x &lt;&lt; <span class="hljs-string">&quot; b.y = &quot;</span> &lt;&lt; b.y &lt;&lt; endl;<br>    &#125;;<br>    <span class="hljs-comment">// 值初始化</span><br>    <span class="hljs-type">int</span> x&#123;&#125;; <span class="hljs-type">double</span> y&#123;&#125;;<br>    <span class="hljs-type">int</span> *p&#123;&#125;;<br>    A a&#123;&#125;; B b&#123;&#125;;<br>    <span class="hljs-built_in">printer</span>(x, y, p, a, b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src="/../images/C-%E5%80%BC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96/image-20240930111807883.png"></p><h3 id="2-默认初始化（Default-Initialization）"><a href="#2-默认初始化（Default-Initialization）" class="headerlink" title="2. 默认初始化（Default Initialization）"></a>2. <strong>默认初始化（Default Initialization）</strong></h3><p>默认初始化是指在变量定义时，如果没有显式地为其提供初始值，编译器会对它进行默认的处理。</p><ul><li>基本数据类型（如<code>int</code>、<code>float</code>）：不会进行任何初始化，可能包含未定义值（垃圾值）。</li><li>指针类型：也是未定义的，指针没有被初始化到<code>nullptr</code>。</li><li>类类型：如果类定义了默认构造函数，那么对象将调用这个构造函数。</li></ul><p>默认初始化常在以下情况下发生：</p><ul><li><p>通过不加括号或等号的方式声明对象：</p></li><li><p>对于类类型，如果类有用户定义的默认构造函数，则会调用这个构造函数，否则，类成员将默认初始化。</p></li></ul><p>在C++中，默认初始化和值初始化的行为可能在某些情况下看起来相同，但它们的底层机制却有所不同。你遇到的情况是，默认初始化和值初始化的结果相同，通常发生在以下几种场景下：</p><h3 id="3-全局变量和静态变量"><a href="#3-全局变量和静态变量" class="headerlink" title="3. 全局变量和静态变量"></a>3. <strong>全局变量和静态变量</strong></h3><p>在C++中，<strong>全局变量</strong>和<strong>静态变量</strong>总是被<strong>零初始化</strong>，无论你是否显式地对它们进行初始化。这意味着即使你使用默认初始化，它们也会被初始化为零值。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> global_var;  <span class="hljs-comment">// 全局变量，默认初始化为0</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> static_var;  <span class="hljs-comment">// 静态局部变量，默认初始化为0</span><br>    <span class="hljs-type">int</span> local_var;  <span class="hljs-comment">// 局部变量，默认初始化，未定义（垃圾值）</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情况下，全局变量<code>global_var</code>和静态变量<code>static_var</code>即使没有显式地进行值初始化，默认初始化时也会被设置为0。这是C++标准规定的。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 15</title>
    <link href="/2024/09/29/C-C-Primer-Chapter-15/"/>
    <url>/2024/09/29/C-C-Primer-Chapter-15/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象程序设计"><a href="#面向对象程序设计" class="headerlink" title="面向对象程序设计"></a>面向对象程序设计</h1><span id="more"></span><p>面向对象程序设计基于三个基本概念：数据抽象、继承和动态绑定。</p><p>继承和动态绑定对程序的编写有两方面的影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别。</p><h2 id="15-1-OOP：概述"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述</h2><p>面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的接口与实现分离（见第7章）；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。</p><p><strong>继承</strong></p><p>通过继承（inheritance）联系在一起的类构成一种层次关系。通常在层次关系的根部有一个<strong>基类（base class）</strong>，其他类则直接或间接地从基类继承而来，这些继承得到的类称为<strong>派生类（derived class）</strong>。基类负责定义在层次关系中所有类<strong>共同拥有的成员</strong>，而每个派生类定义各自<strong>特有的成员</strong>。</p><p>在C++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数（virtual function）</strong>。</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929224029399.png"></p><p>派生类必须通过使用<strong>类派生列表（class derivation list）</strong>明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929224100105.png"></p><p>派生类必须在其内部对所有重新定义的虚函数进行声明。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个<strong>override关键字</strong>。</p><p><strong>动态绑定</strong></p><div class="note note-primary">            <p>在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。</p>          </div><p>通过使用<strong>动态绑定（dynamic binding）</strong>，我们能用同一段代码分别处理Quote和Bulk_quote的对象。</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929224258001.png"></p><p>我们既能使用基类Quote的对象调用该函数，也能使用派生类Bulk_quote的对象调用它；又因为print_total是使用引用类型调用net_price函数的，所以出于15.2.1节（第528页）将要解释的原因，实际传入print_total的对象类型将决定到底执行net_price的哪个版本.</p><p>在上述过程中函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为<strong>运行时绑定（run-time binding）。</strong></p><h2 id="15-2-定义基类和派生类"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类</h2><h3 id="15-2-1-定义基类"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类</h3><div class="note note-primary">            <p>基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>          </div><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929224513032.png"></p><p><strong>成员函数与继承</strong></p><p>派生类可以继承其基类的成员，然而当遇到如net_price这样与类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以<strong>覆盖（override）</strong>从基类继承而来的旧定义。</p><p>在C++语言中，基类必须将它的两种成员函数区分开来：</p><ul><li>一种是基类希望其派生类进行覆盖的函数；</li><li>另一种是基类希望派生类直接继承而不要改变的函数。</li></ul><p>对于前者，基类通常将其定义为虚函数（virtual）。当我们使用指针或引用调用虚函数时，该调用将被动态绑定。</p><p>任何<strong>构造函数之外的非静态函数</strong>（参见7.6节，第268页）都可以是虚函数。关键字virtual<strong>只能出现在类内部的声明语句之前</strong>而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</p><p>成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。</p><p><strong>访问控制与继承</strong></p><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，<strong>派生类能访问公有成员，而不能访问私有成员。</strong>不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用<strong>受保护的（protected）</strong>访问运算符说明这样的成员。</p><h3 id="15-2-2-定义派生类"><a href="#15-2-2-定义派生类" class="headerlink" title="15.2.2 定义派生类"></a>15.2.2 定义派生类</h3><p>派生类必须通过使用类派生列表（class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：public、protected或者private。</p><p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明。</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929225239979.png"></p><p><strong>派生类中的虚函数</strong></p><p>派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p><p>派生类可以在它覆盖的函数前使用virtual关键字，但不是非得这么做。我们将在15.3节（第538页）介绍其原因，C++11新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是</p><ul><li>在形参列表后面</li><li>或者在const成员函数（参见7.1.2节，第231页）的const关键字后面</li><li>或者在引用成员函数（参见13.6.3节，第483页）的引用限定符后面</li></ul><p>添加一个关键字override。</p><p><strong>派生类对象及派生类向基类的类型转换</strong></p><div class="note note-primary">            <p>在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。</p>          </div><p>一个派生类对象包含多个组成部分：一个含有派生类自己定义的（非静态）成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。</p><p>C++标准并没有明确规定派生类的对象在内存中如何分布，但是我们可以认为Bulk_quote的对象包含如图15.1所示的两部分。</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929225929820.png"></p><p>因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为<strong>派生类到基类的（derived-to-base）类型转换。</strong></p><p><strong>派生类构造函数</strong></p><div class="note note-primary">            <p>每个类控制它自己的成员初始化过程。</p>          </div><div class="note note-primary">            <p>首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p>          </div><p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p><p><strong>派生类使用基类的成员</strong></p><p>派生类可以访问基类的公有成员和受保护成员</p><p><strong>关键概念：遵循基类的接口</strong></p><p>必须明确一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。</p><p>因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p><p><strong>继承与静态成员</strong></p><p>如果基类定义了一个静态成员（参见7.6节，第268页），则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</p><p>静态成员遵循通用的访问控制规则，如果基类中的成员是private的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它</p><p><strong>派生类的声明</strong></p><p>派生类的声明与其他类差别不大（参见7.3.3节，第250页），声明中包含类名但是不包含它的派生列表。</p><p><strong>被用作基类的类</strong></p><p>如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p><p><strong>防止继承的发生</strong></p><p>有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。为了实现这一目的，C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个<strong>关键字final</strong></p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929230835841.png"></p><h3 id="15-2-3-类型转换与继承"><a href="#15-2-3-类型转换与继承" class="headerlink" title="15.2.3 类型转换与继承"></a>15.2.3 类型转换与继承</h3><p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p><div class="note note-primary">            <p>和内置指针一样，智能指针类（参见12.1节，第400页）也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内</p>          </div><p><strong>静态类型与动态类型</strong></p><p>表达式的<strong>静态类型</strong>在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；<strong>动态类型</strong>则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</p><p>例如，当print_total调用net_price时，我们知道item的静态类型是Quote&amp;，它的动态类型则依赖于item绑定的实参，动态类型直到在运行时调用该函数时才会知道。如果我们传递一个Bulk_quote对象给print_total，则item的静态类型将与它的动态类型不一致。</p><p><strong>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</strong></p><p><strong>不存在从基类向派生类的隐式类型转换</strong></p><p>编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast（参见19.2.1节，第730页）请求一个类型转换，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用static_cast（参见4.11.3节，第144页）来强制覆盖掉编译器的检查工作。</p><p><strong>在对象之间不存在类型转换</strong></p><div class="note note-primary">            <p>当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>          </div><p>派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。</p><h2 id="15-3-虚函数"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数</h2><p>当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。</p><p>通常情况下，如果我们不使用某个函数，则无须为该函数提供定义（参见6.1.2节，第186页）。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。</p><p><strong>对虚函数的调用可能在运行时才被解析</strong></p><p>动态绑定只有当我们通过指针或引用调用虚函数时才会发生。当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。</p><p><strong>关键概念：C++的多态性</strong></p><p>OOP的核心思想是多态性（polymorphism）。把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式”而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本所在。</p><p><strong>派生类中的虚函数</strong></p><p>当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。然而这么做并非必须，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。</p><p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。</p><p>同样，派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果D由B派生得到，则基类的虚函数可以返回B＊而派生类的对应函数可以返回D＊，只不过这样的返回类型要求从D到B的类型转换是可访问的。</p><p><strong>final和override说明符</strong></p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929232926332.png"></p><p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。</p><p>在C++11新标准中我们可以使用override关键字来说明派生类中的虚函数。这么做的好处是在使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误，后者在编程实践中显得更加重要。如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。</p><p>还能把某个函数指定为final，如果我们已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误。</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929232944340.png"></p><p>final和override说明符出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型（参见6.3.3节，第206页）之后。</p><p><strong>虚函数与默认实参</strong></p><div class="note note-primary">            <p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>          </div><p>虚函数也可以拥有默认实参（参见6.5.1节，第211页）。如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。换句话说，如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</p><p><strong>回避虚函数的机制</strong></p><p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929233126493.png"></p><p>通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。</p><p>什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。</p><div class="note note-warning">            <p>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。</p>          </div><h2 id="15-4-抽象基类"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类</h2><p><strong>纯虚函数</strong></p><p>可以将net_price定义成<strong>纯虚（pure virtual）函数</strong>从而令程序实现我们的设计意图，这样做可以清晰明了地告诉用户当前这个net_price函数是没有实际意义的。和普通的虚函数不一样，一个纯虚函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写&#x3D;0就可以将一个虚函数说明为纯虚函数。其中，&#x3D;0只能出现在类内部的虚函数声明语句处</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929233710084.png"></p><p>尽管我们不能直接定义这个类的对象，但是Disc_quote的派生类构造函数将会使用Disc_quote的构造函数来构建各个派生类对象的Disc_quote部分。</p><p>值得注意的是，我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个&#x3D;0的函数提供函数体。</p><p><strong>含有纯虚函数的类是抽象基类</strong></p><p>含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。我们不能（直接）创建一个抽象基类的对象。因为Disc_quote将net_price定义成了纯虚函数，所以我们不能定义Disc_quote的对象。我们可以定义Disc_quote的派生类的对象，前提是这些类覆盖了net_price函数。</p><p>Disc_quote的派生类必须给出自己的net_price定义，否则它们仍将是抽象基类。</p><p><strong>派生类构造函数只初始化它的直接基类</strong></p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929233925603.png"></p><p>这个版本的Bulk_quote的直接基类是Disc_quote，间接基类是Quote。每个Bulk_quote对象包含三个子对象：一个（空的）Bulk_quote部分、一个Disc_quote子对象和一个Quote子对象。该构造函数将它的实参传递给Disc_quote的构造函数，随后Disc_quote的构造函数继续调用Quote的构造函数。Quote的构造函数首先初始化bulk的bookNo和price成员，当Quote的构造函数结束后，开始运行Disc_quote的构造函数并初始化quantity和discount成员，最后运行Bulk_quote的构造函数，该函数无须执行实际的初始化或其他工作。</p><p><strong>关键概念：重构</strong></p><p>在Quote的继承体系中增加Disc_quote类是重构（refactoring）的一个典型示例。重构负责重新设计类的体系以便将操作和&#x2F;或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很普遍的现象。</p><p>值得注意的是，即使我们改变了整个继承体系，那些使用了Bulk_quote或Quote的代码也无须进行任何改动。不过一旦类被重构（或以其他方式被改变），就意味着我们必须重新编译含有这些类的代码了。</p><p><strong>受保护的成员</strong></p><p>一个类使用protected关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。</p><ul><li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的。</li><li>和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。</li><li>此外，protected还有另外一条重要的性质。派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。</li></ul><p>为了理解最后一条规则，请考虑如下的例子</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929234449633.png"></p><p>如果派生类（及其友元）能访问基类对象的受保护成员，则上面的第二个clobber（接受一个Base&amp;）将是合法的。该函数不是Base的友元，但是它仍然能够改变一个Base对象的内容。如果按照这样的思路，则我们只要定义一个形如Sneaky 的新类就能非常简单地规避掉protected提供的访问保护了。</p><p>要想阻止以上的用法，我们就要做出如下规定，即派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。</p><p><strong>公有、私有和受保护继承</strong></p><p>某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。</p><p>派生访问说明符对于<strong>派生类的成员（及友元）</strong>能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。</p><p>派生访问说明符的目的是<strong>控制派生类用户（包括派生类的派生类在内）</strong>对于基类成员的访问权限。</p><p><strong>派生类向基类转换的可访问性</strong></p><p>派生类向基类的转换（参见15.2.2节，第530页）是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定D继承自B：</p><ul><li>只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换。</li><li>不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。</li><li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有的，则不能使用。</li></ul><p><strong>关键概念：类的设计与受保护的成员</strong></p><p>不考虑继承的话，我们可以认为一个类有两种不同的用户：普通用户和类的实现者。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。</p><p>如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p><p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。</p><p><strong>友元与继承</strong></p><p>基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929235349712.png"></p><p>Pal是Base的友元，所以Pal能够访问Base对象的成员，这种可访问性包括了Base对象内嵌在其派生类对象中的情况。</p><p><strong>改变个别成员的可访问性</strong></p><p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用using声明（参见3.1节，第74页）可以达到这一目的</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240929235518822.png"></p><p>因为Derived使用了私有继承，所以继承而来的成员size和n（在默认情况下）是Derived的私有成员。然而，我们使用using声明语句改变了这些成员的可访问性。改变之后，Derived的用户将可以使用size成员，而Derived的派生类将能使用n。</p><p>通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。</p><div class="note note-primary">            <p>派生类只能为那些它可以访问的名字提供using声明。</p>          </div><p><strong>默认的继承保护级别</strong></p><p>默认情况下，使用class关键字定义的派生类是私有继承的；而使用struct关键字定义的派生类是公有继承的。</p><h2 id="15-6-继承中的类作用域"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域</h2><p>每个类定义自己的作用域（参见7.4节，第253页），在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套（参见2.2.4节，第43页）在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。</p><p><strong>在编译时进行名字查找</strong></p><p>一个对象、引用或指针的静态类型（参见15.2.3节，第532页）决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。</p><p><strong>名字冲突与继承</strong></p><p>和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字（参见2.2.4节，第43页）</p><p><strong>通过作用域运算符来使用隐藏的成员</strong></p><p>可以通过作用域运算符来使用一个被隐藏的基类成员</p><div class="note note-primary">            <p>除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>          </div><p><strong>关键概念：名字查找与继承</strong></p><p>理解函数调用的解析过程对于理解C++的继承至关重要，假定我们调用p-&gt;mem（）（或者obj.mem（）），则依次执行以下4个步骤：</p><ol><li>首先确定p（或obj）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型。</li><li>在p（或obj）的静态类型对应的类中查找mem。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。</li><li>一旦找到了mem，就进行常规的类型检查（参见6.1节，第183页）以确认对于当前找到的mem，本次调用是否合法。</li><li>假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：<ul><li>如果mem是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型。</li><li>反之，如果mem不是虚函数或者我们是通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用。</li></ul></li></ol><p><strong>一如往常，名字查找先于类型检查</strong></p><p>声明在内层作用域的函数并不会重载声明在外层作用域的函数（参见6.4.1节，第210页）。因此，定义派生类中的函数也不会重载其基类中的成员。</p><p><strong>虚函数与作用域</strong></p><p>我们现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了（参见15.3节，第537页）。假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240930103221575.png"></p><p><strong>覆盖重载的函数</strong></p><p>成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。</p><p>有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其烦琐。</p><p>一种好的解决方案是为重载的成员提供一条using声明语句（参见15.5节，第546页），这样我们就无须覆盖基类中的每一个重载版本了。using声明语句指定一个名字而不指定形参列表，所以一条基类成员函数的using声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义。</p><p>类内using声明的一般规则同样适用于重载函数的名字（参见15.5节，第546页）；基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是对using声明点的访问。</p><h2 id="15-7-构造函数与拷贝控制"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制</h2><h3 id="15-7-1-虚析构函数"><a href="#15-7-1-虚析构函数" class="headerlink" title="15.7.1 虚析构函数"></a>15.7.1 虚析构函数</h3><p>继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数（参见15.2.1节，第528页），这样我们就能动态分配继承体系中的对象了。</p><p>因为指针或者引用的静态类型可能与实际指向对象的动态类型不一致，所以析构函数应该被声明为虚函数，这样在析构的时候可以动态绑定，执行动态类型的析构函数，以确保析构正确。</p><p><strong>虚析构函数将阻止合成移动操作</strong></p><p>基类需要一个虚析构函数这一事实还会对基类和派生类的定义产生另外一个间接的影响：如果一个类定义了析构函数，即使它通过&#x3D;default的形式使用了合成的版本，编译器也不会为这个类合成移动操作（参见13.6.2节，第475页）。</p><h3 id="15-7-2-合成拷贝控制与继承"><a href="#15-7-2-合成拷贝控制与继承" class="headerlink" title="15.7.2 合成拷贝控制与继承"></a>15.7.2 合成拷贝控制与继承</h3><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。</p><p><strong>派生类中删除的拷贝控制与基类的关系</strong></p><p>就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数（参见13.1.6节，第450页和13.6.2节，第475页）。</p><p>此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数：</p><ul><li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问（参见15.5节，第543页），则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。</li><li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。</li><li>和过去一样，编译器将不会合成一个删除掉的移动操作。当我们使用&#x3D;default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。</li></ul><p><strong>移动操作与继承</strong></p><p>大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p><p>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的Quote可以使用合成的版本，不过前提是Quote必须显式地定义这些成员。一旦Quote定义了自己的移动操作，那么它必须同时显式地定义拷贝操作。</p><h3 id="15-7-3-派生类的拷贝控制成员"><a href="#15-7-3-派生类的拷贝控制成员" class="headerlink" title="15.7.3 派生类的拷贝控制成员"></a>15.7.3 派生类的拷贝控制成员</h3><p>派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。析构函数只负责销毁派生类自己分配的资源。</p><p><strong>定义派生类的拷贝或移动构造函数</strong></p><p>当为派生类定义拷贝或移动构造函数时（参见13.1.1节，第440页和13.6.2节，第473页），我们通常使用对应的基类构造函数初始化对象的基类部分</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240930105340630.png"></p><div class="note note-warning">            <p>在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。</p>          </div><p><strong>派生类赋值运算符</strong></p><p>与拷贝和移动构造函数一样，派生类的赋值运算符（参见13.1.2节，第443页和13.6.2节，第474页）也必须显式地为其基类部分赋值</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240930105530059.png"></p><p><strong>派生类析构函数</strong></p><p>对象的基类部分是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源。</p><p>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。</p><p><strong>在构造函数和析构函数中调用虚函数</strong></p><p>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p><h3 id="15-7-4-继承的构造函数"><a href="#15-7-4-继承的构造函数" class="headerlink" title="15.7.4 继承的构造函数"></a>15.7.4 继承的构造函数</h3><p>在C++11新标准中，派生类能够重用其直接基类定义的构造函数。尽管如我们所知，这些构造函数并非以常规的方式继承而来，但是为了方便，我们不妨姑且称其为“继承”的。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。</p><p>类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。</p><p>派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的using声明语句。</p><p><img src="/../images/C-C-Primer-Chapter-15/image-20240930110151289.png"></p><p>通常情况下，using声明语句只是令某个名字在当前作用域内可见。而当作用于构造函数时，using声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p><p>如果派生类含有自己的数据成员，则这些成员将被默认初始化（参见7.1.4节，第238页）。</p><p><strong>继承的构造函数的特点</strong></p><p>和普通成员的using声明不一样，一个构造函数的using声明不会改变该构造函数的访问级别。例如，不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则。</p><p>而且，一个using声明语句不能指定explicit或constexpr。如果基类的构造函数是explicit（参见7.5.4节，第265页）或者constexpr（参见7.5.6节，第267页），则继承的构造函数也拥有相同的属性。</p><p>当一个基类构造函数含有默认实参（参见6.5.1节，第211页）时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</p><p>如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。</p><ul><li>第一个例外是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。</li><li>第二个例外是默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。</li></ul><h2 id="15-8-容器与继承"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承</h2><p>当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不允许在容器中保存不同类型的元素，所以我们不能把具有继承关系的多种类型的对象直接存放在容器当中。</p><p><strong>在容器中放置（智能）指针而非对象</strong></p><p>当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针（参见12.1节，第400页））。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[算法]快速幂算法</title>
    <link href="/2024/09/28/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/28/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h1><span id="more"></span><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1 题目"></a>1 题目</h2><p>设$a$是一个给定实数，计算$a^n$，其中$n$是自然数。</p><h2 id="2-解法"><a href="#2-解法" class="headerlink" title="2 解法"></a>2 解法</h2><h3 id="2-1-暴力解"><a href="#2-1-暴力解" class="headerlink" title="2.1 暴力解"></a>2.1 暴力解</h3><p>暴力解比较直观，直接对$a$进行$n-1$次相乘即可。</p><p>时间复杂度为$O(n)$.</p><h3 id="2-2-快速幂-递归"><a href="#2-2-快速幂-递归" class="headerlink" title="2.2 快速幂-递归"></a>2.2 快速幂-递归</h3><p>考虑分治的方法，首先将问题规约为一个更小的子问题，计算$a^{n&#x2F;2}$，计算出的结果只需要在相乘一次即可得到原问题的解。这里需要对$n$的奇偶性进行分情况讨论，如下所示：<br>$$<br>\begin{align}<br>    &amp; a^n &#x3D; a^{n &#x2F; 2} \times a^{n &#x2F; 2} \qquad n为偶数 \\<br>    &amp; a^n &#x3D; a^{(n - 1) &#x2F; 2} \times a^{(n - 1) &#x2F; 2} \times a \qquad n为奇数<br>\end{align}<br>$$<br><strong>时间复杂度</strong></p><p>该递归算法的递推方程为<br>$$<br>W(n) &#x3D;<br>\begin{cases}<br>    &amp; W(n&#x2F;2) + O(1) \\<br>    &amp; W(1) &#x3D; 0<br>\end{cases}<br>$$<br>该递推方程符合主定理的第二种情况，由此可得该算法在最坏情况下的时间复杂度$W(n) &#x3D; O(logn)$.</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fastExponentiation</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">unsigned</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">fastExponentiation</span>(a, n / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> result * result;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> result * result * a;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-快速幂-迭代"><a href="#2-3-快速幂-迭代" class="headerlink" title="2.3 快速幂-迭代"></a>2.3 快速幂-迭代</h3><p>观察递归版本，对于$a^{10}$，我们发现，快速幂计算$a^{10}$的过程如下：<br>$$<br>a^{10} &#x3D; (a^5)^2 &#x3D; (a^2 * a^3)^2 &#x3D; ((a * a)^2 * a)^2<br>$$<br>因为两个同底的幂相乘可以转换为指数相加，因此为了计算$a^n$，我们只需要求出一个序列$d_n &#x3D; [d1, d2, …, d_k]$，使得${\Sigma_{i&#x3D;1}^{k}d_i} &#x3D; n$，如此，我们可以通过求解$a^{d_i}$，并将所有结果累乘获得原问题的解。</p><p>那么，如何求得这个序列$d_n$呢？最简单的方法是将$n$表示成二进制形式，所有二进制位为1的权组成的集合即我们要求的$d_n$.</p><p><strong>时间复杂度</strong></p><p>我们将求解过程融入到求一个数的二进制表示的过程中，因此最坏时间复杂度为$W(n) &#x3D; O(logn)$，</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">fastExponentiation</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">unsigned</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">unsigned</span> bit = <span class="hljs-number">0</span>;  <br>    <span class="hljs-type">double</span> res = <span class="hljs-number">1</span>;    <br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        bit = n % <span class="hljs-number">2</span>;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (bit) res *= a;<br>        a *= a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-扩展"><a href="#3-扩展" class="headerlink" title="3 扩展"></a>3 扩展</h2><p>该思想可以用于求解Fibonacci数列。</p><p><strong>定理</strong></p><p>设$Fn$为第$n$个Fibonacci数，那么有</p><p><img src="/../images/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/image-20240928232343898.png"></p><p>通过数学归纳法可以证明上述定理。</p><p>由定理，我们可以将计算Fibonacci数转换为矩阵的$n$次幂，因为计算二阶矩阵相乘只需要8次乘法，即常数时间，因此我们可以优化求Fibonacci数的算法时间复杂度到$O(logn)$.</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>分治算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[算法]分治策略</title>
    <link href="/2024/09/28/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"/>
    <url>/2024/09/28/%E7%AE%97%E6%B3%95-%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h1><span id="more"></span><h2 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1 基本思想"></a>1 基本思想</h2><p>将规模为n的原问题规约为规模更小的一个或多个子问题，递归或迭代求解每个子问题，然后把子问题的解进行综合，从而得到原问题的解。</p><p>需要注意：</p><ol><li>子问题与原问题性质完全一致</li><li>子问题之间可以彼此独立的求解</li><li>递归停止时的子问题可以直接求解（常数时间）</li><li>当子问题划分比较均匀的时候，时间复杂度相对较低</li></ol><p><strong>一般分治算法伪代码描述</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pseudocode">if |P| &lt;= c then S(p)                   // 递归出口 小规模的问题直接求解<br>divide P into P1, P2, ..., Pk// 规约为k个子问题<br>for i = 1 to k do<br>yi &lt;- Divide-and-Conquer(Pi)// 递归求解子问题<br>return Merge(y1, y2, ..., yk)           // 综合子问题的解<br></code></pre></td></tr></table></figure><h2 id="2-分析技术"><a href="#2-分析技术" class="headerlink" title="2 分析技术"></a>2 分析技术</h2><p>分治算法通常是递归算法，分析时间复杂度需要求解递推方程，常见的递推方程有以下两类：<br>$$<br>\begin{aligned}<br>    &amp; T\left(n\right)&#x3D;\sum_{i&#x3D;1}^{k}a_{i}T\left(n-i\right)+f\left(n\right) \\<br>    &amp; T\left(n\right)&#x3D;aT\left(\frac{n}{b}\right)+d\left(n\right)<br>\end{aligned}<br>$$<br>对于第一类方程，可以使用迭代、递归树、尝试法求解；</p><p>对于第二类方程，可以使用迭代、递归树、主定理法求解；</p><h3 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h3><p>$$<br>\begin{align}<br>    a \geq 1, b &gt; 1 为常数，f(n)为函数，T(n)为非负整数，且T(n)&#x3D;aT(n&#x2F;b)+f(n)<br>\end{align}<br>$$</p><p>$$<br>\begin{align}<br> &amp; \qquad(1)若 f(n)&#x3D;O(n^{\log_ba-\varepsilon}),\varepsilon&gt;0,<br>     则 T(n)&#x3D;\Theta(n^{\log_ba}). \\<br> &amp; \qquad(2)若 f(n)&#x3D;\Theta(n^{\log_ba}),<br>    则 T(n)&#x3D;\Theta(n^{\log_ba}\operatorname{log}n).  \\<br> &amp; \qquad(3)若 f(n)&#x3D;\Omega(n^{\log_ba+\varepsilon}),\varepsilon&gt;0, 且对于某个常数c和所有充分大的n, 有 af(n&#x2F;b)\leqslant cf(n), 则 T(n)&#x3D;\Theta(f(n)).<br>\end{align}<br>$$</p><h2 id="3-改进分治算法的途径"><a href="#3-改进分治算法的途径" class="headerlink" title="3 改进分治算法的途径"></a>3 改进分治算法的途径</h2><p>改进算法主要有两种途径：</p><ol><li>减少子问题个数</li><li>通过预处理减少递归过程中的工作量</li></ol><h3 id="3-1-通过代数变换减少子问题个数"><a href="#3-1-通过代数变换减少子问题个数" class="headerlink" title="3.1 通过代数变换减少子问题个数"></a>3.1 通过代数变换减少子问题个数</h3><p>这种方法主要思想是有的子问题的解可以通过简单的计算由其他子问题的解获得，那么该子问题就不必递归求解，由此减少了子问题的个数。</p><p>例子：</p><ol><li>整数乘法</li><li>Strassen矩阵乘法</li></ol><h3 id="3-2-利用预处理减少递归内部的计算量"><a href="#3-2-利用预处理减少递归内部的计算量" class="headerlink" title="3.2 利用预处理减少递归内部的计算量"></a>3.2 利用预处理减少递归内部的计算量</h3><p>这种方法的主要思想是通过预处理，减少递归内部的计算量，从而达到优化算法的目的。</p><p>例子：平面上最邻近点对</p><h2 id="4-典型实例"><a href="#4-典型实例" class="headerlink" title="4 典型实例"></a>4 典型实例</h2><p><a href="https://erlsrnby04.github.io/2024/09/28/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95/">快速幂算法</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
      <category>分治算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>分治</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[内核赛]系统调用实现</title>
    <link href="/2024/09/28/%E5%86%85%E6%A0%B8%E8%B5%9B-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/09/28/%E5%86%85%E6%A0%B8%E8%B5%9B-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="系统调用实现"><a href="#系统调用实现" class="headerlink" title="系统调用实现"></a>系统调用实现</h1><span id="more"></span><h1 id="系统调用的说明以及调用方式"><a href="#系统调用的说明以及调用方式" class="headerlink" title="系统调用的说明以及调用方式"></a>系统调用的说明以及调用方式</h1><p>系统调用方式遵循RISC-V ABI,即调用号存放在a7寄存器中,6个参数分别储存在a0-a5寄存器<br>中,返回值保存在a0中。</p><p>主要参考了Linux 5.10 syscalls，详细请参见：<a href="https://man7.org/linux/man-pages/man2/syscalls.2.html">https://man7.org/linux/man-pages/man2/syscalls.2.html</a></p><h2 id="如何添加一个系统调用"><a href="#如何添加一个系统调用" class="headerlink" title="如何添加一个系统调用"></a>如何添加一个系统调用</h2><ol><li>在user.h文件中添加系统调用封装后的函数声明</li><li>在usys.pl文件中添加一个entry</li><li>在syscall.h中添加对应的宏</li><li>在syscall.c中添加函数的声明，并更新系统调用表</li><li>根据功能，选择一个合适的内核模块，进行实现。</li></ol><h2 id="文件系统相关"><a href="#文件系统相关" class="headerlink" title="文件系统相关"></a>文件系统相关</h2><h3 id="define-SYS-getcwd-17（10-17）"><a href="#define-SYS-getcwd-17（10-17）" class="headerlink" title="#define SYS_getcwd 17（10.17）"></a>#define SYS_getcwd 17（10.17）</h3><p>功能：获取当前工作目录；</p><p>输入：</p><ul><li><p>char *buf：一块缓存区，用于保存当前工作目录的字符串。当buf设为NULL，由系统来分配缓存区。</p></li><li><p>size：buf缓存区的大小。</p></li></ul><p>返回值：成功执行，则返回当前工作目录的字符串的指针。失败，则返回NULL。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size;<br><span class="hljs-type">long</span> ret = syscall(SYS_getcwd, buf, size);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-pipe2-59-10-29"><a href="#define-SYS-pipe2-59-10-29" class="headerlink" title="#define SYS_pipe2 59 (10.29)"></a>#define SYS_pipe2 59 (10.29)</h3><p>功能：创建管道；</p><p>输入：</p><ul><li>fd[2]：用于保存2个文件描述符。其中，fd[0]为管道的读出端，fd[1]为管道的写入端。</li></ul><p>返回值：成功执行，返回0。失败，返回-1。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> fd[<span class="hljs-number">2</span>]<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">syscall</span>(SYS_pipe2, fd, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="define-SYS-dup-23-10-29"><a href="#define-SYS-dup-23-10-29" class="headerlink" title="#define SYS_dup 23 (10.29)"></a>#define SYS_dup 23 (10.29)</h3><p>功能：复制文件描述符；</p><p>输入：</p><ul><li>fd：被复制的文件描述符。</li></ul><p>返回值：成功执行，返回新的文件描述符。失败，返回-1。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> fd<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">syscall</span>(SYS_dup, fd)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="define-SYS-dup3-24-10-29"><a href="#define-SYS-dup3-24-10-29" class="headerlink" title="#define SYS_dup3 24 (10.29)"></a>#define SYS_dup3 24 (10.29)</h3><p>功能：复制文件描述符，并指定了新的文件描述符；</p><p>输入：</p><ul><li>old：被复制的文件描述符。</li><li>new：新的文件描述符。</li></ul><p>返回值：成功执行，返回新的文件描述符。失败，返回-1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">int</span> <span class="hljs-keyword">old</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">new</span>;<br><span class="hljs-type">int</span> ret <span class="hljs-operator">=</span> syscall(SYS_dup3, <span class="hljs-keyword">old</span>, <span class="hljs-keyword">new</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-chdir-49-（10-29）"><a href="#define-SYS-chdir-49-（10-29）" class="headerlink" title="#define SYS_chdir 49 （10.29）"></a>#define SYS_chdir 49 （10.29）</h3><p>功能：切换工作目录；</p><p>输入：</p><ul><li>path：需要切换到的目录。</li></ul><p>返回值：成功执行，返回0。失败，返回-1。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const <span class="hljs-type">char</span> *<span class="hljs-type">path</span>;<br><span class="hljs-type">int</span> ret = syscall(SYS_chdir, <span class="hljs-type">path</span>);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-openat-56-（10-29）"><a href="#define-SYS-openat-56-（10-29）" class="headerlink" title="#define SYS_openat 56 （10.29）"></a>#define SYS_openat 56 （10.29）</h3><p>功能：打开或创建一个文件；</p><p>输入：</p><ul><li><p>fd：文件所在目录的文件描述符。</p></li><li><p>filename：要打开或创建的文件名。如为绝对路径，则忽略fd。如为相对路径，且fd是AT_FDCWD，则filename是相对于当前工作目录来说的。如为相对路径，且fd是一个文件描述符，则filename是相对于fd所指向的目录来说的。</p></li><li><p>flags：必须包含如下访问模式的其中一种：O_RDONLY，O_WRONLY，O_RDWR。还可以包含文件创建标志和文件状态标志。</p></li><li><p>mode：文件的所有权描述。详见<code>man 7 inode </code>。</p></li></ul><p>返回值：成功执行，返回新的文件描述符。失败，返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">syscall</span>(SYS_openat, fd, filename, flags, mode);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-close-57-（10-29）"><a href="#define-SYS-close-57-（10-29）" class="headerlink" title="#define SYS_close 57 （10.29）"></a>#define SYS_close 57 （10.29）</h3><p>功能：关闭一个文件描述符；</p><p>输入：</p><ul><li>fd：要关闭的文件描述符。</li></ul><p>返回值：成功执行，返回0。失败，返回-1。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> fd<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">syscall</span>(SYS_close, fd)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="define-SYS-getdents64-61-12-11"><a href="#define-SYS-getdents64-61-12-11" class="headerlink" title="#define SYS_getdents64 61 (12.11)"></a>#define SYS_getdents64 61 (12.11)</h3><p>功能：获取目录的条目;</p><p>输入：</p><ul><li><p>fd：所要读取目录的文件描述符。</p></li><li><p>buf：一个缓存区，用于保存所读取目录的信息。缓存区的结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> &#123;</span><br>    uint64 d_ino;<span class="hljs-comment">// 索引结点号</span><br>    int64 d_off;<span class="hljs-comment">// 到下一个dirent的偏移</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> d_reclen;<span class="hljs-comment">// 当前dirent的长度</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> d_type;<span class="hljs-comment">// 文件类型</span><br>    <span class="hljs-type">char</span> d_name[];<span class="hljs-comment">//文件名</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>len：buf的大小。</p></li></ul><p>返回值：成功执行，返回读取的字节数。当到目录结尾，则返回0。失败，则返回-1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> dirent *buf, size_t <span class="hljs-built_in">len</span><br><span class="hljs-type">int</span> ret = syscall(SYS_getdents64, fd, buf, <span class="hljs-built_in">len</span>);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-read-63-（10-29）"><a href="#define-SYS-read-63-（10-29）" class="headerlink" title="#define SYS_read 63 （10.29）"></a>#define SYS_read 63 （10.29）</h3><p>功能：从一个文件描述符中读取；</p><p>输入：</p><ul><li>fd：要读取文件的文件描述符。</li><li>buf：一个缓存区，用于存放读取的内容。</li><li>count：要读取的字节数。</li></ul><p>返回值：成功执行，返回读取的字节数。如为0，表示文件结束。错误，则返回-1。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">int fd, void *<span class="hljs-keyword">buf, </span>size_t <span class="hljs-built_in">count</span>;<br>ssize_t ret = <span class="hljs-keyword">syscall(SYS_read, </span>fd, <span class="hljs-keyword">buf, </span><span class="hljs-built_in">count</span>);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-write-64-（10-29）"><a href="#define-SYS-write-64-（10-29）" class="headerlink" title="#define SYS_write 64 （10.29）"></a>#define SYS_write 64 （10.29）</h3><p>功能：从一个文件描述符中写入；</p><p>输入：</p><ul><li>fd：要写入文件的文件描述符。</li><li>buf：一个缓存区，用于存放要写入的内容。</li><li>count：要写入的字节数。</li></ul><p>返回值：成功执行，返回写入的字节数。错误，则返回-1。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count;<br><span class="hljs-type">ssize_t</span> ret = <span class="hljs-built_in">syscall</span>(SYS_write, fd, buf, count);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-linkat-37-12-13"><a href="#define-SYS-linkat-37-12-13" class="headerlink" title="#define SYS_linkat 37 (12.13)"></a>#define SYS_linkat 37 (12.13)</h3><p>功能：创建文件的链接；</p><p>输入：</p><ul><li>olddirfd：原来的文件所在目录的文件描述符。</li><li>oldpath：文件原来的名字。如果oldpath是相对路径，则它是相对于olddirfd目录而言的。如果oldpath是相对路径，且olddirfd的值为AT_FDCWD，则它是相对于当前路径而言的。如果oldpath是绝对路径，则olddirfd被忽略。</li><li>newdirfd：新文件名所在的目录。</li><li>newpath：文件的新名字。newpath的使用规则同oldpath。</li><li>flags：在2.6.18内核之前，应置为0。其它的值详见<code>man 2 linkat</code>。</li></ul><p>返回值：成功执行，返回0。失败，返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> olddirfd, <span class="hljs-type">char</span> *oldpath, <span class="hljs-type">int</span> newdirfd, <span class="hljs-type">char</span> *newpath, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">syscall</span>(SYS_linkat, olddirfd, oldpath, newdirfd, newpath, flags);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-unlinkat-35-12-13"><a href="#define-SYS-unlinkat-35-12-13" class="headerlink" title="#define SYS_unlinkat 35 (12.13)"></a>#define SYS_unlinkat 35 (12.13)</h3><p>功能：移除指定文件的链接(可用于删除文件)；</p><p>输入：</p><ul><li>dirfd：要删除的链接所在的目录。</li><li>path：要删除的链接的名字。如果path是相对路径，则它是相对于dirfd目录而言的。如果path是相对路径，且dirfd的值为AT_FDCWD，则它是相对于当前路径而言的。如果path是绝对路径，则dirfd被忽略。</li><li>flags：可设置为0或AT_REMOVEDIR。</li></ul><p>返回值：成功执行，返回0。失败，返回-1。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> dirfd, <span class="hljs-type">char</span> *<span class="hljs-type">path</span>, unsigned <span class="hljs-type">int</span> flags;<br>syscall(SYS_unlinkat, dirfd, <span class="hljs-type">path</span>, flags);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-mkdirat-34-（10-29）"><a href="#define-SYS-mkdirat-34-（10-29）" class="headerlink" title="#define SYS_mkdirat 34 （10.29）"></a>#define SYS_mkdirat 34 （10.29）</h3><p>功能：创建目录；</p><p>输入：</p><ul><li>dirfd：要创建的目录所在的目录的文件描述符。</li><li>path：要创建的目录的名称。如果path是相对路径，则它是相对于dirfd目录而言的。如果path是相对路径，且dirfd的值为AT_FDCWD，则它是相对于当前路径而言的。如果path是绝对路径，则dirfd被忽略。</li><li>mode：文件的所有权描述。详见<code>man 7 inode </code>。</li></ul><p>返回值：成功执行，返回0。失败，返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dirfd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">mode_t</span> mode;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">syscall</span>(SYS_mkdirat, dirfd, path, mode);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-umount2-39"><a href="#define-SYS-umount2-39" class="headerlink" title="#define SYS_umount2 39"></a>#define SYS_umount2 39</h3><ul><li>功能：卸载文件系统；</li><li>输入：指定卸载目录，卸载参数；</li><li>返回值：成功返回0，失败返回-1；</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *special, <span class="hljs-type">int</span> flags;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">syscall</span>(SYS_umount2, special, flags);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-mount-40"><a href="#define-SYS-mount-40" class="headerlink" title="#define SYS_mount 40"></a>#define SYS_mount 40</h3><ul><li>功能：挂载文件系统；</li><li>输入：<ul><li>special: 挂载设备；</li><li>dir: 挂载点；</li><li>fstype: 挂载的文件系统类型；</li><li>flags: 挂载参数；</li><li>data: 传递给文件系统的字符串参数，可为NULL；</li></ul></li><li>返回值：成功返回0，失败返回-1；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *special, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dir, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *fstype, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *data;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">syscall</span>(SYS_mount, special, dir, fstype, flags, data);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-fstat-80-12-13"><a href="#define-SYS-fstat-80-12-13" class="headerlink" title="#define SYS_fstat 80 (12.13)"></a>#define SYS_fstat 80 (12.13)</h3><ul><li>功能：获取文件状态；</li><li>输入：<ul><li>fd: 文件句柄；</li><li>kst: 接收保存文件状态的指针；</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">kstat</span> &#123;<br><span class="hljs-type">dev_t</span> st_dev;<br><span class="hljs-type">ino_t</span> st_ino;<br><span class="hljs-type">mode_t</span> st_mode;<br><span class="hljs-type">nlink_t</span> st_nlink;<br><span class="hljs-type">uid_t</span> st_uid;<br><span class="hljs-type">gid_t</span> st_gid;<br><span class="hljs-type">dev_t</span> st_rdev;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> __pad;<br><span class="hljs-type">off_t</span> st_size;<br><span class="hljs-type">blksize_t</span> st_blksize;<br><span class="hljs-type">int</span> __pad2;<br><span class="hljs-type">blkcnt_t</span> st_blocks;<br><span class="hljs-type">long</span> st_atime_sec;<br><span class="hljs-type">long</span> st_atime_nsec;<br><span class="hljs-type">long</span> st_mtime_sec;<br><span class="hljs-type">long</span> st_mtime_nsec;<br><span class="hljs-type">long</span> st_ctime_sec;<br><span class="hljs-type">long</span> st_ctime_nsec;<br><span class="hljs-type">unsigned</span> __unused[<span class="hljs-number">2</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功返回0，失败返回-1；</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> fd<span class="hljs-comment">;</span><br>struct kstat kst<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">syscall</span>(SYS_fstat, fd, &amp;kst)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="进程管理相关"><a href="#进程管理相关" class="headerlink" title="进程管理相关"></a>进程管理相关</h2><h3 id="define-SYS-clone-220-（10-26）"><a href="#define-SYS-clone-220-（10-26）" class="headerlink" title="#define SYS_clone 220 （10.26）"></a>#define SYS_clone 220 （10.26）</h3><ul><li>功能：创建一个子进程；</li><li>输入：<ul><li>flags: 创建的标志，如SIGCHLD；</li><li>stack: 指定新进程的栈，可为0；</li><li>ptid: 父线程ID；</li><li>tls: TLS线程本地存储描述符；</li><li>ctid: 子线程ID；</li></ul></li><li>返回值：成功则返回子进程的线程ID，失败返回-1；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pid_t</span> ret = <span class="hljs-built_in">syscall</span>(SYS_clone, flags, stack, ptid, tls, ctid)<br></code></pre></td></tr></table></figure><h3 id="define-SYS-execve-221-（10-26）"><a href="#define-SYS-execve-221-（10-26）" class="headerlink" title="#define SYS_execve 221 （10.26）"></a>#define SYS_execve 221 （10.26）</h3><ul><li>功能：执行一个指定的程序；</li><li>输入：<ul><li>path: 待执行程序路径名称，</li><li>argv: 程序的参数， </li><li>envp: 环境变量的数组指针</li></ul></li><li>返回值：成功不返回，失败返回-1；</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[], <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[];<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">syscall</span>(SYS_execve, path, argv, envp);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-wait4-260（10-26）"><a href="#define-SYS-wait4-260（10-26）" class="headerlink" title="#define SYS_wait4 260（10.26）"></a>#define SYS_wait4 260（10.26）</h3><ul><li>功能：等待进程改变状态;</li><li>输入：<ul><li>pid: 指定进程ID，可为-1等待任何子进程；</li><li>status: 接收状态的指针；</li><li>options: 选项：WNOHANG，WUNTRACED，WCONTINUED；</li></ul></li><li>返回值：成功则返回进程ID；如果指定了WNOHANG，且进程还未改变状态，直接返回0；失败则返回-1；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pid_t</span> pid, <span class="hljs-type">int</span> *status, <span class="hljs-type">int</span> options;<br><span class="hljs-type">pid_t</span> ret = <span class="hljs-built_in">syscall</span>(SYS_wait4, pid, status, options);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-exit-93-（10-26）"><a href="#define-SYS-exit-93-（10-26）" class="headerlink" title="#define SYS_exit 93 （10.26）"></a>#define SYS_exit 93 （10.26）</h3><ul><li>功能：触发进程终止，无返回值；</li><li>输入：终止状态值；</li><li>返回值：无返回值；</li></ul><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> ec;<br><span class="hljs-keyword">syscall</span>(SYS_exit, ec);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-getppid-173-（10-25）"><a href="#define-SYS-getppid-173-（10-25）" class="headerlink" title="#define SYS_getppid 173 （10.25）"></a>#define SYS_getppid 173 （10.25）</h3><ul><li>功能：获取父进程ID；</li><li>输入：系统调用ID；</li><li>返回值：成功返回父进程ID；</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">pid_t ret <span class="hljs-operator">=</span> syscall(SYS_getppid)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="define-SYS-getpid-172-（10-25）"><a href="#define-SYS-getpid-172-（10-25）" class="headerlink" title="#define SYS_getpid 172 （10.25）"></a>#define SYS_getpid 172 （10.25）</h3><ul><li>功能：获取进程ID；</li><li>输入：系统调用ID；</li><li>返回值：成功返回进程ID；</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">pid_t ret <span class="hljs-operator">=</span> syscall(SYS_getpid)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="内存管理相关"><a href="#内存管理相关" class="headerlink" title="内存管理相关"></a>内存管理相关</h2><h3 id="define-SYS-brk-214-（10-26）"><a href="#define-SYS-brk-214-（10-26）" class="headerlink" title="#define SYS_brk 214 （10.26）"></a>#define SYS_brk 214 （10.26）</h3><ul><li>功能：修改数据段的大小；</li><li>输入：指定待修改的地址；</li><li>返回值：成功返回0，失败返回-1;</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">uint</span>ptr_t brk;<br><span class="hljs-built_in">uint</span>ptr_t ret = syscall(SYS_brk, brk);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-munmap-215-12-13"><a href="#define-SYS-munmap-215-12-13" class="headerlink" title="#define SYS_munmap 215 (12.13)"></a>#define SYS_munmap 215 (12.13)</h3><ul><li>功能：将文件或设备取消映射到内存中；</li><li>输入：映射的指定地址及区间；</li><li>返回值：成功返回0，失败返回-1;</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> *<span class="hljs-keyword">start</span>, size_t len<br><span class="hljs-type">int</span> ret = syscall(SYS_munmap, <span class="hljs-keyword">start</span>, len);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-mmap-222-12-13"><a href="#define-SYS-mmap-222-12-13" class="headerlink" title="#define SYS_mmap 222 (12.13)"></a>#define SYS_mmap 222 (12.13)</h3><ul><li>功能：将文件或设备映射到内存中；</li><li>输入：<ul><li>start: 映射起始位置，</li><li>len: 长度，</li><li>prot: 映射的内存保护方式，可取：PROT_EXEC, PROT_READ, PROT_WRITE, PROT_NONE</li><li>flags: 映射是否与其他进程共享的标志，</li><li>fd: 文件句柄，</li><li>off: 文件偏移量；</li></ul></li><li>返回值：成功返回已映射区域的指针，失败返回-1;</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> *<span class="hljs-keyword">start</span>, size_t len, <span class="hljs-type">int</span> prot, <span class="hljs-type">int</span> flags, <span class="hljs-type">int</span> fd, off_t <span class="hljs-keyword">off</span><br>long ret = syscall(SYS_mmap, <span class="hljs-keyword">start</span>, len, prot, flags, fd, <span class="hljs-keyword">off</span>);<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="define-SYS-times-153-12-10"><a href="#define-SYS-times-153-12-10" class="headerlink" title="#define SYS_times 153  (12.10)"></a>#define SYS_times 153  (12.10)</h3><ul><li>功能：获取进程时间；</li><li>输入：tms结构体指针，用于获取保存当前进程的运行时间数据；</li><li>返回值：成功返回已经过去的滴答数，失败返回-1;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">tms</span> *tms;<br><span class="hljs-type">clock_t</span> ret = <span class="hljs-built_in">syscall</span>(SYS_times, tms);<br></code></pre></td></tr></table></figure><h3 id="define-SYS-uname-160-12-13"><a href="#define-SYS-uname-160-12-13" class="headerlink" title="#define SYS_uname 160 (12.13)"></a>#define SYS_uname 160 (12.13)</h3><ul><li>功能：打印系统信息；</li><li>输入：utsname结构体指针用于获得系统信息数据；</li><li>返回值：成功返回0，失败返回-1;</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">struct utsname *uts<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">syscall</span>(SYS_uname, uts)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="define-SYS-sched-yield-124-（10-25）"><a href="#define-SYS-sched-yield-124-（10-25）" class="headerlink" title="#define SYS_sched_yield 124 （10.25）"></a>#define SYS_sched_yield 124 （10.25）</h3><ul><li>功能：让出调度器；</li><li>输入：系统调用ID；</li><li>返回值：成功返回0，失败返回-1;</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">int</span> <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">syscall</span>(SYS_sched_yield)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="define-SYS-gettimeofday-169-12-11"><a href="#define-SYS-gettimeofday-169-12-11" class="headerlink" title="#define SYS_gettimeofday 169 (12.11)"></a>#define SYS_gettimeofday 169 (12.11)</h3><ul><li>功能：获取时间；</li><li>输入： timespec结构体指针用于获得时间值；</li><li>返回值：成功返回0，失败返回-1;</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">struct timespec *ts<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">syscall</span>(SYS_gettimeofday, ts, <span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h3 id="define-SYS-nanosleep-101-12-11"><a href="#define-SYS-nanosleep-101-12-11" class="headerlink" title="#define SYS_nanosleep 101 (12.11)"></a>#define SYS_nanosleep 101 (12.11)</h3><ul><li>功能：执行线程睡眠，sleep()库函数基于此系统调用；</li><li>输入：睡眠的时间间隔；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> &#123;<br><span class="hljs-type">time_t</span> tv_sec;        <span class="hljs-comment">/* 秒 */</span><br><span class="hljs-type">long</span>   tv_nsec;       <span class="hljs-comment">/* 纳秒, 范围在0~999999999 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>返回值：成功返回0，失败返回-1;</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> *req, <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> *rem;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">syscall</span>(SYS_nanosleep, req, rem);<br></code></pre></td></tr></table></figure><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">static inline _u64 internal_syscall(long n, _u64 _<span class="hljs-built_in">a0</span>, _u64 _<span class="hljs-built_in">a1</span>, _u64 _<span class="hljs-built_in">a2</span>, _u64<br>_<span class="hljs-built_in">a3</span>, _u64 _<span class="hljs-built_in">a4</span>, _u64 _<span class="hljs-built_in">a5</span>) &#123;<br>register _u64 <span class="hljs-built_in">a0</span> asm(<span class="hljs-string">&quot;a0&quot;</span>) = _<span class="hljs-built_in">a0</span>;<br>register _u64 <span class="hljs-built_in">a1</span> asm(<span class="hljs-string">&quot;a1&quot;</span>) = _<span class="hljs-built_in">a1</span>;<br>register _u64 <span class="hljs-built_in">a2</span> asm(<span class="hljs-string">&quot;a2&quot;</span>) = _<span class="hljs-built_in">a2</span>;<br>register _u64 <span class="hljs-built_in">a3</span> asm(<span class="hljs-string">&quot;a3&quot;</span>) = _<span class="hljs-built_in">a3</span>;<br>register _u64 <span class="hljs-built_in">a4</span> asm(<span class="hljs-string">&quot;a4&quot;</span>) = _<span class="hljs-built_in">a4</span>;<br>register _u64 <span class="hljs-built_in">a5</span> asm(<span class="hljs-string">&quot;a5&quot;</span>) = _<span class="hljs-built_in">a5</span>;<br>register long <span class="hljs-keyword">syscall_id </span>asm(<span class="hljs-string">&quot;a7&quot;</span>) = n;<br>asm volatile (<span class="hljs-string">&quot;ecall&quot;</span> : <span class="hljs-string">&quot;+r&quot;</span>(<span class="hljs-built_in">a0</span>) : <span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-built_in">a1</span>), <span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-built_in">a2</span>), <span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-built_in">a3</span>), <span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-built_in">a4</span>), <span class="hljs-string">&quot;r&quot;</span><br>(<span class="hljs-built_in">a5</span>), <span class="hljs-string">&quot;r&quot;</span>(<span class="hljs-keyword">syscall_id));</span><br><span class="hljs-keyword"></span>return <span class="hljs-built_in">a0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Xv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Xv6 Chapter 5</title>
    <link href="/2024/09/27/MIT-6-1810-Xv6-Chapter-5/"/>
    <url>/2024/09/27/MIT-6-1810-Xv6-Chapter-5/</url>
    
    <content type="html"><![CDATA[<h1 id="Interrupts-and-device-drivers"><a href="#Interrupts-and-device-drivers" class="headerlink" title="Interrupts and device drivers"></a>Interrupts and device drivers</h1><span id="more"></span><p>驱动程序在操作系统中起着管理硬件设备的重要作用。它负责配置设备硬件、启动操作、处理中断，并与可能在等待设备输入&#x2F;输出（I&#x2F;O）的进程进行协调。驱动程序代码比较复杂，因为它需要与它管理的设备并发执行。此外，驱动程序必须理解设备的硬件接口，而这些接口往往比较复杂，甚至文档不全。</p><p>需要操作系统关注的设备通常可以配置为生成中断，中断是一种陷阱（trap）。内核的陷阱处理代码识别出设备触发了中断，并调用驱动程序的中断处理程序。在 <strong>xv6</strong> 操作系统中，这个调度过程发生在 <code>devintr</code>（kernel&#x2F;trap.c:185）中。</p><p>许多设备驱动程序在两种上下文中执行代码：上半部分在进程的内核线程中运行，而下半部分在中断发生时执行。上半部分通常通过系统调用（如 <code>read</code> 和 <code>write</code>）被调用，要求设备执行I&#x2F;O操作。例如，它可能请求硬盘读取一个数据块，并等待操作完成。最终，设备完成操作并触发中断。驱动程序的中断处理程序作为下半部分运行，确定完成了什么操作，必要时唤醒等待的进程，并指示硬件继续处理任何等待的操作。</p><h2 id="5-1-Code-Console-input"><a href="#5-1-Code-Console-input" class="headerlink" title="5.1  Code: Console input"></a>5.1  Code: Console input</h2><p>控制台驱动程序（kernel&#x2F;console.c）是驱动程序结构的简单示例。该驱动程序通过连接到RISC-V的UART串口硬件接收人类输入的字符。控制台驱动程序每次累积一行输入，处理特殊字符如退格键和Control-U。用户进程（如shell）使用<code>read</code>系统调用从控制台获取输入。当你在QEMU中向xv6输入内容时，你的按键通过QEMU模拟的UART硬件传递到xv6。</p><p>驱动程序与UART硬件通信，UART硬件是由QEMU模拟的16550芯片。在真实计算机中，16550芯片管理连接到终端或其他计算机的RS232串行链接。而在QEMU中，它连接到你的键盘和显示器。</p><p>UART硬件通过内存映射的控制寄存器呈现给软件。即，RISC-V硬件将一些物理地址连接到UART设备，因此对这些地址的加载和存储操作将与设备硬件交互，而非与RAM交互。UART的内存映射地址从<code>0x10000000</code>（即<code>UART0</code>）开始（定义在<code>kernel/memlayout.h:21</code>）。UART控制寄存器是宽度为一个字节的一组寄存器，其偏移量定义在<code>kernel/uart.c:22</code>。例如，LSR寄存器包含指示是否有输入字符等待被软件读取的位。这些字符（如果有的话）可从RHR寄存器读取。每次读取一个字符后，UART硬件会从内部FIFO中删除该字符，并在FIFO为空时清除LSR中的“ready”位。UART的发送硬件与接收硬件基本独立；如果软件向THR写入一个字节，UART会发送该字节。</p><p>xv6的<code>main</code>函数通过调用<code>consoleinit</code>（kernel&#x2F;console.c:182）初始化UART硬件。该代码配置UART，以便在每次接收到一个输入字节时生成接收中断，并且在每次完成发送一个输出字节时生成发送完成中断（kernel&#x2F;uart.c:53）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">consoleinit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  initlock(&amp;cons.lock, <span class="hljs-string">&quot;cons&quot;</span>);<br><br>  uartinit();<br><br>  <span class="hljs-comment">// connect read and write system calls</span><br>  <span class="hljs-comment">// to consoleread and consolewrite.</span><br>  devsw[CONSOLE].read = consoleread;<br>  devsw[CONSOLE].write = consolewrite;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>xv6的shell通过<code>init.c</code>打开的文件描述符（user&#x2F;init.c:19）从控制台读取数据。对<code>read</code>系统调用的请求通过内核到达<code>consoleread</code>（kernel&#x2F;console.c:80）。<code>consoleread</code>等待输入通过中断到达并缓存在<code>cons.buf</code>中，将输入复制到用户空间，并在整行到达后返回给用户进程。如果用户没有输入完整的一行，任何正在读取的进程会在<code>sleep</code>调用中等待（kernel&#x2F;console.c:96）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// user read()s from the console go here.</span><br><span class="hljs-comment">// copy (up to) a whole input line to dst.</span><br><span class="hljs-comment">// user_dist indicates whether dst is a user</span><br><span class="hljs-comment">// or kernel address.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">consoleread</span><span class="hljs-params">(<span class="hljs-type">int</span> user_dst, uint64 dst, <span class="hljs-type">int</span> n)</span><br>&#123;<br>  uint target;<br>  <span class="hljs-type">int</span> c;<br>  <span class="hljs-type">char</span> cbuf;<br><br>  target = n;<br>  acquire(&amp;cons.lock);<br>  <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// wait until interrupt handler has put some</span><br>    <span class="hljs-comment">// input into cons.buffer.</span><br>    <span class="hljs-keyword">while</span>(cons.r == cons.w)&#123;<br>      <span class="hljs-keyword">if</span>(killed(myproc()))&#123;<br>        release(&amp;cons.lock);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>      &#125;<br>      sleep(&amp;cons.r, &amp;cons.lock);<br>    &#125;<br><br>    c = cons.buf[cons.r++ % INPUT_BUF_SIZE];<br><br>    <span class="hljs-keyword">if</span>(c == C(<span class="hljs-string">&#x27;D&#x27;</span>))&#123;  <span class="hljs-comment">// end-of-file</span><br>      <span class="hljs-keyword">if</span>(n &lt; target)&#123;<br>        <span class="hljs-comment">// Save ^D for next time, to make sure</span><br>        <span class="hljs-comment">// caller gets a 0-byte result.</span><br>        cons.r--;<br>      &#125;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// copy the input byte to the user-space buffer.</span><br>    cbuf = c;<br>    <span class="hljs-keyword">if</span>(either_copyout(user_dst, dst, &amp;cbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br><br>    dst++;<br>    --n;<br><br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>      <span class="hljs-comment">// a whole line has arrived, return to</span><br>      <span class="hljs-comment">// the user-level read().</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  release(&amp;cons.lock);<br><br>  <span class="hljs-keyword">return</span> target - n;<br>&#125;<br></code></pre></td></tr></table></figure><p>当用户输入一个字符时，UART硬件请求RISC-V触发中断，从而激活xv6的陷阱处理程序。陷阱处理程序调用<code>devintr</code>（kernel&#x2F;trap.c:185），该函数通过查看RISC-V的<code>scause</code>寄存器发现中断来自外部设备。然后它请求名为PLIC的硬件单元（kernel&#x2F;trap.c:193）告知中断的设备。如果中断来自UART，<code>devintr</code>会调用<code>uartintr</code>。</p><p><code>uartintr</code>（kernel&#x2F;uart.c:177）从UART硬件读取任何等待的输入字符，并将其传递给<code>consoleintr</code>（kernel&#x2F;console.c:136）；它不会等待字符，因为将来输入会触发新的中断。<code>consoleintr</code>的任务是将输入字符累积到<code>cons.buf</code>中，直到一整行到达。<code>consoleintr</code>会特殊处理退格键和其他一些字符。当换行符到达时，<code>consoleintr</code>会唤醒等待的<code>consoleread</code>（如果有的话）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// the console input interrupt handler.</span><br><span class="hljs-comment">// uartintr() calls this for input character.</span><br><span class="hljs-comment">// do erase/kill processing, append to cons.buf,</span><br><span class="hljs-comment">// wake up consoleread() if a whole line has arrived.</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">consoleintr</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span><br>&#123;<br>  acquire(&amp;cons.lock);<br><br>  <span class="hljs-keyword">switch</span>(c)&#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;P&#x27;</span>)</span>:  <span class="hljs-comment">// Print process list.</span><br>    <span class="hljs-title function_">procdump</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;U&#x27;</span>)</span>:  <span class="hljs-comment">// Kill line.</span><br>    <span class="hljs-title function_">while</span><span class="hljs-params">(cons.e != cons.w &amp;&amp;</span><br><span class="hljs-params">          cons.buf[(cons.e<span class="hljs-number">-1</span>) % INPUT_BUF_SIZE] != <span class="hljs-string">&#x27;\n&#x27;</span>)</span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-title function_">C</span><span class="hljs-params">(<span class="hljs-string">&#x27;H&#x27;</span>)</span>: <span class="hljs-comment">// Backspace</span><br>  <span class="hljs-keyword">case</span> &#x27;\x7f&#x27;: <span class="hljs-comment">// Delete key</span><br>    <span class="hljs-title function_">if</span><span class="hljs-params">(cons.e != cons.w)</span>&#123;<br>      cons.e--;<br>      consputc(BACKSPACE);<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-keyword">if</span>(c != <span class="hljs-number">0</span> &amp;&amp; cons.e-cons.r &lt; INPUT_BUF_SIZE)&#123;<br>      c = (c == <span class="hljs-string">&#x27;\r&#x27;</span>) ? <span class="hljs-string">&#x27;\n&#x27;</span> : c;<br><br>      <span class="hljs-comment">// echo back to the user.</span><br>      consputc(c);<br><br>      <span class="hljs-comment">// store for consumption by consoleread().</span><br>      cons.buf[cons.e++ % INPUT_BUF_SIZE] = c;<br><br>      <span class="hljs-keyword">if</span>(c == <span class="hljs-string">&#x27;\n&#x27;</span> || c == C(<span class="hljs-string">&#x27;D&#x27;</span>) || cons.e-cons.r == INPUT_BUF_SIZE)&#123;<br>        <span class="hljs-comment">// wake up consoleread() if a whole line (or end-of-file)</span><br>        <span class="hljs-comment">// has arrived.</span><br>        cons.w = cons.e;<br>        wakeup(&amp;cons.r);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>  <br>  release(&amp;cons.lock);<br>&#125;<br><br><span class="hljs-comment">// handle a uart interrupt, raised because input has</span><br><span class="hljs-comment">// arrived, or the uart is ready for more output, or</span><br><span class="hljs-comment">// both. called from devintr().</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">uartintr</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// read and process incoming characters.</span><br>  <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-type">int</span> c = uartgetc();<br>    <span class="hljs-keyword">if</span>(c == <span class="hljs-number">-1</span>)<br>      <span class="hljs-keyword">break</span>;<br>    consoleintr(c);<br>  &#125;<br><br>  <span class="hljs-comment">// send buffered characters.</span><br>  acquire(&amp;uart_tx_lock);<br>  uartstart();<br>  release(&amp;uart_tx_lock);<br>&#125;<br></code></pre></td></tr></table></figure><p>一旦被唤醒，<code>consoleread</code>会检测到<code>cons.buf</code>中有一整行，将其复制到用户空间，并通过系统调用机制返回到用户空间。</p><h2 id="5-2-Code-Console-output"><a href="#5-2-Code-Console-output" class="headerlink" title="5.2  Code: Console output"></a>5.2  Code: Console output</h2><p>在控制台连接的文件描述符上进行的<code>write</code>系统调用最终会到达<code>uartputc</code>（kernel&#x2F;uart.c:87）。设备驱动程序维护一个输出缓冲区（<code>uart_tx_buf</code>），这样写入的进程不需要等待UART完成发送操作；相反，<code>uartputc</code>会将每个字符添加到缓冲区中，并调用<code>uartstart</code>来启动设备的传输（如果设备尚未传输），然后立即返回。唯一会导致<code>uartputc</code>等待的情况是缓冲区已满。</p><p>每次UART完成发送一个字节时，它会生成一个中断。<code>uartintr</code>会调用<code>uartstart</code>，该函数检查设备是否确实完成了发送，并将下一个缓冲的输出字符交给设备。因此，如果一个进程向控制台写入多个字节，通常第一个字节会通过<code>uartputc</code>调用<code>uartstart</code>发送，剩余的缓冲字节则由<code>uartstart</code>在UART发送完成中断到来时调用<code>uartintr</code>发送。</p><p>需要注意的一个通用模式是通过缓冲和中断将设备活动与进程活动解耦。即使没有进程在等待读取，控制台驱动程序仍然可以处理输入；之后的读取操作将能够看到这些输入。同样，进程可以发送输出而不必等待设备的响应。这种解耦可以通过允许进程与设备I&#x2F;O并发执行来提高性能，特别是在设备较慢（如UART）或需要立即处理（如回显输入字符）的情况下。这种思想有时被称为I&#x2F;O并发。</p><h2 id="5-3-Concurrency-in-drivers"><a href="#5-3-Concurrency-in-drivers" class="headerlink" title="5.3 Concurrency in drivers"></a>5.3 Concurrency in drivers</h2><p>你可能已经注意到在<code>consoleread</code>和<code>consoleintr</code>中调用了<code>acquire</code>函数。这些调用用于获取锁，以保护控制台驱动程序的数据结构免受并发访问的影响。这里有三种并发的潜在危险：两个进程在不同的CPU上同时调用<code>consoleread</code>；硬件可能请求CPU在该CPU已经在执行<code>consoleread</code>时传递控制台（实际上是UART）的中断；硬件可能在不同的CPU上传递控制台中断，而此时<code>consoleread</code>正在执行。第六章解释了如何使用锁来确保这些并发问题不会导致错误的结果。</p><p>并发对驱动程序的另一个影响是，某个进程可能正在等待设备输入，但输入到来的中断可能发生在另一个进程（甚至是没有进程运行的情况下）。因此，中断处理程序不允许考虑它所中断的进程或代码。例如，中断处理程序不能安全地调用<code>copyout</code>，因为它依赖于当前进程的页表。中断处理程序通常执行的工作相对较少（例如，只是将输入数据复制到缓冲区中），然后唤醒上半部分代码来完成其余工作。</p><h2 id="5-4-Timer-interrupts"><a href="#5-4-Timer-interrupts" class="headerlink" title="5.4 Timer interrupts"></a>5.4 Timer interrupts</h2><p>Xv6 使用定时器中断来维护当前时间的概念，并在计算密集型进程之间进行切换。定时器中断来自连接到每个 RISC-V CPU 的时钟硬件。Xv6 通过编程使每个 CPU 的时钟硬件定期中断 CPU。</p><p><code>start.c</code>中的代码（kernel&#x2F;start.c:53）设置了一些控制位，允许监督模式访问定时器控制寄存器，然后请求第一次定时器中断。定时器控制寄存器包含一个硬件以稳定速率递增的计数，这表示当前时间。<code>stimecmp</code>寄存器则包含 CPU 将触发定时器中断的时间；通过将<code>stimecmp</code>设置为当前时间加上<code>x</code>，可以安排在<code>x</code>个时间单位后触发中断。对于 QEMU 的 RISC-V 模拟，1000000 个时间单位大约等于十分之一秒。</p><p>定时器中断像其他设备中断一样，通过<code>usertrap</code>或<code>kerneltrap</code>和<code>devintr</code>到达。定时器中断到来时，<code>scause</code>寄存器的低位被设置为5；<code>trap.c</code>中的<code>devintr</code>检测到这种情况并调用<code>clockintr</code>（kernel&#x2F;trap.c:164）。该函数递增<code>ticks</code>变量，从而使内核能够跟踪时间的流逝。为避免在多CPU情况下时间流逝加速，递增操作仅发生在一个CPU上。<code>clockintr</code>唤醒任何在<code>sleep</code>系统调用中等待的进程，并通过写入<code>stimecmp</code>来安排下一个定时器中断。</p><p><code>devintr</code>对于定时器中断返回2，以指示<code>kerneltrap</code>或<code>usertrap</code>调用<code>yield</code>，从而使 CPU 可以在可运行的进程之间进行多路复用。</p><p>定时器中断在内核代码中可能会导致上下文切换，这就是为什么<code>usertrap</code>的早期代码在启用中断之前要谨慎保存状态（如<code>sepc</code>）。这些上下文切换意味着内核代码必须以能够在没有警告的情况下从一个 CPU 转移到另一个 CPU 的方式编写。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Xv6 Chapter 4</title>
    <link href="/2024/09/26/MIT-6-1810-Xv6-Chapter-4/"/>
    <url>/2024/09/26/MIT-6-1810-Xv6-Chapter-4/</url>
    
    <content type="html"><![CDATA[<h1 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a>Traps and system calls</h1><span id="more"></span><p>有三种情况会导致CPU暂停普通指令的执行，并强制转移控制权到处理该事件的特殊代码。</p><ol><li>系统调用：当用户程序执行 <code>ecall</code> 指令请求内核为其执行某项操作时，就会发生系统调用。</li><li>异常：当指令（无论是用户指令还是内核指令）执行了非法操作时，例如除以零或使用无效的虚拟地址，就会触发异常。</li><li>设备中断：当某个设备发出信号表示它需要处理时，例如磁盘硬件完成了读写请求，就会发生设备中断。</li></ol><p>xv6中用trap来代表以上三种情况。通常的执行流程如下：</p><ol><li>trap强制将控制权转移到内核</li><li>内核保存寄存器和其他状态</li><li>内核执行相应的处理代码</li><li>内核恢复寄存器和其他状态，跳转到原来的代码继续执行</li></ol><p>Xv6 的trap处理分为四个阶段：</p><ol><li>第一阶段是 RISC-V CPU 执行的硬件操作</li><li>第二阶段是一些汇编指令用于准备内核 C 代码</li><li>第三阶段是 C 函数决定如何处理陷阱</li><li>最后是系统调用或设备驱动程序服务例程。</li></ol><p>尽管这三种trap类型之间有很多共同点，理论上可以用一条代码路径处理所有trap，但实际上将来自用户空间和来自内核空间的trap分开处理更为方便。处理trap的内核代码（汇编或 C）通常被称为处理程序，最开始的处理程序指令通常用汇编编写，称为向量（vector）。</p><h2 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h2><p>每个RISC-V的CPU都有一套控制寄存器，内核可以读写这些控制寄存器来告诉CPU如何处理trap或者了解发生了什么trap。riscv.h中包含了xv6用到的定义。</p><p>一些比较重要的寄存器：</p><ul><li><strong>stvec</strong>：内核在此寄存器中写入trap处理程序的地址；RISC-V 发生trap时会跳转到 <code>stvec</code> 中的地址去处理trap。</li><li><strong>sepc</strong>：发生trap时，RISC-V 将程序计数器（PC）的值保存到此寄存器中（因为 PC 随后会被 <code>stvec</code> 中的值覆盖）。<code>sret</code>（从陷阱返回）指令会将 <code>sepc</code> 的值复制回 PC。内核可以通过写入 <code>sepc</code> 来控制 <code>sret</code> 的返回地址。</li><li><strong>scause</strong>：RISC-V 在此寄存器中存储一个数字，描述trap发生的原因。</li><li><strong>sscratch</strong>：trap处理程序使用此寄存器帮助避免在保存用户寄存器之前覆盖它们。</li><li><strong>sstatus</strong>：<code>sstatus</code> 中的 SIE（supervisor interrupt enable） 位控制设备中断是否启用。如果内核清除 SIE 位，RISC-V 将推迟设备中断，直到内核设置 SIE 位。SPP 位则指示trap是来自用户态还是S态，并且控制 <code>sret</code> 的返回态。</li></ul><p>以上寄存器只能在S态访问，用户态不能访问。每个CPU都有自己的一套控制寄存器，在某个时间可能有多个CPU在处理trap。</p><p>当需要处理一个trap时，<strong>硬件进行如下操作</strong>：</p><ol><li>如果sstatus中的SIE位没有设置，并且trap的种类是设备中断，则不进行下列操作。</li><li>清除sstatus中的SIE位来禁用设备中断。</li><li>将pc的值拷贝到sepc中</li><li>将当前的模式保存到sstatus中的SPP位中</li><li>设置scause寄存器的值来标识trap的原因</li><li>切换到S态</li><li>将stvec的值拷贝到pc</li><li>开始执行pc指向的指令</li></ol><p>需要注意的是，硬件并不负责将页表切换到内核页表，也不负责切换到内核栈，也不会保存除了pc以外的其他寄存器的值，因此内核的软件必须负责这些。</p><h2 id="4-2-Traps-from-user-space"><a href="#4-2-Traps-from-user-space" class="headerlink" title="4.2 Traps from user space"></a>4.2 Traps from user space</h2><p>xv6中处理来自用户态的trap的路径大概如下：</p><ol><li>uservec（kernel&#x2F;trampoline.S）</li><li>usertrap（kernel&#x2F;trap.c）</li><li>返回后，usertrapret（kernel&#x2F;trap.c）</li><li>userret（kernel&#x2F;trampoline.S）</li></ol><p>Xv6 的trap处理设计中一个重要的限制是 RISC-V 硬件在触发trap时不会切换页表。这意味着 <code>stvec</code> 中的trap处理程序地址必须在用户页表中有一个有效的映射，因为trap处理代码开始执行时，用户页表仍然生效。此外，Xv6 的trap处理代码还需要切换到内核页表；为了在切换到内核页表后能够继续执行，内核页表也必须为 <code>stvec</code> 指向的处理程序地址提供映射。</p><p>Xv6 通过使用trampoline page来满足这些要求。该页包含了 <code>uservec</code>，即 Xv6 的trap处理代码，而 <code>stvec</code> 指向这个代码。该页被映射在每个进程的页表中，地址是 <code>TRAMPOLINE</code>，该页同样也被映射在内核页表中的 <code>TRAMPOLINE</code> 地址上。由于该页在内核地址空间中和用户地址空间中映射在相同的地址，因此trap处理程序在切换到内核页表后可以继续执行。</p><p><code>uservec</code> 的代码在 <code>trampoline.S</code> 文件中（kernel&#x2F;trampoline.S:22）。当 <code>uservec</code> 开始执行时，所有32个寄存器都包含了被中断的用户代码的值。这些32个寄存器的值需要保存到内存中，以便稍后内核在返回用户空间之前恢复它们。将这些值存储到内存需要使用一个寄存器来存放内存地址，但此时没有任何通用寄存器可用。RISC-V 提供了 <code>sscratch</code> 寄存器作为帮助。在 <code>uservec</code> 的开头，<code>csrw</code> 指令将 <code>a0</code> 保存到 <code>sscratch</code> 中。这样，<code>uservec</code> 就有了一个寄存器（<code>a0</code>）可以使用。</p><p><code>uservec</code> 的下一个任务是保存32个用户寄存器。内核为每个进程分配了一页内存用于保存一个 <code>trapframe</code> 结构体，其中包含保存这32个用户寄存器的空间（见 kernel&#x2F;proc.h:43）。因为此时 <code>satp</code> 仍然指向用户页表，因此 <code>uservec</code> 需要 <code>trapframe</code> 映射到用户地址空间中。Xv6 将每个进程的 <code>trapframe</code> 映射在该进程用户页表中的虚拟地址 <code>TRAPFRAME</code>，这个地址位于 <code>TRAMPOLINE</code> 的下方。每个进程的 <code>p-&gt;trapframe</code> 也指向 <code>trapframe</code>，但使用的是物理地址，以便内核通过内核页表访问它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// memlayout.h</span><br><span class="hljs-comment">// map the trampoline page to the highest address,</span><br><span class="hljs-comment">// in both user and kernel space.</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span><br><br><span class="hljs-comment">// User memory layout.</span><br><span class="hljs-comment">// Address zero first:</span><br><span class="hljs-comment">//   text</span><br><span class="hljs-comment">//   original data and bss</span><br><span class="hljs-comment">//   fixed-size stack</span><br><span class="hljs-comment">//   expandable heap</span><br><span class="hljs-comment">//   ...</span><br><span class="hljs-comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span><br><span class="hljs-comment">//   TRAMPOLINE (the same page as in the kernel)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span><br></code></pre></td></tr></table></figure><p>因此，<code>uservec</code> 将地址 <code>TRAPFRAME</code> 加载到 <code>a0</code> 中，并将所有用户寄存器保存在此处，包括从 <code>sscratch</code> 中读取的<code>a0</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># trampoline.S<br># save user a0 in sscratch so<br># a0 can be used to get at TRAPFRAME.<br>csrw sscratch, a0<br><br># each process has a separate p-&gt;trapframe memory area,<br># but it&#x27;s mapped to the same virtual address<br># (TRAPFRAME) in every process&#x27;s user page table.<br>li a0, TRAPFRAME<br><br># save the user registers in TRAPFRAME<br>sd ra, 40(a0)<br>sd sp, 48(a0)<br>sd gp, 56(a0)<br>sd tp, 64(a0)<br>sd t0, 72(a0)<br>sd t1, 80(a0)<br>sd t2, 88(a0)<br>sd s0, 96(a0)<br>sd s1, 104(a0)<br>sd a1, 120(a0)<br>sd a2, 128(a0)<br>sd a3, 136(a0)<br>sd a4, 144(a0)<br>sd a5, 152(a0)<br>sd a6, 160(a0)<br>sd a7, 168(a0)<br>sd s2, 176(a0)<br>sd s3, 184(a0)<br>sd s4, 192(a0)<br>sd s5, 200(a0)<br>sd s6, 208(a0)<br>sd s7, 216(a0)<br>sd s8, 224(a0)<br>sd s9, 232(a0)<br>sd s10, 240(a0)<br>sd s11, 248(a0)<br>sd t3, 256(a0)<br>sd t4, 264(a0)<br>sd t5, 272(a0)<br>sd t6, 280(a0)<br><br># save the user a0 in p-&gt;trapframe-&gt;a0<br>csrr t0, sscratch<br>sd t0, 112(a0)<br></code></pre></td></tr></table></figure><p><code>trapframe</code> 还包含当前进程的内核栈地址、当前 CPU 的 hartid、<code>usertrap</code> 函数的地址以及内核页表的地址。<code>uservec</code> 从中读取这些值，将 <code>satp</code> 切换到内核页表，并跳转到 <code>usertrap</code>。注意在切换页表之前以及之后需要执行 <code>sfence.vma</code> 指令，第一次确保所有之前的内存操作使用的都是用户页表，并且操作都已经完成，然后切换到内核页表，再次执行该指令，确保TLB中缓存的之前用户页表的PTE都已经被刷新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp<br>ld sp, 8(a0)<br><br># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid<br>ld tp, 32(a0)<br><br># load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap<br>ld t0, 16(a0)<br><br># fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.<br>ld t1, 0(a0)<br><br># wait for any previous memory operations to complete, so that<br># they use the user page table.<br>sfence.vma zero, zero<br><br># install the kernel page table.<br>csrw satp, t1<br><br># flush now-stale user entries from the TLB.<br>sfence.vma zero, zero<br><br># jump to usertrap(), which does not return<br>jr t0<br></code></pre></td></tr></table></figure><p><code>usertrap</code> 的任务是确定陷阱的原因，进行处理并返回（见 kernel&#x2F;trap.c:37）。它首先将 <code>stvec</code> 改为指向 <code>kernelvec</code>，以便内核中发生的陷阱由 <code>kernelvec</code> 处理。它保存 <code>sepc</code> 寄存器（硬件保存的用户程序计数器），因为 <code>usertrap</code> 可能会调用 <code>yield</code> 切换到另一个进程的内核线程，而该进程可能会返回用户空间，并修改 <code>sepc</code>。根据scause寄存器的值进行trap原因的判断（由硬件设置）：如果陷阱是系统调用，<code>usertrap</code> 调用 <code>syscall</code> 处理；如果是设备中断，调用 <code>devintr</code>；否则是异常，内核会终止出错的进程。在处理系统调用时，系统调用路径会将保存的用户程序计数器增加4，因为 RISC-V 在系统调用的情况下，会将程序计数器停留在 <code>ecall</code> 指令上，但用户代码需要从后续的指令继续执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// handle an interrupt, exception, or system call from user space.</span><br><span class="hljs-comment">// called from trampoline.S</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrap</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br>  <br>  <span class="hljs-comment">// SPP在trap发生的时候由硬件设置</span><br>  <span class="hljs-keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;usertrap: not from user mode&quot;</span>);<br><br>  <span class="hljs-comment">// send interrupts and exceptions to kerneltrap(),</span><br>  <span class="hljs-comment">// since we&#x27;re now in the kernel.</span><br>  w_stvec((uint64)kernelvec);<br><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <br>  <span class="hljs-comment">// save user program counter.</span><br>  p-&gt;trapframe-&gt;epc = r_sepc();<br>  <br>  <span class="hljs-comment">// scause的值由硬件设置</span><br>  <span class="hljs-keyword">if</span>(r_scause() == <span class="hljs-number">8</span>)&#123;<br>    <span class="hljs-comment">// system call</span><br><br>    <span class="hljs-keyword">if</span>(killed(p))<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>    <span class="hljs-comment">// sepc points to the ecall instruction,</span><br>    <span class="hljs-comment">// but we want to return to the next instruction.</span><br>    p-&gt;trapframe-&gt;epc += <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">// an interrupt will change sepc, scause, and sstatus,</span><br>    <span class="hljs-comment">// so enable only now that we&#x27;re done with those registers.</span><br>    <span class="hljs-comment">// 发生trap的时候，硬件会关闭设备中断</span><br>    intr_on();<br><br>    syscall();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((which_dev = devintr()) != <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// 设备中断</span><br>    <span class="hljs-comment">// ok</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 异常</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usertrap(): unexpected scause 0x%lx pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;            sepc=0x%lx stval=0x%lx\n&quot;</span>, r_sepc(), r_stval());<br>    setkilled(p);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(killed(p))<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)<br>    yield();<br><br>  usertrapret();<br>&#125;<br><br></code></pre></td></tr></table></figure><p>返回用户空间的第一步是调用 <code>usertrapret</code>（见 kernel&#x2F;trap.c:90）。这个函数设置 RISC-V 控制寄存器，为用户空间的未来陷阱做好准备：将 <code>stvec</code> 设置为 <code>uservec</code> 并准备 <code>trapframe</code> 字段，这是 <code>uservec</code> 依赖的内容。<code>usertrapret</code> 将 <code>sepc</code> 设置为先前保存的用户程序计数器。最后，<code>usertrapret</code> 调用位于trampoline page上的 <code>userret</code>，该函数的代码映射在用户和内核页表中，原因是 <code>userret</code> 的汇编代码需要切换页表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//</span><br><span class="hljs-comment">// return to user space</span><br><span class="hljs-comment">//</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">usertrapret</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// we&#x27;re about to switch the destination of traps from</span><br>  <span class="hljs-comment">// kerneltrap() to usertrap(), so turn off interrupts until</span><br>  <span class="hljs-comment">// we&#x27;re back in user space, where usertrap() is correct.</span><br>  intr_off();<br><br>  <span class="hljs-comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span><br>  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);<br>  w_stvec(trampoline_uservec);<br><br>  <span class="hljs-comment">// set up trapframe values that uservec will need when</span><br>  <span class="hljs-comment">// the process next traps into the kernel.</span><br>  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="hljs-comment">// kernel page table</span><br>  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="hljs-comment">// process&#x27;s kernel stack</span><br>  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;<br>  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="hljs-comment">// hartid for cpuid()</span><br><br>  <span class="hljs-comment">// set up the registers that trampoline.S&#x27;s sret will use</span><br>  <span class="hljs-comment">// to get to user space.</span><br>  <br>  <span class="hljs-comment">// set S Previous Privilege mode to User.</span><br>  <span class="hljs-comment">// 设置SPP为0 当使用sret返回的时候 会自动切换到用户态</span><br>  <span class="hljs-comment">// 设置SPIE为1 当使用sret返回的时候 会自动使能设备中断</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_sstatus();<br>  x &amp;= ~SSTATUS_SPP; <span class="hljs-comment">// clear SPP to 0 for user mode</span><br>  x |= SSTATUS_SPIE; <span class="hljs-comment">// enable interrupts in user mode</span><br>  w_sstatus(x);<br><br>  <span class="hljs-comment">// set S Exception Program Counter to the saved user pc.</span><br>  w_sepc(p-&gt;trapframe-&gt;epc);<br><br>  <span class="hljs-comment">// tell trampoline.S the user page table to switch to.</span><br>  uint64 satp = MAKE_SATP(p-&gt;pagetable);<br><br>  <span class="hljs-comment">// jump to userret in trampoline.S at the top of memory, which </span><br>  <span class="hljs-comment">// switches to the user page table, restores user registers,</span><br>  <span class="hljs-comment">// and switches to user mode with sret.</span><br>  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);<br>  ((<span class="hljs-type">void</span> (*)(uint64))trampoline_userret)(satp);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>usertrapret</code> 调用 <code>userret</code> 时，将进程的用户页表的指针传递给 <code>a0</code>（见 kernel&#x2F;trampoline.S:101）。<code>userret</code> 将 <code>satp</code> 切换到进程的用户页表。回想一下，用户页表映射了trampoline page和 <code>TRAPFRAME</code>，但没有其他内核内容。trampoline page在用户和内核页表中的相同虚拟地址映射允许 <code>userret</code> 在切换 <code>satp</code> 后继续执行。从此时开始，<code>userret</code> 能使用的唯一数据是寄存器的内容和 <code>trapframe</code> 的内容。<code>userret</code> 将 <code>TRAPFRAME</code> 地址加载到 <code>a0</code>，通过 <code>a0</code> 从 <code>trapframe</code> 中恢复保存的用户寄存器，恢复保存的 <code>a0</code>，并执行 <code>sret</code> 返回用户空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs assembly">userret:<br>    # userret(pagetable)<br>    # called by usertrapret() in trap.c to<br>    # switch from kernel to user.<br>    # a0: user page table, for satp.<br><br>    # switch to the user page table.<br>    sfence.vma zero, zero<br>    csrw satp, a0<br>    sfence.vma zero, zero<br><br>    li a0, TRAPFRAME<br><br>    # restore all but a0 from TRAPFRAME<br>    ld ra, 40(a0)<br>    ld sp, 48(a0)<br>    ld gp, 56(a0)<br>    ld tp, 64(a0)<br>    ld t0, 72(a0)<br>    ld t1, 80(a0)<br>    ld t2, 88(a0)<br>    ld s0, 96(a0)<br>    ld s1, 104(a0)<br>    ld a1, 120(a0)<br>    ld a2, 128(a0)<br>    ld a3, 136(a0)<br>    ld a4, 144(a0)<br>    ld a5, 152(a0)<br>    ld a6, 160(a0)<br>    ld a7, 168(a0)<br>    ld s2, 176(a0)<br>    ld s3, 184(a0)<br>    ld s4, 192(a0)<br>    ld s5, 200(a0)<br>    ld s6, 208(a0)<br>    ld s7, 216(a0)<br>    ld s8, 224(a0)<br>    ld s9, 232(a0)<br>    ld s10, 240(a0)<br>    ld s11, 248(a0)<br>    ld t3, 256(a0)<br>    ld t4, 264(a0)<br>    ld t5, 272(a0)<br>    ld t6, 280(a0)<br><br># restore user a0<br>    ld a0, 112(a0)<br><br>    # return to user mode and user pc.<br>    # usertrapret() set up sstatus and sepc.<br>    sret<br></code></pre></td></tr></table></figure><h2 id="4-3-Code：Calling-system-calls"><a href="#4-3-Code：Calling-system-calls" class="headerlink" title="4.3 Code：Calling system calls"></a>4.3 Code：Calling system calls</h2><p>首先将系统调用的参数放进寄存器a0-a6中，然后将系统调用号放进寄存器a7中。 <code>usertrap</code> 会判断当前发生的trap是系统调用，然后调用 <code>syscall</code> 函数去执行。 <code>syscall</code> 函数从trapframe中取得参数和系统调用号，然后用系统调用号作为索引取得系统调用处理程序的地址执行。当系统调用返回的时候，会把返回值存放在 <code>p-&gt;trapframe-&gt;a0</code> 中。</p><p>initcode.S系统调用 <code>exec(init, argv)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># exec(init, argv)<br>.globl start<br>start:<br>    la a0, init<br>    la a1, argv<br>    li a7, SYS_exec<br>    ecall·<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-comment">// a7中存放了系统调用号</span><br>  <span class="hljs-comment">// 系统调用之前存放到a7中</span><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    <span class="hljs-comment">// Use num to lookup the system call function for num, call it,</span><br>    <span class="hljs-comment">// and store its return value in p-&gt;trapframe-&gt;a0</span><br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-Code：System-call-arguments"><a href="#4-4-Code：System-call-arguments" class="headerlink" title="4.4 Code：System call arguments"></a>4.4 Code：System call arguments</h2><p>系统调用需要获取用户调用系统调用时传递的参数。这个参数最开始被放到用户寄存器中，之后在 <code>usertrap</code> 中被保存到trapframe中。内核通过 <code>argint</code> 、<code>argaddr</code> 、<code>argfd</code> 从trapframe中获取第n个系统调用参数（整数、指针、文件描述符）。它们都通过 <code>argraw</code> 来获取trapframe中的寄存器的值。syscall在usertrap中执行，此时已经切换到S态，寄存器的值都被保存到trapframe中，但是由于已经切换到内核页表，因此无法通过虚拟地址访问trapframe，可以通过p-&gt;trapframe直接获取trapframe的物理地址进行访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> uint64<br><span class="hljs-title function_">argraw</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">switch</span> (n) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a0;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a1;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a2;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a3;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a4;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>    <span class="hljs-keyword">return</span> p-&gt;trapframe-&gt;a5;<br>  &#125;<br>  panic(<span class="hljs-string">&quot;argraw&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// Fetch the nth 32-bit system call argument.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">argint</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> *ip)</span><br>&#123;<br>  *ip = argraw(n);<br>&#125;<br><br><span class="hljs-comment">// Retrieve an argument as a pointer.</span><br><span class="hljs-comment">// Doesn&#x27;t check for legality, since</span><br><span class="hljs-comment">// copyin/copyout will do that.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">argaddr</span><span class="hljs-params">(<span class="hljs-type">int</span> n, uint64 *ip)</span><br>&#123;<br>  *ip = argraw(n);<br>&#125;<br><br><span class="hljs-comment">// Fetch the nth word-sized system call argument as a null-terminated string.</span><br><span class="hljs-comment">// Copies into buf, at most max.</span><br><span class="hljs-comment">// Returns string length if OK (including nul), -1 if error.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">argstr</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> max)</span><br>&#123;<br>  uint64 addr;<br>  argaddr(n, &amp;addr);<br>  <span class="hljs-keyword">return</span> fetchstr(addr, buf, max);<br>&#125;<br></code></pre></td></tr></table></figure><p>有些系统调用会传递指针作为参数，这会导致两个问题：</p><ol><li>用户程序可能是恶意的或者有bug，导致传递进来的地址是无效的。</li><li>由于内核页表和用户页表映射不同，用户传递的地址无法直接使用。</li></ol><p>内核提供了函数来从用户地址中读写数据。</p><p> <code>exec</code> 使用 <code>fetchstr</code> 来从用户空间中获取一个字符串参数。 <code>fetchstr</code> 调用 <code>copyinstr</code> 来完成数据拷贝的任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Fetch the nul-terminated string at addr from the current process.</span><br><span class="hljs-comment">// Returns length of string, not including nul, or -1 for error.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fetchstr</span><span class="hljs-params">(uint64 addr, <span class="hljs-type">char</span> *buf, <span class="hljs-type">int</span> max)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>  <span class="hljs-keyword">if</span>(copyinstr(p-&gt;pagetable, buf, addr, max) &lt; <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(buf);<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>copyinstr</code> 至多从用户页表pagetable中的虚拟地址srcva指定的地方拷贝max字节到dst指定的地方。</p><p>因为pagetable不是当前的页表，所以 <code>copyinstr</code> 使用 <code>walkaddr</code> 在pagetable中查找虚拟地址srcva，并获得相应的物理地址pa0。之后可以直接进行拷贝操作。类似的，<code>copyout</code> 将数据从内核拷贝到用户空间中。</p><h2 id="4-5-Traps-from-kernel-space"><a href="#4-5-Traps-from-kernel-space" class="headerlink" title="4.5 Traps from kernel space"></a>4.5 Traps from kernel space</h2><p>xv6以一种不同的方式处理来自内核的trap。当进入内核后，usertrap会将stvec的值指向kernelvec。因为执行kernelvec的时候，一定已经在S态了，satp已经是内核页表，并且sp也指向内核栈。kernelvec将32个寄存器的值保存到内核栈中。之后会跳转到kerneltrap执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">kernelvec:<br>    # make room to save registers.<br>    addi sp, sp, -256<br><br>    # save caller-saved registers.<br>    sd ra, 0(sp)<br>    sd sp, 8(sp)<br>    sd gp, 16(sp)<br>    sd tp, 24(sp)<br>    sd t0, 32(sp)<br>    sd t1, 40(sp)<br>    sd t2, 48(sp)<br>    sd a0, 72(sp)<br>    sd a1, 80(sp)<br>    sd a2, 88(sp)<br>    sd a3, 96(sp)<br>    sd a4, 104(sp)<br>    sd a5, 112(sp)<br>    sd a6, 120(sp)<br>    sd a7, 128(sp)<br>    sd t3, 216(sp)<br>    sd t4, 224(sp)<br>    sd t5, 232(sp)<br>    sd t6, 240(sp)<br><br>    # call the C trap handler in trap.c<br>    call kerneltrap<br></code></pre></td></tr></table></figure><p>kerneltrap只处理两种类型的trap：设备中断和异常。它调用devintr来处理设备中断。如果不是设备中断，那就一定是异常，内核中的异常通常意味着fatal error，内核调用panic之后停止执行。</p><p>如果kerneltrap处理的是时钟中断，并且当前进程的内核线程正在运行，kerneltrap会调用yield将CPU使用权让出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// interrupts and exceptions from kernel code go here via kernelvec,</span><br><span class="hljs-comment">// on whatever the current kernel stack is.</span><br><span class="hljs-type">void</span> <br><span class="hljs-title function_">kerneltrap</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-type">int</span> which_dev = <span class="hljs-number">0</span>;<br>  uint64 sepc = r_sepc();<br>  uint64 sstatus = r_sstatus();<br>  uint64 scause = r_scause();<br>  <br>  <span class="hljs-keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kerneltrap: not from supervisor mode&quot;</span>);<br>  <span class="hljs-keyword">if</span>(intr_get() != <span class="hljs-number">0</span>)<br>    panic(<span class="hljs-string">&quot;kerneltrap: interrupts enabled&quot;</span>);<br><br>  <span class="hljs-keyword">if</span>((which_dev = devintr()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-comment">// interrupt or trap from an unknown source</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;scause=0x%lx sepc=0x%lx stval=0x%lx\n&quot;</span>, scause, r_sepc(), r_stval());<br>    panic(<span class="hljs-string">&quot;kerneltrap&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// give up the CPU if this is a timer interrupt.</span><br>  <span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span> &amp;&amp; myproc() != <span class="hljs-number">0</span>)<br>    yield();<br><br>  <span class="hljs-comment">// the yield() may have caused some traps to occur,</span><br>  <span class="hljs-comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span><br>  w_sepc(sepc);<br>  w_sstatus(sstatus);<br>&#125;<br></code></pre></td></tr></table></figure><p>当kerneltrap完成后，它需要返回之前被中断的代码继续执行。因为yield可能会破坏sepc和sstatus中的值，所以kerneltrap需要在开始的时候保存它们。因此，kerneltrap完成后需要先恢复这些控制寄存器的值，然后返回到kernelvec。kernelvec从栈中恢复寄存器的值，然后执行sret指令，将sepc的值拷贝到pc中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># restore registers.<br>    ld ra, 0(sp)<br>    ld sp, 8(sp)<br>    ld gp, 16(sp)<br>    # not tp (contains hartid), in case we moved CPUs<br>    ld t0, 32(sp)<br>    ld t1, 40(sp)<br>    ld t2, 48(sp)<br>    ld a0, 72(sp)<br>    ld a1, 80(sp)<br>    ld a2, 88(sp)<br>    ld a3, 96(sp)<br>    ld a4, 104(sp)<br>    ld a5, 112(sp)<br>    ld a6, 120(sp)<br>    ld a7, 128(sp)<br>    ld t3, 216(sp)<br>    ld t4, 224(sp)<br>    ld t5, 232(sp)<br>    ld t6, 240(sp)<br><br>    addi sp, sp, 256<br><br>    # return to whatever we were doing in the kernel.<br>    sret<br></code></pre></td></tr></table></figure><p>当从用户态进入内核的时候，xv6会设置CPU的stvec指向kernelvec。在内核开始执行和stvec指向kernelvec之间会有一段时间（执行uservec的代码的时候已经处于S态，但是直到usertrap中才修改stvec的值指向kernelvec），RISC-V在处理一个trap的时候关闭设备中断，usertrap直到设置好stvec之后才重新使能设备中断，因此可以确保这段时间不会有设备中断，否则就会导致来自S态的trap错误的被uservec处理。</p><h2 id="4-6-Page-fault-exceptions"><a href="#4-6-Page-fault-exceptions" class="headerlink" title="4.6 Page-fault exceptions"></a>4.6 Page-fault exceptions</h2><p>xv6对异常的处理比较简单，如果异常来自用户态，则内核杀死发生异常的进程，如果异常来自S态，则内核panics。真实的操作系统往往有更加复杂的处理方式。</p><p><strong>写时复制</strong></p><p>许多内核通过页错误来实现写实复制（copy on write， COW）fork。考虑xv6实现的fork，通过uvmcopy分配内存并将父进程的内存拷贝一份。如果可以共享父进程的内存将提高效率，然后，普通的实现将导致父子进程互相干扰。</p><p>为了解决这个问题，父子进程可以通过恰当的设置页表权限和页错误来解决这个问题。当：</p><ul><li>某个虚拟地址在页表中没有映射</li><li>页表项的v位置0</li><li>页表项的某些权限位禁止操作</li></ul><p>的时候，CPU会发起一个页错误异常。</p><p>xv6中区分三种页错误：</p><ol><li>读页错误</li><li>写页错误</li><li>指令页错误</li></ol><p>通过scause寄存器指明页错误的种类，stval寄存器保存发生错误的虚拟地址。</p><p>COWfork的想法是初始的时候父子进程共享相同的物理页，但是父子进程页表中相应的页表项标记为只读（PTE_W置0）。父子进程可以顺利的读共享的页，但是当任何一个进程试图写共享的页的时候，会引发一个页错误。内核此时在复制一份共享的页面，然后修改相应进程的页表中的页表项，然后返回到发生异常的指令重新执行。</p><p>COW需要一个记录来帮助决定什么时候可以释放掉一个物理页面，因为每个物理页面可能会被多个进程共享。有了这个记录，在发生写页错误的时候，内核可以根据记录来查看当前共享这个物理页面的进程数，如果只有一个进程，那么就无需进行复制（假设父子进程共享一个页面，然后子进程退出了，父进程此时再写会触发页错误，但是无需复制）。</p><p><strong>lazy allocation</strong></p><p>通过页错误，我们还可以实现lazy allocation。当一个进程通过sbrk申请更多内存的时候，内核仅仅记录大小的更改，但是不实际申请物理页和创建页表项。但在这些新的虚拟地址上发生页错误的时候，内核再实际去申请物理内存。</p><ul><li><p>lazy allocation的优势：</p><ol><li>因为应用总是会申请更多的内存（实际不需要这么多），所以lazy allocation很有必要。</li><li>当应用申请很大的内存的时候，一次sbrk的开销是很大的，可以通过lazy allocation平均这些开销。</li></ol></li><li><p>lazy allocation的缺点：</p><p>会引发页错误，导致用户态到S态的切换。可以通过每次申请一连串的页来减少页错误的次数；也可以通过特化页错误的代码来降低开销。</p></li></ul><p><strong>请求分页</strong></p><p>在xv6中，调用exec的时候会把程序的完整镜像加载到内存中，如果镜像很大，这个开销会非常大。现代操作系统通过请求分页机制来分摊这个开销。通常只是在页表中建立相应的页表项，但并不实际读取硬盘，将页表项的PTE_V字段置0，当程序实际访问该虚拟地址指向的内容的时候，在将物理页读入内存。</p><p>运行在计算机上的程序可能需要的内存超出计算机的 RAM。为了解决这个问题，操作系统可以实现磁盘分页。其基本思路是将仅一部分用户页面存储在 RAM 中，而将其余页面存储在磁盘的分页区域中。内核会将对应于存储在分页区域（即不在 RAM 中）的内存的页表项（PTE）标记为无效。如果应用程序尝试使用已经分页到磁盘的页面，就会发生页面错误，此时需要将该页面调入：内核的trap处理程序将分配一页物理 RAM，将页面从磁盘读入 RAM，并修改相关的 PTE 以指向该 RAM。</p><p>如果需要调入的页面时没有空闲的物理 RAM，会发生什么呢？在这种情况下，内核必须首先通过将一页物理内存分页出去或驱逐到磁盘的分页区域来释放一页物理页面，并将引用该物理页面的 PTE 标记为无效。驱逐操作开销较大，因此分页性能最佳的情况是尽量少发生页面错误：如果应用程序只使用其内存页面的一个子集，而这些子集的并集可以分配在 RAM 中，这种属性通常被称为良好的局部性。</p><p>在许多虚拟内存技术中，内核通常以对应用程序透明的方式实现磁盘分页。尽管硬件提供了大量的 RAM，但计算机通常会有很少或没有空闲的物理内存。例如，云服务提供商通常在一台机器上多路复用多个客户，以高效利用硬件成本；另一个例子是用户在智能手机上运行多个应用程序，而物理内存又非常有限。在这种情况下，分配一个页面可能需要首先驱逐一个现有页面。因此，当空闲物理内存稀缺时，分配成本较高。</p><p>懒惰分配和按需分页在空闲内存稀缺且程序仅积极使用其分配内存的一部分时尤其有利。这些技术还可以避免在页面被分配或加载但从未使用或在使用之前被驱逐时浪费的工作。</p><p>结合分页和页面错误异常的其他特性包括自动扩展堆栈和内存映射文件（memory-mapped files），即程序通过 <code>mmap</code> 系统调用映射到其地址空间的文件，使得程序可以通过加载和存储指令读取和写入这些文件。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Xv6 Chapter 3</title>
    <link href="/2024/09/25/MIT-6-1810-Xv6-Chapter-3/"/>
    <url>/2024/09/25/MIT-6-1810-Xv6-Chapter-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Page-tables"><a href="#Page-tables" class="headerlink" title="Page tables"></a>Page tables</h1><span id="more"></span><h2 id="3-1-Paging-hardware"><a href="#3-1-Paging-hardware" class="headerlink" title="3.1 Paging hardware"></a>3.1 Paging hardware</h2><p>RISC-V的指令操控的是虚拟地址，而物理内存是按照物理地址索引的。页表硬件负责进行虚拟地址和物理地址的转换。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-3/image-20240925134044836.png"></p><p>xv6运行在Sv39 RISC-V上，只使用64位虚拟地址的低39位。在这种情况下，页表逻辑上是一个2^27次方的页表项（Page table entrie，PTE）数组，每个PTE包含44位物理页码（Physical page number， PPN）和一些标识位。页表硬件将虚拟地址低39位的高27位作为页表索引，然后将取得的44位PPN作为高44位，虚拟地址的低12位作为页内偏移，获得一个56位的物理地址。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-3/image-20240925143042508.png"></p><p>xv6中采取的是三级页表，第一级页表页的物理起始地址由satp寄存器保存，27位的高9位用来索引第一级页表，第一级页表页表项的PPN字段是第二级页表页的起始物理地址，27位的中间9位用来索引第二级页表，其页表项的PPN字段是第三级页表页的起始物理地址，27位的低9位用来索引第三级页表，其页表项的PPN字段是实际访问内存页的物理地址。每级页表页大小为一页，包含512个页表项。</p><p>在上述地址转换过程中，如果某个页表项不存在，都会引发一个页面错误异常（page fault exception），由内核负责处理这个异常。</p><p>采取这种多级页表的好处是节省了内存空间，用不到的页表页将不会占据空间；缺点是在地址转化的时候需要进行多次访问。以三级页表为例，首先需要访问第一级页表获取第二级页表的物理地址，然后需要访问第二级页表获取第三级页表的物理地址，再访问第三级页表获取实际物理页的物理地址，之后才能访问我们实际需要读取的数据。为了解决这个问题，CPU可以将一些页表项缓存到TLB（Translation Look-aside Buffer）中，这样，如果在TLB中命中，则直接可以拿到实际物理页的物理地址，不需要进行额外的访存操作。</p><p>xv6中和页表硬件相关的结构定义在（kernel&#x2F;riscv.h）中。</p><p>每个CPU都有自己的satp寄存器，该寄存器指定了第一级页表的物理地址。</p><h2 id="3-2-Kernel-address-space"><a href="#3-2-Kernel-address-space" class="headerlink" title="3.2 Kernel address space"></a>3.2 Kernel address space</h2><p>xv6为每个进程维护一个页表，并且维护一个单独的页表指明内核地址空间。内核配置内存空间的布局使其可以访问物理内存和各种设备资源，如图3.3所示。内核内存布局用到的常量定义在kernel&#x2F;memlayout.h里。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-3/image-20240925145411714.png"></p><p>QEMU 模拟了一个计算机系统，物理内存（RAM）从物理地址 0x80000000 开始，至少延续到 0x88000000，称为 PHYSTOP。QEMU 还包含了 I&#x2F;O 设备，比如磁盘接口。这些设备接口通过内存映射控制寄存器暴露给软件，这些寄存器位于物理地址空间的 0x80000000 之下。内核可以通过读取或写入这些特殊的物理地址与设备进行交互；这样的读写操作是与设备硬件直接通信，而不是与 RAM 进行交互。第 4 章将解释 xv6 如何与这些设备进行交互。</p><p>内核通过“直接映射”访问 RAM 和内存映射的设备寄存器，即将资源映射到与物理地址相同的虚拟地址。例如，内核本身位于虚拟地址空间和物理内存中的  <code>KERNBASE=0x80000000</code> 。直接映射简化了内核读取或写入物理内存的代码。</p><ul><li><p><strong>直接映射</strong>：在直接映射中，虚拟地址与物理地址相等，这意味着内核可以使用相同的地址来访问内存。这种方式使得内核在处理物理内存时更加简便，不需要额外的地址转换。</p></li><li><p><strong>内存分配示例</strong>：例如，在 <code>fork</code> 系统调用中，当为子进程分配用户内存时，分配器返回的是物理内存地址。由于内核采用直接映射，<code>fork</code> 可以直接将这个物理地址作为虚拟地址使用，将父进程的用户内存内容复制到子进程中。这减少了需要进行地址转换的复杂性。</p></li></ul><p>在内核的虚拟地址空间中，有几个地址并不是直接映射的，包括：</p><ol><li><p><strong>Trampoline Page</strong></p><ul><li><p><strong>映射位置</strong>：Trampoline 页位于虚拟地址空间的顶部，并且用户页面表也具有相同的映射。</p></li><li><p><strong>作用</strong>：Trampoline 页用于实现上下文切换等功能。它的物理页面（存放 Trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次在虚拟空间的顶部，另一次是直接映射的地址。</p></li><li><p><strong>特点</strong>：这种设计展示了页面表的灵活使用，能够在需要时同时使用不同的映射。</p></li></ul></li><li><p><strong>Kernel Stack Pages</strong></p><ul><li><p><strong>每个进程的内核栈</strong>：每个进程都有自己的内核栈，这些栈映射在高地址，以便在它们下面保留一个未映射的保护页（guard page）。</p></li><li><p><strong>保护页</strong>：保护页的页表项（PTE）是无效的（即 PTE_V 没有设置），因此如果内核栈溢出，它将可能导致异常，从而引发内核恐慌（panic）。没有保护页的情况下，溢出的栈可能会覆盖其他内核内存，导致错误操作。</p></li><li><p><strong>映射设计</strong>：内核通过高内存映射使用这些栈，但也可以通过直接映射的地址访问它们。如果只使用直接映射而不设置保护页，处理保护页将涉及取消映射原本指向物理内存的虚拟地址，这将变得难以使用。</p></li></ul></li></ol><p><strong>权限设置</strong></p><ul><li><strong>Trampoline 页和内核文本的映射</strong>：这些页面的权限设置为 PTE_R（可读）和 PTE_X（可执行），内核可以从这些页面读取和执行指令。</li><li><strong>其他页面的映射</strong>：其他页面的权限设置为 PTE_R（可读）和 PTE_W（可写），允许内核读取和写入这些页面的内存。</li><li><strong>保护页的映射</strong>：保护页的映射是无效的，以防止访问。</li></ul><h2 id="3-3-Code-creating-an-address-space"><a href="#3-3-Code-creating-an-address-space" class="headerlink" title="3.3  Code: creating an address space"></a>3.3  Code: creating an address space</h2><p>xv6中大多数操控地址空间和页表的代码在vm.c中。</p><p>核心数据结构是 <code>pagetable_t</code> ，这是一个指向第一级页表的指针，它要么指向内核页表，要么指向进程自己的页表。</p><p>核心函数有：</p><ul><li><code>walk</code> - 找到一个虚拟地址对应的PTE</li><li><code>mappages</code> - 为新的映射设立PTE</li></ul><p>以kvm为前缀的函数操作内核页表；以uvm为前缀的函数操作进程页表；其它函数两者都可以操作。</p><p>在 xv6 操作系统中，<code>copyout</code> 和 <code>copyin</code> 函数用于将数据复制到用户虚拟地址和从用户虚拟地址复制数据，这些地址作为系统调用参数传入。这些函数在 <code>vm.c</code> 文件中实现，因为它们需要显式地转换这些地址以找到对应的物理内存。</p><p><strong>内核的页表创建</strong>：</p><ul><li>在启动序列的早期，<code>main</code> 函数调用 <code>kvminit</code> 来创建内核的页表。此调用发生在 xv6 启用分页之前，因此地址直接指向物理内存。</li><li><code>kvmmake</code> 首先分配一页物理内存，用于存放根页面表。然后，它调用 <code>kvmmap</code> 安装内核所需的地址转换，包括内核的指令和数据、到 PHYSTOP 的物理内存，以及实际上是设备的内存范围。</li></ul><p><strong>分配内核栈</strong>：</p><ul><li><code>proc_mapstacks</code> 为每个进程分配一个内核栈。它调用 <code>kvmmap</code> 将每个栈映射到由 <code>KSTACK</code> 生成的虚拟地址，这样可以为无效的栈保护页留出空间。</li></ul><p><strong>页面映射的安装</strong>：</p><ul><li><code>kvmmap</code> 调用 <code>mappages</code>，将虚拟地址范围映射到相应的物理地址范围。对于范围内的每个虚拟地址，<code>mappages</code> 分别处理，并按页间隔进行映射。</li><li>对于每个需要映射的虚拟地址，<code>mappages</code> 调用 <code>walk</code> 找到该地址的页面表项（PTE）。然后，它初始化 PTE，以保存相关的物理页面编号、所需的权限（PTE_W、PTE_X 和&#x2F;或 PTE_R），并设置 PTE_V 将 PTE 标记为有效。</li></ul><p><strong>PTE 查找</strong></p><ul><li><strong>walk 函数</strong>：<code>walk</code> 函数模拟 RISC-V 的分页硬件，逐级查找虚拟地址的 PTE。它使用每级地址的 9 位虚拟地址索引相关的页面目录页。每一层中，它找到的是下一层页面目录页的 PTE，或者是最终页面的 PTE。</li><li>如果一级或二级页面目录页中的 PTE 无效，则所需的目录页尚未分配；如果 <code>alloc</code> 参数被设置，<code>walk</code> 将分配一个新的页面表页，并将其物理地址放入 PTE 中。它返回树中最低层的 PTE 地址。</li></ul><p><strong>物理内存与虚拟地址的直接映射</strong></p><p>上述代码依赖于物理内存直接映射到内核虚拟地址空间。例如，当 <code>walk</code> 函数向下查找页面表时，它从 PTE 中提取下一层页面表的物理地址，然后将该地址用作虚拟地址以获取下一层的 PTE。所以必须保证是采用直接映射。</p><p><strong>安装内核页表</strong></p><ul><li><code>main</code> 调用 <code>kvminithart</code> 安装内核页面表。它将根页面表的物理地址写入 <code>satp</code> 寄存器。此后，CPU 将使用内核页面表进行地址转换。由于内核使用直接映射，下一条指令的虚拟地址将正确映射到对应的物理内存地址。</li></ul><p><strong>TLB</strong></p><p>在 RISC-V CPU 中，页表项会被缓存到转换后备缓冲区（TLB）中。当 xv6 修改页表时，必须通知 CPU 使对应的 TLB 缓存条目失效。如果不这样做，TLB 可能会在后续使用旧的缓存映射，这可能会导致指向的物理页面被分配给其他进程，从而使一个进程能够访问或篡改另一个进程的内存。</p><p><strong>TLB 失效机制</strong></p><ul><li><p><strong>sfence.vma 指令</strong>：</p><p>RISC-V 提供了 <code>sfence.vma</code> 指令，用于刷新当前 CPU 的 TLB。xv6 在 <code>kvminithart</code> 中重新加载 <code>satp</code> 寄存器后执行此指令，同时在切换到用户页面表的 Trampoline 代码中也会调用它（在 <code>kernel/trampoline.S:89</code> 处）。</p></li><li><p><strong>确保旧表格的完整性</strong>：</p><p>在更改 <code>satp</code> 之前，也需要发出 <code>sfence.vma</code> 指令，以确保所有未完成的加载和存储操作已完成。这一等待过程确保先前对页表的更新完成，同时保证之前的加载和存储使用旧的页表，而不是新的。</p></li></ul><p><strong>地址空间标识符（ASIDs）</strong></p><ul><li>为了避免刷新整个 TLB，RISC-V CPU 可能支持地址空间标识符（ASIDs）。这样，内核可以仅刷新特定地址空间的 TLB 条目，而无需影响其他地址空间。</li><li>然而，xv6 并未使用这一特性，因此每次修改页表时仍需完全刷新 TLB。</li></ul><h2 id="3-4-Physical-memory-allocation"><a href="#3-4-Physical-memory-allocation" class="headerlink" title="3.4 Physical memory allocation"></a>3.4 Physical memory allocation</h2><p>xv6使用介于内核末尾和PHYSTOP直接的物理内存来进行运行时分配。通过页面链表来维护空闲页面，当分配的时候需要从链表中移除分配的页面，当释放的时候需要将页面添加到链表中。</p><h2 id="3-5-Code：Physical-memory-allocator"><a href="#3-5-Code：Physical-memory-allocator" class="headerlink" title="3.5 Code：Physical memory allocator"></a>3.5 Code：Physical memory allocator</h2><p>分配器代码在kalloc.c中。</p><p>分配器的数据结构是空闲页面的链表。链表中的元素是 <code>struct run</code> ，这些结构体保存在相应的空闲页面内。链表被一个自旋锁保护。</p><p> <code>main</code> 调用 <code>kinit</code> 来初始化这个分配器。 <code>kinit</code> 负责初始化链表，维护每个空闲页面。用到了 <code>freerange</code> 和 <code>kfree</code>。</p><h2 id="3-6-Process-address-space"><a href="#3-6-Process-address-space" class="headerlink" title="3.6 Process address space"></a>3.6 Process address space</h2><p>每个进程都有自己的页表，进程切换的时候会更换页表。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-3/image-20240925173235081.png"></p><p>内核在用户地址空间的顶部映射了一页包含 trampoline 代码的页面，该页面没有设置用户访问权限（PTE_U）。这样，虽然这页物理内存在所有地址空间中可见，但只有内核能够使用它。</p><p><strong>共享页面</strong>：</p><p>这页物理内存被映射到每个用户进程的地址空间中，但由于没有用户访问权限，用户进程无法访问或修改该页。</p><p><strong>内核的用途</strong>：</p><p>该页面的主要用途是在上下文切换时，内核可以通过 trampoline 代码快速切换到用户模式。这种设计简化了用户与内核之间的切换过程。</p><p><strong>安全性</strong>：</p><p>通过限制用户访问这页内存，内核能够防止潜在的安全问题，确保用户进程无法干扰或篡改关键的内核代码。</p><h2 id="3-7-Code：sbrk"><a href="#3-7-Code：sbrk" class="headerlink" title="3.7 Code：sbrk"></a>3.7 Code：sbrk</h2><h2 id="3-8-Code：exec"><a href="#3-8-Code：exec" class="headerlink" title="3.8 Code：exec"></a>3.8 Code：exec</h2>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Xv6 Chapter 2</title>
    <link href="/2024/09/24/MIT-6-1810-Xv6-Chapter-2/"/>
    <url>/2024/09/24/MIT-6-1810-Xv6-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Operating-system-organization"><a href="#Operating-system-organization" class="headerlink" title="Operating system organization"></a>Operating system organization</h1><span id="more"></span><p>一个操作系统必须满足三个需求：</p><ol><li>复用</li><li>隔离</li><li>交互</li></ol><p>xv6是用LP64C写的（long和pointer是8B，int是4B）。</p><h2 id="2-1-Abstracting-physical-resources"><a href="#2-1-Abstracting-physical-resources" class="headerlink" title="2.1 Abstracting physical resources"></a>2.1 Abstracting physical resources</h2><p>通过抽象硬件资源，可以使操作系统方便的实现复用、隔离、交互。</p><h2 id="2-2-User-mode，supervisor-mode，and-system-calls"><a href="#2-2-User-mode，supervisor-mode，and-system-calls" class="headerlink" title="2.2 User mode，supervisor mode，and system calls"></a>2.2 User mode，supervisor mode，and system calls</h2><p>隔离需要应用程序和操作系统之间有一条硬边界。</p><p>为了实现这种隔离，操作系统必须使进程不能访问操作系统的指令和数据，也不能访问其他进程的指令和数据。</p><p>CPU为这种隔离提供了硬件支持。RISC-V有三种指令执行模式：机器模式（machine mode）、内核模式（supervisor mode），用户模式（user mode）。</p><p><strong>机器模式（machine mode）</strong></p><p>该模式的指令有完整的特权。CPU初始启动的时候在该模式，然后在boot的过程中设置电脑，之后就会切换到内核模式。</p><p><strong>内核模式（supervisor mode）</strong></p><p>该模式下可以执行<strong>特权指令</strong>，例如开关中断、访问页表寄存器等。如果一个用户模式下的进程尝试执行特权指令，CPU不会执行，而是切换到内核模式，然后终止该进程。</p><p>应用想要执行内核中的函数必须切换到内核中执行，且不能直接执行内核函数，而是通过一种特殊的指令进入内核（RISV-V提供ecall指令），之后内核会去检查应用传进来的参数是否合法（例如内存是否越界，是否有权限执行这种操作等）。之所以用通过统一的指令来进入内核，是防止有的程序跳过参数检查等步骤。</p><h2 id="2-3-Kernel-organization"><a href="#2-3-Kernel-organization" class="headerlink" title="2.3 Kernel organization"></a>2.3 Kernel organization</h2><p>设计的关键是操作系统的什么部分应该在内核模式下运行。</p><p><strong>宏内核</strong></p><p>一种方法是将整个操作系统放在内核中，称为宏内核。</p><p>宏内核的优点是不用决定哪部分放在内核；操作系统不同部分合作容易。缺点是系统十分复杂，错误通常会导致整个内核崩溃。</p><p><strong>微内核</strong></p><p>另一种方法是最小化内核的代码，将大部分系统功能实现在用户模式下，称为微内核。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-2/image-20240924200038764.png"></p><p>在微内核模式下，操作系统的有些部分可以运行在用户模式的进程中，称为服务器（server）。操作系统提供一种进程间通信的方法，程序间通过互相发送消息来进行通信。</p><h2 id="2-4-Code：xv6-organization"><a href="#2-4-Code：xv6-organization" class="headerlink" title="2.4 Code：xv6 organization"></a>2.4 Code：xv6 organization</h2><p>xv6 的内核源代码位于 <code>kernel/</code> 子目录中，源代码被分为多个文件，遵循一定的模块化概念。图 2.2 列出了这些文件。模块之间的接口在 <code>defs.h</code>（即 <code>kernel/defs.h</code>）中定义。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-2/image-20240924200752501.png"></p><h2 id="2-5-Process-overview"><a href="#2-5-Process-overview" class="headerlink" title="2.5 Process overview"></a>2.5 Process overview</h2><p>xv6中隔离的最小单元是进程。</p><p>内核实现进程的机制包括用户&#x2F;特权模式标志、地址空间以及线程的时间片分配。</p><p>进程给程序提供了一种自己拥有整个地址空间和CPU的假象。</p><p>xv6 使用页表（由硬件实现）为每个进程提供独立的地址空间。RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）转换为物理地址（CPU 发送到主内存的地址）。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-2/image-20240924202734337.png"></p><p>xv6 为每个进程维护一个独立的页表，定义该进程的地址空间。如图 2.3 所示，地址空间从虚拟地址零开始，包括进程的用户内存。首先是指令，然后是全局变量，再是栈，最后是“堆”区域（用于 <code>malloc</code>），该区域可以根据需要扩展。限制进程地址空间最大大小的因素有很多：RISC-V 的指针宽度为 64 位，硬件在查找页表中的虚拟地址时仅使用低 39 位，而 xv6 只使用这 39 位中的 38 位。因此，最大地址为 (2^{38} - 1 &#x3D; 0x3fffffffff)，也就是 <code>MAXVA</code>（定义在 kernel&#x2F;riscv.h:378）。在地址空间的顶部，xv6 放置了一个 4096 字节的 trampoline 页和一个 trapframe 页。xv6 使用这两个页面进行内核的切换；trampoline 页包含切换进出内核的代码，而 trapframe 用于保存进程的用户寄存器，具体内容在第四章中解释。</p><p>内核为每个进程维护各自的状态，存放在proc结构体里（kernel&#x2F;proc.h：85）。</p><p>每个进程都有一个控制线程（简称线程），它保存执行该进程所需的状态。在任何给定时刻，线程可能在 CPU 上执行，或者处于挂起状态（未执行但能够在未来恢复执行）。要在进程之间切换 CPU，内核会挂起当前在该 CPU 上运行的线程并保存其状态，然后恢复另一个进程之前挂起的线程的状态。线程的大部分状态（局部变量、函数调用的返回地址）存储在线程的栈上。</p><p>每个进程有两个栈：用户栈和内核栈（p-&gt;kstack）。当进程执行用户指令时，仅使用其用户栈，而内核栈为空。当进程进入内核（进行系统调用或中断）时，内核代码在进程的内核栈上执行；在进程处于内核状态时，其用户栈仍然保存着数据，但不再被主动使用。进程的线程在活跃使用用户栈和内核栈之间交替切换。内核栈是独立的（并且受到保护，防止用户代码破坏），以确保即使进程破坏了其用户栈，内核也能正常执行。</p><p>进程可以通过执行 RISC-V 的 <code>ecall</code> 指令来发起系统调用。此指令提升硬件特权级，并将程序计数器更改为内核定义的入口点。入口点的代码切换到进程的内核栈，并执行实现系统调用的内核指令。当系统调用完成时，内核切换回用户栈，并通过调用 <code>sret</code> 指令返回用户空间，这将降低硬件特权级，并在系统调用指令后继续执行用户指令。进程的线程可以在内核中“阻塞”，以等待 I&#x2F;O 操作完成，并在 I&#x2F;O 完成后从上次中断的地方恢复。</p><p><code>p-&gt;state</code> 指示进程的状态，可能是已分配、准备运行、当前在 CPU 上运行、等待 I&#x2F;O 或正在退出。</p><p><code>p-&gt;pagetable</code> 保存进程的页表，格式符合 RISC-V 硬件的要求。xv6 使得分页硬件在执行进程的用户空间时使用 <code>p-&gt;pagetable</code>。进程的页表还记录了分配给该进程存储内存的物理页的地址。</p><p>总之，进程结合了两个设计理念：地址空间使进程拥有自己的内存的错觉，线程使进程拥有自己的 CPU 的错觉。在 xv6 中，进程由一个地址空间和一个线程组成。在实际的操作系统中，进程可能拥有多个线程，以利用多个 CPU。</p><h2 id="2-6-Code：starting-xv6，the-first-process-and-system-call"><a href="#2-6-Code：starting-xv6，the-first-process-and-system-call" class="headerlink" title="2.6 Code：starting xv6，the first process and system call"></a>2.6 Code：starting xv6，the first process and system call</h2><p>当RISC-V计算机上电后，首先会初始化硬件，然后执行一个存放在ROM中的boot loader。bool loader负责把xv6内核装载进内存中。然后，在机器模式下，CPU从_entry(kernel&#x2F;entry.S:7)开始执行xv6。开始时页表装置被关闭，虚拟地址直接被映射到对应的物理地址。</p><p>loader将内核装在到物理地址0x80000000，之所以装载到这里，是因为0x0-0x80000000包含了IO设备。</p><p>从代码中可以看到， <code>_entry.S</code> 为每个CPU都准备了一个栈。通过 <code>csrr</code> 指令取得当前hart的id（通常从0开始），并以该id为偏移，将不同CPU的栈错开。xv6在 <code>start.c</code> （kernel&#x2F;start.c：11）中声明了一个初始栈数组， <code>stack0</code> 。 <code>_entry</code> 中的指令将sp改为 <code>stack0+4096 * hartid</code> （栈顶）。之后 <code>_entry</code> 调用 <code>start</code> （kernel&#x2F;start.c：15）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs assembly">        # qemu -kernel loads the kernel at 0x80000000<br>        # and causes each hart (i.e. CPU) to jump there.<br>        # kernel.ld causes the following code to<br>        # be placed at 0x80000000.<br>.section .text<br>.global _entry<br>_entry:<br>        # set up a stack for C.<br>        # stack0 is declared in start.c,<br>        # with a 4096-byte stack per CPU.<br>        # sp = stack0 + (hartid * 4096)<br>        la sp, stack0<br>        li a0, 1024*4<br>        csrr a1, mhartid<br>        addi a1, a1, 1<br>        mul a0, a0, a1<br>        add sp, sp, a0<br>        # jump to start() in start.c<br>        call start<br>spin:<br>        j spin<br><br></code></pre></td></tr></table></figure><p> <code>start</code> 执行一些只能在机器模式下执行的配置，然后转入内核模式。为了进入内核模式，RISC-V提供了指令 <code>mret</code> ，这条指令通常用来从内核模式到机器模式的调用返回。 <code>start</code> 并不上述的情况，我们可以通过手动设置使之好像是这种情况。首先，设置mstatus寄存器为S态，然后设置mepc寄存器为main的地址，接下来在进行一些相应的配置。在转入内核模式之前， <code>start</code> 还使时钟芯片能够产生时钟中断。之后执行 <code>mret</code> 指令，调转到 <code>main</code> 继续执行（kernel&#x2F;main.c：11）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">timerinit</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// entry.S needs one stack per CPU.</span><br>__attribute__ ((aligned (<span class="hljs-number">16</span>))) <span class="hljs-type">char</span> stack0[<span class="hljs-number">4096</span> * NCPU];<br><br><span class="hljs-comment">// entry.S jumps here in machine mode on stack0.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">start</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">// set M Previous Privilege mode to Supervisor, for mret.</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x = r_mstatus();<br>  x &amp;= ~MSTATUS_MPP_MASK;<br>  x |= MSTATUS_MPP_S;<br>  w_mstatus(x);<br><br>  <span class="hljs-comment">// set M Exception Program Counter to main, for mret.</span><br>  <span class="hljs-comment">// requires gcc -mcmodel=medany</span><br>  w_mepc((uint64)main);<br><br>  <span class="hljs-comment">// disable paging for now.</span><br>  w_satp(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// delegate all interrupts and exceptions to supervisor mode.</span><br>  w_medeleg(<span class="hljs-number">0xffff</span>);<br>  w_mideleg(<span class="hljs-number">0xffff</span>);<br>  w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);<br><br>  <span class="hljs-comment">// configure Physical Memory Protection to give supervisor mode</span><br>  <span class="hljs-comment">// access to all of physical memory.</span><br>  w_pmpaddr0(<span class="hljs-number">0x3fffffffffffff</span>ull);<br>  w_pmpcfg0(<span class="hljs-number">0xf</span>);<br><br>  <span class="hljs-comment">// ask for clock interrupts.</span><br>  timerinit();<br><br>  <span class="hljs-comment">// keep each CPU&#x27;s hartid in its tp register, for cpuid().</span><br>  <span class="hljs-type">int</span> id = r_mhartid();<br>  w_tp(id);<br><br>  <span class="hljs-comment">// switch to supervisor mode and jump to main().</span><br>  <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;mret&quot;</span>)</span>;<br>&#125;<br><br><span class="hljs-comment">// ask each hart to generate timer interrupts.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">timerinit</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-comment">// enable supervisor-mode timer interrupts.</span><br>  w_mie(r_mie() | MIE_STIE);<br>  <br>  <span class="hljs-comment">// enable the sstc extension (i.e. stimecmp).</span><br>  w_menvcfg(r_menvcfg() | (<span class="hljs-number">1L</span> &lt;&lt; <span class="hljs-number">63</span>)); <br>  <br>  <span class="hljs-comment">// allow supervisor to use stimecmp and time.</span><br>  w_mcounteren(r_mcounteren() | <span class="hljs-number">2</span>);<br>  <br>  <span class="hljs-comment">// ask for the very first timer interrupt.</span><br>  w_stimecmp(r_time() + <span class="hljs-number">1000000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>main</code> 首先初始化几个设别和子系统，然后通过调用 <code>userinit</code> （kernel&#x2F;proc.c）来创建第一个用户进程。第一个进程执行一个用RISC-V汇编写的小程序，这个小程序执行了xv6中的第一个系统调用。这个小程序在initcode.S中，它实际执行了 <code>exec(init, argv)</code> 。 它将 <code>exec</code> 系统调用号（SYS_EXEC）load进寄存器a7，然后执行 <code>ecall</code> 指令重新进入内核。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;memlayout.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;riscv.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span></span><br><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> started = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// start() jumps here in supervisor mode on all CPUs.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(cpuid() == <span class="hljs-number">0</span>)&#123;<br>    consoleinit();<br>    printfinit();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xv6 kernel is booting\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    kinit();         <span class="hljs-comment">// physical page allocator</span><br>    kvminit();       <span class="hljs-comment">// create kernel page table</span><br>    kvminithart();   <span class="hljs-comment">// turn on paging</span><br>    procinit();      <span class="hljs-comment">// process table</span><br>    trapinit();      <span class="hljs-comment">// trap vectors</span><br>    trapinithart();  <span class="hljs-comment">// install kernel trap vector</span><br>    plicinit();      <span class="hljs-comment">// set up interrupt controller</span><br>    plicinithart();  <span class="hljs-comment">// ask PLIC for device interrupts</span><br>    binit();         <span class="hljs-comment">// buffer cache</span><br>    iinit();         <span class="hljs-comment">// inode table</span><br>    fileinit();      <span class="hljs-comment">// file table</span><br>    virtio_disk_init(); <span class="hljs-comment">// emulated hard disk</span><br>    userinit();      <span class="hljs-comment">// first user process</span><br>    __sync_synchronize();<br>    started = <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">while</span>(started == <span class="hljs-number">0</span>)<br>      ;<br>    __sync_synchronize();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hart %d starting\n&quot;</span>, cpuid());<br>    kvminithart();    <span class="hljs-comment">// turn on paging</span><br>    trapinithart();   <span class="hljs-comment">// install kernel trap vector</span><br>    plicinithart();   <span class="hljs-comment">// ask PLIC for device interrupts</span><br>  &#125;<br><br>  scheduler();        <br>&#125;<br></code></pre></td></tr></table></figure><p>内核在 <code>syscall</code> 中使用a7寄存器中的值去调用指定的系统调用，即 <code>exec</code> 。系统调用表（system call table）（kernel&#x2F;syscall.c：107）将SYS_EXEC映射到系统调用 <code>sys_exec</code> 。之后 <code>exec</code> 会把内存和寄存器替换为 <code>init</code> （user&#x2F;init.c：15）的内存镜像。</p><p>当内核完成 <code>exec</code> 调用后，会返回用户空间执行 <code>init</code> 函数。该函数首先创建一个新的控制台设备文件，并通过文件描述符 0、1 和 2 打开它。随后，<code>init</code> 在该控制台上启动 shell，至此，系统已经启动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// init: The initial user-level program</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/spinlock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/sleeplock.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/file.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">char</span> *argv[] = &#123; <span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> pid, wpid;<br><br>  <span class="hljs-keyword">if</span>(open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="hljs-number">0</span>)&#123;<br>    mknod(<span class="hljs-string">&quot;console&quot;</span>, CONSOLE, <span class="hljs-number">0</span>);<br>    open(<span class="hljs-string">&quot;console&quot;</span>, O_RDWR);<br>  &#125;<br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stdout</span><br>  dup(<span class="hljs-number">0</span>);  <span class="hljs-comment">// stderr</span><br><br>  <span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: starting sh\n&quot;</span>);<br>    pid = fork();<br>    <span class="hljs-keyword">if</span>(pid &lt; <span class="hljs-number">0</span>)&#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: fork failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)&#123;<br>      exec(<span class="hljs-string">&quot;sh&quot;</span>, argv);<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: exec sh failed\n&quot;</span>);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>      <span class="hljs-comment">// this call to wait() returns if the shell exits,</span><br>      <span class="hljs-comment">// or if a parentless process exits.</span><br>      wpid = wait((<span class="hljs-type">int</span> *) <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span>(wpid == pid)&#123;<br>        <span class="hljs-comment">// the shell exited; restart it.</span><br>        <span class="hljs-keyword">break</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(wpid &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;init: wait returned an error\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// it was a parentless process; do nothing.</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.1810]Xv6 Chapter 1</title>
    <link href="/2024/09/24/MIT-6-1810-Xv6-Chapter-1/"/>
    <url>/2024/09/24/MIT-6-1810-Xv6-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Operating-system-interfaces"><a href="#Operating-system-interfaces" class="headerlink" title="Operating system interfaces"></a>Operating system interfaces</h1><span id="more"></span><p>操作系统的工作是：</p><ol><li>在多个程序间共享一台电脑</li><li>提供一套比硬件更有用的服务</li></ol><p>操作系统：</p><ol><li>管理并抽象底层硬件</li><li>在多个程序间共享硬件</li><li>提供一种受控的程序交互方式</li></ol><p>操作系统是通过接口来向程序提供服务的。</p><p>每个进程（运行中的程序），都有指令、数据、栈。</p><p>进程通过系统调用（system call）来使用操作系统提供的服务。</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-1/image-20240924132438222.png"></p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-1/image-20240924132532714.png"></p><h2 id="1-1-Processes-and-memory"><a href="#1-1-Processes-and-memory" class="headerlink" title="1.1 Processes and memory"></a>1.1 Processes and memory</h2><p>进程由用户空间的内存（指令、数据、栈）和一些状态组成。xv6是分时操作系统，每个进程都有一个唯一的PID来标识。</p><p><strong><code>fork</code> 系统调用</strong></p><p><code>fork</code>系统调用完全复制调用者的内存给新进程，然后在原进程和新进程中返回，原进程中返回值为新进程的PID，新进程中的返回值为0。</p><p>需要注意的是，父子进程之间的内存空间是相互独立的，即每个进程都有一份自己的拷贝。</p><p><strong><code>wait</code> 系统调用</strong></p><p><code>wait</code>系统调用返回当前进程的一个退出的子进程的PID，并且将子进程的退出状态拷贝到指定内存中。如果没有退出的子进程，<code>wait</code>阻塞等待。如果当前进程没有子进程，<code>wait</code>立即返回-1。如果不关心子进程的退出状态，可以传入一个0地址。</p><p><strong><code>exec</code>系统调用</strong></p><p><code>exec</code>系统调用负责用存储在文件系统中的可执行文件加载新的内存镜像，替换调用进程的内存。这个可执行文件必须遵循特定格式，定义了文件的各个部分，例如哪些部分包含指令和数据，以及从哪个指令开始执行。在 xv6 中，使用的是 ELF（可执行与可链接格式），详见第三章。</p><p>通常，这个可执行文件是通过编译程序源代码生成的。当 <code>exec</code> 成功调用时，控制权不会返回到原程序，而是从 ELF 头部指定的入口点开始执行新加载的指令。<code>exec</code> 需要两个参数：可执行文件的名称和一个字符串数组，包含传递给新进程的参数。大多数程序通常会忽略掉字符串数组的第一个参数，一般是程序的名字。</p><p><strong>为什么 <code>fork</code> 和 <code>exec</code> 是分离的</strong></p><p>操作系统利用这种分离机制实现IO重定向。同时，为了避免创建一个子进程然后马上调用 <code>exec</code> 调换掉内存，操作系统通过虚拟内存的一些技巧来优化，例如copy on write。</p><p><strong>申请内存</strong></p><p>xv6大多数时候隐式申请用户空间的内存，但是进程也可以通过调用 <code>sbrk(n)</code> 来申请更多的内存空间，该函数返回申请内存的起始地址。</p><h2 id="1-2-I-O-and-File-descriptors"><a href="#1-2-I-O-and-File-descriptors" class="headerlink" title="1.2 I&#x2F;O and File descriptors"></a>1.2 I&#x2F;O and File descriptors</h2><p>文件描述符是一个整数，代表着一个内核管理的object，进程可以从这个object读，或向这个object写。</p><p>一个进程可以通过</p><ol><li>打开文件、目录、设别</li><li>创建管道；</li><li>duplicating一个文件描述符</li></ol><p>来获得文件描述符。</p><p>文件描述符这种抽象使得我们可以不用关注文件的种类，无论是文件、管道、设备，我们都将他们视为字节流来处理。</p><p>内部，xv6内核将文件描述符用作每个进程的打开文件表的索引。通常，一个进程从文件描述符0读取输入（标准输入），向文件描述符1输出（标准输出），将错误信息输出到文件描述符2（标准错误）。</p><p><strong><code>read(fd, buf, n)</code> 系统调用</strong></p><p>该系统调用从fd指向的object读取至多n个字节，拷贝到buf内，并返回读取的字节数。</p><p>每个文件描述符都有一个关联的偏移量，<code>read</code> 会更新这个偏移量，指向下一个未被读取的字节。</p><p>当没有更多的字节可读时，<code>read</code> 会返回0。</p><p> <strong><code>write(fd, buf, n)</code> 系统调用</strong></p><p>该系统调用向fd写n个字节，返回实际写入的字节数。只有当错误发生的时候，实际写入的字节数才不等于n。</p><p> <strong><code>close(fd)</code> 系统调用</strong></p><p>该系统调用释放一个文件描述符，使之可以为之后的文件使用。</p><p>一个新的文件描述符总是当前进程中最小的未使用的文件描述符。</p><p> <strong><code>fork</code> 和文件描述符</strong></p><p><code>fork</code> 会将父进程的打开文件表复制给子进程，子进程和父进程的打开文件是一样的。</p><p><code>exec</code>  会替换调用进程的内存，但是会保留打开文件表。</p><p>这种行为使得shell可以简单的实现IO重定向。</p><p> <code>cat &lt; input.txt</code> 的简单实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;cat&quot;</span>;<br>argv[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-comment">// child</span><br>    close(<span class="hljs-number">0</span>);<br>    open(<span class="hljs-string">&quot;input.txt&quot;</span>, O_RDONLY);<br>    exec(<span class="hljs-string">&quot;/bin/cat&quot;</span>, argv);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点是子进程先关闭了文件描述符0，然后再打开input.txt，这是操作系统会将文件描述符0分配给这个文件。</p><p>父进程的文件描述符并不会被改变，因为子进程有一张自己的打开文件表。</p><p>需要注意的是，虽然fork会复制打开文件表，但是每个文件描述符关联的偏移在父子进程间是共享的。</p><p> <strong><code>open</code> 系统调用</strong></p><p>该系统调用打开一个文件，并返回相应的文件描述符。</p><p>第二个参数可以是(kerenl&#x2F;fcntl.h)：</p><ul><li>O_RDONLY</li><li>O_WRONLY</li><li>O_RDWR</li><li>O_CREATE</li><li>O_TRUNC</li></ul><p> <strong><code>dup(fd)</code> 系统调用</strong></p><p>该系统调用复制一个文件描述符，返回一个指向相同object的文件描述符。这两个文件描述符共享偏移，类似fork。</p><blockquote><p>Two file descriptors share an offset if they were derived from the same original file descriptor by a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if they resulted from open calls for the same file</p></blockquote><p>通过 <code>fork</code> 和 <code>dup</code> 获得的文件描述符和都共享相同的偏移。</p><h2 id="1-3-Pipes"><a href="#1-3-Pipes" class="headerlink" title="1.3 Pipes"></a>1.3 Pipes</h2><p>管道是内核中的一个小缓冲区，通过一对文件描述符暴露给进程。这是进程间通信的一种方式。</p><p> <strong><code>pipe</code> 系统调用</strong></p><p>该系统调用创建一个新的管道，并将一对文件描述符放到参数指定的整数数组中。</p><p>如果没有可读数据，读一个管道可能会：</p><ul><li>阻塞直到数据到来</li><li>阻塞直到所有对管道写端的文件描述符被关闭</li></ul><p>第二种情况会返回0。</p><p>管道相较临时文件的优势：</p><ol><li>管道会自动清理</li><li>管道可以处理任意长度的数据，而临时文件必须要求硬盘有足够的空间</li><li>管道允许管道的不同阶段并行执行</li></ol><h2 id="1-4-File-system"><a href="#1-4-File-system" class="headerlink" title="1.4 File system"></a>1.4 File system</h2><p>xv6文件系统提供数据文件，包含字节流；提供目录，包含指向数据文件和其他目录文件的引用。</p><p>目录以树的形式组织，以&#x2F;开始的路径以根目录为根，不以&#x2F;开始的路径以当前进程当前的工作目录为根（可以通过<code>chdir</code>系统调用来改变）。</p><p><code>mkdir</code> 系统调用创建一个新的目录，<code>open</code> 系统调用通过指定 <code>O_CREATE</code> 选项来创建一个新的数据文件， <code>mknode</code> 系统调用创建一个新的设备文件。该系统调用通过两个参数来唯一标识一个内核设备（主、副设备号）。</p><p>文件名和文件本身是不同的。同一个文件由一个唯一的inode来标识；同一个文件可以有多个文件名，即链接。</p><p>每个链接由一个目录中的目录项组成，这个目录项包含一个文件名以及一个指向文件inode的指针。</p><p>每个inode保存着文件的元数据，包括种类，长度，磁盘位置，以及链接数等。</p><p> <strong><code>fstat</code> 系统调用</strong></p><p>该系统调用从inode中获取文件的元数据，并将数据填入 <code>stat</code> 结构体中。（kernel&#x2F;stat.h）</p><p><img src="/../images/MIT-6-1810-Xv6-Chapter-1/image-20240924153124059.png"></p><p> <strong><code>link</code> 系统调用</strong></p><p>该系统调用创建一个链接。读写该链接和读写原文件操作的是同一个文件。</p><p> <code>unlink</code> 系统调用</p><p>该系统调用删除一个链接。只有当指向同一个inode的所有链接都被删除的时候，才会真正释放inode和文件内容。</p><p>一种约定俗称的创建一个临时inode方法:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">fd = open(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>, O_CREATE | O_RDWR);<br>unlink(<span class="hljs-string">&quot;/tmp/xyz&quot;</span>);<br></code></pre></td></tr></table></figure><p>当进程调用close或者退出后，这个inode会被自动清理。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++] 返回值优化</title>
    <link href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"/>
    <url>/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是返回值优化？"><a href="#什么是返回值优化？" class="headerlink" title="什么是返回值优化？"></a>什么是返回值优化？</h3><p><strong>返回值优化</strong>（Return Value Optimization, RVO）是C++编译器的一种优化技术，用于减少不必要的对象拷贝，特别是在函数返回临时对象的场景中。RVO 可以显著提高程序性能，并减少临时对象的生成和析构操作。</p><span id="more"></span><p>在C++中，函数返回值通常会涉及临时对象的创建和销毁。例如，当函数返回一个对象时，通常会创建一个临时对象来存储返回值，然后将其拷贝到接收返回值的变量中。返回值优化（RVO）是编译器的一种优化技术，它避免了这些临时对象的拷贝操作。</p><h3 id="RVO的工作机制"><a href="#RVO的工作机制" class="headerlink" title="RVO的工作机制"></a>RVO的工作机制</h3><p>通常情况下，返回一个对象的过程涉及两步：</p><ol><li>创建并初始化一个临时对象（可能是函数内的局部对象）。</li><li>将这个临时对象拷贝或移动到调用者提供的目标位置。</li></ol><p><strong>RVO</strong>通过直接在目标位置构造返回的对象，跳过了临时对象的创建，从而避免了拷贝或移动操作。</p><h3 id="例子（无RVO-vs-有RVO）"><a href="#例子（无RVO-vs-有RVO）" class="headerlink" title="例子（无RVO vs. 有RVO）"></a>例子（无RVO vs. 有RVO）</h3><h4 id="没有RVO时："><a href="#没有RVO时：" class="headerlink" title="没有RVO时："></a>没有RVO时：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp;) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function">MyClass <span class="hljs-title">createObject</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// 返回局部对象，会调用拷贝构造函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass newObj = <span class="hljs-built_in">createObject</span>();  <span class="hljs-comment">// 接收返回值，会再次拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，<code>createObject()</code>函数返回一个局部对象 <code>obj</code>，在没有RVO的情况下：</p><ol><li>首先构造局部对象 <code>obj</code>。</li><li>然后调用拷贝构造函数将 <code>obj</code>拷贝到一个临时对象（用来保存返回值）。</li><li>最后将这个临时对象拷贝到 <code>newObj</code>中。</li></ol><p>因此，会涉及两次拷贝构造调用，这样的拷贝是性能上的浪费。</p><h4 id="有RVO时："><a href="#有RVO时：" class="headerlink" title="有RVO时："></a>有RVO时：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MyClass <span class="hljs-title">createObject</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    <span class="hljs-keyword">return</span> obj;  <span class="hljs-comment">// RVO优化，直接在返回位置构造</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass newObj = <span class="hljs-built_in">createObject</span>();  <span class="hljs-comment">// 直接在newObj上构造对象，无需拷贝</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在启用RVO的情况下，编译器会跳过临时对象的创建，直接在 <code>newObj</code>的内存位置上构造 <code>obj</code>，避免了不必要的拷贝操作。</p><h3 id="RVO的类型"><a href="#RVO的类型" class="headerlink" title="RVO的类型"></a>RVO的类型</h3><ol><li><strong>命名返回值优化（Named Return Value Optimization, NRVO）</strong>：NRVO是RVO的一种形式，发生在返回值是命名的局部变量时。例如，函数返回一个命名的局部对象，编译器会直接在调用者的内存空间中构造该对象，而不是先创建一个临时对象。</li><li><strong>标准RVO</strong>：标准RVO发生在返回一个未命名的临时对象时。例如，函数返回一个临时构造的对象，而不是局部变量。这种优化在C++17后是强制执行的，不再依赖于编译器是否选择进行优化。</li></ol><h3 id="C-17-中的强制RVO"><a href="#C-17-中的强制RVO" class="headerlink" title="C++17 中的强制RVO"></a>C++17 中的强制RVO</h3><p>从C++17开始，标准RVO成为强制行为，编译器必须执行返回值优化，不再需要拷贝或移动临时对象。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">MyClass <span class="hljs-title">createObject</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">MyClass</span>();  <span class="hljs-comment">// C++17中，直接在返回位置构造对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在C++17之前，编译器可能会选择不进行优化，但从C++17开始，编译器必须直接在目标位置构造返回的对象，从而完全消除了临时对象和拷贝构造的开销。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>RVO</strong>（返回值优化）是一种编译器优化技术，可以在函数返回对象时避免不必要的临时对象拷贝。</li><li><strong>NRVO</strong>（命名返回值优化）是RVO的一种形式，应用于返回命名的局部变量。</li><li><strong>C++17</strong>中强制执行了RVO，编译器必须优化返回临时对象的场景，进一步提高了程序效率。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 14</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-14/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-14/</url>
    
    <content type="html"><![CDATA[<h1 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a>重载运算与类型转换</h1><span id="more"></span><h2 id="14-1-基本概念"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念</h2><p>重载的运算符是具有特殊名字的函数：它们的名字由关键字operator和其后要定义的运算符号共同组成。</p><p>除了重载的函数调用运算符operator（）之外，其他重载运算符不能含有默认实参（参见6.5.1节，第211页）。</p><p>如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上（参见7.1.2节，第231页）。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240928234553638.png"></p><p><strong>直接调用一个重载的运算符函数</strong></p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240928234624906.png"></p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240928234642641.png"></p><p><strong>某些运算符不应该被重载</strong></p><div class="note note-primary">            <p>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</p>          </div><p>某些运算符指定了运算对象求值的顺序。因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是，</p><ul><li>逻辑与运算符</li><li>逻辑或运算符（参见4.3节，第126页）</li><li>逗号运算符（参见4.10节，第140页）</li></ul><p>的运算对象求值顺序规则无法保留下来。</p><p>除此之外，&amp;&amp;和||运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值。</p><p>还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。</p><p><strong>使用与内置类型一致的含义</strong></p><ul><li>如果类执行IO操作，则定义移位运算符使其与内置类型的IO保持一致。</li><li>如果类的某个操作是检查相等性，则定义operator&#x3D;&#x3D;；如果类有了operator&#x3D;&#x3D;，意味着它通常也应该有operator！&#x3D;。</li><li>如果类包含一个内在的单序比较操作，则定义operator&lt;；如果类有了operator&lt;，则它也应该含有其他关系操作。</li><li>重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回一个类类型的值，赋值运算符和复合赋值运算符则应该返回左侧运算对象的一个引用。</li></ul><p><strong>赋值和复合赋值运算符</strong></p><p>赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用。</p><p><strong>选择作为成员或者非成员</strong></p><ul><li>赋值（&#x3D;）、下标（[ ]）、调用（（ ））和成员访问箭头（-&gt;）运算符必须是成员。</li><li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li><li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员</li><li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li></ul><h2 id="14-2-输入和输出运算符"><a href="#14-2-输入和输出运算符" class="headerlink" title="14.2 输入和输出运算符"></a>14.2 输入和输出运算符</h2><h3 id="14-2-1-重载输出运算符"><a href="#14-2-1-重载输出运算符" class="headerlink" title="14.2.1 重载输出运算符&lt;&lt;"></a>14.2.1 重载输出运算符&lt;&lt;</h3><p>通常情况下：</p><ul><li>第一个形参：非常量 <code>ostream</code> 的引用</li><li>第二个形参：常量类类型的引用</li><li>返回值：返回第一个 <code>ostream</code> 的形参的引用</li></ul><p><strong>输出运算符尽量减少格式化操作</strong></p><p><strong>输入输出运算符必须是非成员函数</strong></p><p>IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为<strong>友元</strong>（参见7.2.1节，第241页）。</p><h3 id="14-2-2-重载输入运算符"><a href="#14-2-2-重载输入运算符" class="headerlink" title="14.2.2 重载输入运算符&gt;&gt;"></a>14.2.2 重载输入运算符&gt;&gt;</h3><p>通常情况下：</p><ul><li>第一个形参：将要读取的流的引用</li><li>第二个形参：将要读入到的对象的引用</li><li>返回值：返回第一个形参的引用</li></ul><div class="note note-primary">            <p>输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</p>          </div><p><strong>输入时的错误</strong></p><ul><li>当流含有错误类型的数据时读取操作可能失败。例如在读取完bookNo后，输入运算符假定接下来读入的是两个数字数据，一旦输入的不是数字数据，则读取操作及后续对流的其他使用都将失败。</li><li>当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。</li></ul><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929000103050.png"></p><p><strong>标示错误</strong></p><p>一些输入运算符需要做更多数据验证的工作。例如，我们的输入运算符可能需要检查bookNo是否符合规范的格式。在这样的例子中，即使从技术上来看IO是成功的，输入运算符也应该设置流的条件状态以标示出失败信息（参见8.1.2节，第279页）。通常情况下，输入运算符只设置failbit。除此之外，设置eofbit表示文件耗尽，而设置badbit表示流被破坏。最好的方式是由IO标准库自己来标示这些错误。</p><h2 id="14-3-算术和关系运算符"><a href="#14-3-算术和关系运算符" class="headerlink" title="14.3 算术和关系运算符"></a>14.3 算术和关系运算符</h2><p>通常情况下：</p><ul><li>算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换（参见14.1节，第492页）。</li><li>因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。</li></ul><p>如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929000558278.png"></p><h3 id="14-3-1-相等运算符"><a href="#14-3-1-相等运算符" class="headerlink" title="14.3.1 相等运算符"></a>14.3.1 相等运算符</h3><ul><li>如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成operator&#x3D;&#x3D;而非一个普通的命名函数：因为用户肯定希望能使用&#x3D;&#x3D;比较对象，所以提供了&#x3D;&#x3D;就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。此外，类定义了&#x3D;&#x3D;运算符之后也更容易使用标准库容器和算法。</li><li>如果类定义了operator&#x3D;&#x3D;，则该运算符应该能判断一组给定的对象中是否含有重复数据。</li><li>通常情况下，相等运算符应该具有传递性，换句话说，如果a&#x3D;&#x3D;b和b&#x3D;&#x3D;c都为真，则a&#x3D;&#x3D;c也应该为真。·</li><li>如果类定义了operator&#x3D;&#x3D;，则这个类也应该定义operator！&#x3D;。对于用户来说，当他们能使用&#x3D;&#x3D;时肯定也希望能使用！&#x3D;，反之亦然。</li><li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。</li></ul><h3 id="14-3-2-关系运算符"><a href="#14-3-2-关系运算符" class="headerlink" title="14.3.2 关系运算符"></a>14.3.2 关系运算符</h3><p>定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较有用。</p><p>通常情况下关系运算符应该</p><ul><li>定义顺序关系，令其与关联容器中对关键字的要求一致（参见11.2.2节，第378页）</li><li>如果类同时也含有&#x3D;&#x3D;运算符的话，则定义一种关系令其与&#x3D;&#x3D;保持一致。特别是，如果两个对象是！&#x3D;的，那么一个对象应该&lt;另外一个。</li></ul><p>尽管我们可能会认为Sales_data类应该支持关系运算符，但事实证明并非如此，其中的缘由比较微妙，值得读者深思。</p><p>一开始我们可能会认为应该像compareIsbn（参见11.2.2节，第379页）那样定义&lt;，该函数通过比较ISBN来实现对两个对象的比较。然而，尽管compareIsbn提供的顺序关系符合要求1，但是函数得到的结果显然与我们定义的&#x3D;&#x3D;不一致，因此它不满足要求2。</p><p>对于Sales_data的&#x3D;&#x3D;运算符来说，如果两笔交易的revenue和units_sold成员不同，那么即使它们的ISBN相同也无济于事，它们仍然是不相等的。如果我们定义的&lt;运算符仅仅比较ISBN成员，那么将发生这样的情况：两个ISBN相同但revenue和units_sold不同的对象经比较是不相等的，但是其中的任何一个都不比另一个小。然而实际情况是，如果我们有两个对象并且哪个都不比另一个小，则从道理上来讲这两个对象应该是相等的。</p><p>基于上述分析我们也许会认为，只要让operator&lt;依次比较每个数据元素就能解决问题了，比方说让operator&lt;先比较isbn，相等的话继续比较units_sold，还相等再继续比较revenue。然而，这样的排序没有任何必要。根据将来使用Sales_data类的实际需要，我们可能会希望先比较units_sold，也可能希望先比较revenue。有的时候，我们希望units_sold少的对象“小于”units_sold多的对象；另一些时候，则可能希望revenue少的对象“小于”revenue多的对象。因此对于Sales_data类来说，不存在一种逻辑可靠的&lt;定义，这个类不定义&lt;运算符也许更好。</p><blockquote><p>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含&#x3D;&#x3D;，则当且仅当&lt;的定义和&#x3D;&#x3D;产生的结果一致时才定义&lt;运算符。</p></blockquote><h2 id="14-4-赋值运算符"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符</h2><div class="note note-primary">            <p>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</p>          </div><p>之前已经介绍过<a href="https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-13/">拷贝赋值和移动赋值运算符</a>（参见13.1.2节，第443页和13.6.2节，第474页），它们可以把类的一个对象赋值给该类的另一个对象。此外，类还可以定义其他赋值运算符以使用别的类型作为右侧运算对象。举个例子，在拷贝赋值和移动赋值运算符之外，标准库vector类还定义了第三种赋值运算符，该运算符接受花括号内的元素列表作为参数（参见9.2.5节，第302页）。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929001537851.png"></p><p><strong>复合赋值运算符</strong></p><p>复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。</p><h2 id="14-5-下标运算符"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符</h2><div class="note note-primary">            <p>下标运算符必须是成员函数。</p>          </div><p>表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符operator[]。</p><p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。进一步，我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。</p><h2 id="14-6-递增和递减运算符"><a href="#14-6-递增和递减运算符" class="headerlink" title="14.6 递增和递减运算符"></a>14.6 递增和递减运算符</h2><div class="note note-primary">            <p>定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。</p>          </div><p>C++语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。</p><p><strong>定义前置递增&#x2F;递减运算符</strong></p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929002855117.png"></p><p>前置运算符应该返回递增或递减后对象的引用。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929002959564.png"></p><p><strong>区分前置和后置运算符</strong></p><p>后置版本接受一个额外的（不被使用）int类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929003040691.png"></p><p>后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929003107796.png"></p><p>后置运算符调用各自的前置版本来完成实际的工作。</p><h2 id="14-7-成员访问运算符"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符</h2><div class="note note-primary">            <p>箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</p>          </div><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929003249763.png"></p><p>箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。</p><p><strong>对箭头运算符返回值的限定</strong></p><div class="note note-primary">            <p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p>          </div><h2 id="14-8-函数调用运算符"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符</h2><div class="note note-primary">            <p>函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</p>          </div><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。因为这样的类同时也能存储状态，所以与普通函数相比它们更加灵活。</p><p>如果类定义了调用运算符，则该类的对象称作<strong>函数对象（function object）</strong>。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。</p><p><strong>含有状态的函数对象类</strong></p><p>函数对象常常作为泛型算法的实参。</p><h3 id="14-8-1-lambda是函数对象"><a href="#14-8-1-lambda是函数对象" class="headerlink" title="14.8.1 lambda是函数对象"></a>14.8.1 lambda是函数对象</h3><p>当我们编写了一个lambda后，编译器将该表达式翻译成一个未命名类的未命名对象（参见10.3.3节，第349页）。在lambda表达式产生的类中含有一个重载的函数调用运算符。</p><p>默认情况下lambda不能改变它捕获的变量。因此在默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符就不是const的了。</p><p><strong>表示lambda及相应捕获行为的类</strong></p><p>当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引的对象确实存在（参见10.3.3节，第350页）。因此，编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。</p><p>相反，通过值捕获的变量被拷贝到lambda中（参见10.3.3节，第350页）。因此，这种lambda产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</p><h3 id="14-8-2-标准库定义的函数对象"><a href="#14-8-2-标准库定义的函数对象" class="headerlink" title="14.8.2 标准库定义的函数对象"></a>14.8.2 标准库定义的函数对象</h3><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。</p><p>这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929142537414.png"></p><p><strong>在算法中使用标准库函数对象</strong></p><p>表示运算符的函数对象类常用来替换算法中的默认运算符。</p><p>如我们所知，在默认情况下排序算法使用operator&lt;将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个greater类型的对象。该类将产生一个调用运算符并负责执行待排序类型的大于运算。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929142624574.png"></p><p>标准库规定其函数对象对于指针同样适用。我们之前曾经介绍过比较两个无关指针将产生未定义的行为（参见3.5.3节，第107页），然而我们可能会希望通过比较指针的内存地址来sort指针的vector。直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929142713199.png"></p><h3 id="14-8-3-可调用对象与function"><a href="#14-8-3-可调用对象与function" class="headerlink" title="14.8.3 可调用对象与function"></a>14.8.3 可调用对象与function</h3><p>C++语言中有几种可调用的对象：</p><ul><li>函数</li><li>函数指针</li><li>lambda表达式（参见10.3.2节，第346页）</li><li>bind创建的对象（参见10.3.4节，第354页）</li><li>重载了函数调用运算符的类。</li></ul><p>可调用的对象也有类型。例如，每个lambda有它自己唯一的（未命名）类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等。</p><p>然而，两个不同类型的可调用对象却可能共享同一种<strong>调用形式（call signature）</strong>。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143055617.png"></p><p>是一个函数类型，它接受两个int、返回一个int。</p><p><strong>不同类型可能具有相同的调用形式</strong></p><p>对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143127827.png"></p><p>上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但是共享同一种调用形式。</p><p>我们可能希望使用这些可调用对象构建一个简单的桌面计算器。为了实现这一目的，需要定义一个函数表（function table）用于存储指向这些可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。</p><p>在C++语言中，函数表很容易通过map来实现。</p><p>对于此例来说，我们使用一个表示运算符符号的string对象作为关键字；使用实现运算符的函数作为值。当我们需要求给定运算符的值时，先通过运算符索引map，然后调用找到的那个元素。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143258114.png"></p><p>我们可以按照下面的形式将add的指针添加到binops中</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143331235.png"></p><p>但是我们不能将mod或者divide存入binops：</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143340872.png"></p><p><strong>标准库function类型</strong></p><p>可以使用一个名为<strong>function</strong>的新的标准库类型解决上述问题，function定义在functional头文件中，表14.3列举出了function定义的操作。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143407352.png"></p><p>function是一个模板，当创建一个具体的function类型时我们必须提供额外的信息，即该function类型能够表示的对象的调用形式。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143542124.png"></p><p><strong>重载的函数与function</strong></p><p>我们不能（直接）将重载函数的名字存入function类型的对象中</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143643994.png"></p><p>解决上述二义性问题的一条途径是存储函数指针（参见6.7节，第221页）而非函数的名字</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143718359.png"></p><p>也能使用lambda来消除二义性</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929143739573.png"></p><h2 id="14-9-重载、类型转换与运算符"><a href="#14-9-重载、类型转换与运算符" class="headerlink" title="14.9 重载、类型转换与运算符"></a>14.9 重载、类型转换与运算符</h2><p>我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversions），这样的转换有时也被称作用户定义的类型转换（user-defined conversions）。</p><h3 id="14-9-1-类型转换运算符"><a href="#14-9-1-类型转换运算符" class="headerlink" title="14.9.1 类型转换运算符"></a>14.9.1 类型转换运算符</h3><p>类型转换运算符（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929144114812.png"></p><div class="note note-primary">            <p>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是const。</p>          </div><p>其中type表示某种类型。类型转换运算符可以面向任意类型（除了void之外）进行定义，只要该类型能作为函数的返回类型（参见6.1节，第184页）。因此，我们不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型。</p><p>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成const成员。</p><p><strong>定义含有类型转换运算符的类</strong></p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929144255208.png"></p><p>SmallInt类既定义了向类类型的转换，也定义了从类类型向其他类型的转换。其中，构造函数将算术类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929144340414.png"></p><p><strong>提示：避免过度使用类型转换函数</strong></p><p>和使用重载运算符的经验一样，明智地使用类型转换运算符也能极大地简化类设计者的工作，同时使得使用类更加容易。然而，如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p><p>例如，假设某个类表示Date，我们也许会为它添加一个从Date到int的转换。然而，类型转换函数的返回值应该是什么？一种可能的解释是，函数返回一个十进制数，依次表示年、月、日，例如，July 30，1989可能转换为int值19890730。同时还存在另外一种合理的解释，即类型转换运算符返回的int表示的是从某个时间节点（比如January 1，1970）开始经过的天数。显然这两种理解都合情合理，毕竟从形式上看它们产生的效果都是越靠后的日期对应的整数值越大，而且两种转换都有实际的用处。</p><p>问题在于Date类型的对象和int类型的值之间不存在明确的一对一映射关系。因此在此例中，不定义该类型转换运算符也许会更好。作为替代的手段，类可以定义一个或多个普通的成员函数以从各种不同形式中提取所需的信息。</p><p><strong>类型转换运算符可能产生意外结果</strong></p><p>在实践中，类很少提供类型转换运算符。然而这条经验法则存在一种例外情况：对于类来说，定义向bool的类型转换还是比较普遍的现象。</p><p>在C++标准的早期版本中，如果类想定义一个向bool的类型转换，则它常常遇到一个问题：因为bool是一种算术类型，所以类类型的对象转换成bool后就能被用在任何需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果，特别是当istream含有向bool的类型转换时，下面的代码仍将编译通过</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929144657953.png"></p><p>该代码能使用istream的bool类型转换运算符将cin转换成bool，而这个bool值接着会被提升成int并用作内置的左移运算符的左侧运算对象。这样一来，提升后的bool值（1或0）最终会被左移42个位置。这一结果显然与我们的预期大相径庭。</p><p><strong>显式的类型转换运算符</strong></p><p>为了防止这样的异常情况发生，C++11新标准引入了<strong>显式的类型转换运算符（explicit conversion operator）</strong></p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929144747752.png"></p><p>和显式的构造函数（参见7.5.4节，第265页）一样，编译器（通常）也不会将一个显式的类型转换运算符用于隐式类型转换</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929144814005.png"></p><p>该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行：</p><ul><li>if、while及do语句的条件部分</li><li>for语句头的条件表达式</li><li>逻辑非运算符（！）、逻辑或运算符（||）、逻辑与运算符（&amp;&amp;）的运算对象</li><li>条件运算符（？ ：）的条件表达式。</li></ul><p><strong>转换为bool</strong></p><p>向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的。</p><h3 id="14-9-2-避免有二义性的类型转换"><a href="#14-9-2-避免有二义性的类型转换" class="headerlink" title="14.9.2 避免有二义性的类型转换"></a>14.9.2 避免有二义性的类型转换</h3><p>如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话，我们编写的代码将很可能会具有二义性。</p><p>在两种情况下可能产生多重转换路径</p><ol><li>两个类提供相同的类型转换：例如，当A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符时，我们就说它们提供了相同的类型转换。</li><li>类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则。</li></ol><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929145127895.png"></p><p><strong>二义性与转换目标为内置类型的多重类型转换</strong></p><p>类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929145239750.png"></p><p><strong>提示：类型转换与运算符</strong></p><ul><li>不要令两个类执行相同的类型转换：如果Foo类有一个接受Bar类对象的构造函数，则不要在Bar类中再定义转换目标是Foo类的类型转换运算符。</li><li>避免转换目标是内置算术类型的类型转换。特别是当你已经定义了一个转换成算术类型的类型转换时，接下来<ul><li>不要再定义接受算术类型的重载运算符。如果用户需要使用这样的运算符，则类型转换操作将转换你的类型的对象，然后使用内置的运算符。</li><li>不要定义转换到多种算术类型的类型转换。让标准类型转换完成向其他算术类型转换的工作。</li></ul></li></ul><p>一言以蔽之：除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。</p><p><strong>重载函数与转换构造函数</strong></p><p>当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929145705735.png"></p><div class="note note-warning">            <p>如果在调用重载函数时我们需要使用构造函数或者强制类型转换来改变实参的类型，则这通常意味着程序的设计存在不足。在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</p>          </div><p><strong>重载函数与用户定义的类型转换</strong></p><p>当调用重载函数时，如果两个（或多个）用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好。在这个过程中，我们不会考虑任何可能出现的标准类型转换的级别。只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换。</p><p><img src="/../images/C-C-Primer-Chapter-14/image-20240929155414735.png"></p><h3 id="14-9-3-函数匹配与重载运算符"><a href="#14-9-3-函数匹配与重载运算符" class="headerlink" title="14.9.3 函数匹配与重载运算符"></a>14.9.3 函数匹配与重载运算符</h3><p>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 13</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-13/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-13/</url>
    
    <content type="html"><![CDATA[<h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><span id="more"></span><p>一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。</p><h2 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h2><h3 id="13-1-1-拷贝构造函数"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p><p>拷贝构造函数的<strong>第一个参数必须是一个引用类型</strong>，原因我们稍后解释。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数<strong>几乎总是一个const的引用</strong>。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数<strong>通常不应该是explicit的</strong>（参见7.5.4节，第265页）。</p><p><strong>合成拷贝构造函数</strong></p><p>即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</p><p>13.1.6节（第450页）中所见，对某些类来说，合成拷贝构造函数（synthesized copy constructor）用来阻止我们拷贝该类类型的对象。</p><p>虽然我们不能直接拷贝一个数组（参见3.5.1节，第102页），但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。</p><p><strong>拷贝初始化</strong></p><p>当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配（参见6.4节，第209页）来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化（copy initialization）时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换（参见7.5.4节，第263页）。</p><p>拷贝初始化不仅在我们用&#x3D;定义变量时会发生，在下列情况下也会发生</p><ul><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员（参见7.5.5节，第266页）</li></ul><p>当我们初始化标准库容器或是调用其insert或push成员（参见9.3.1节，第306页）时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化（参见9.3.1节，第308页）。</p><p><strong>参数和返回值</strong></p><p>在函数调用过程中，具有非引用类型的参数要进行拷贝初始化（参见6.2.1节，第188页）。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果（参见6.3.2节，第201页）。</p><p>拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。</p><p><strong>拷贝初始化的限制</strong></p><p>如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换（参见7.5.4节，第265页），那么使用拷贝初始化还是直接初始化就不是无关紧要的了</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240921002325205.png"></p><p><strong>编译器可以绕过拷贝构造函数</strong></p><p>在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝&#x2F;移动构造函数，直接创建对象。</p><p>但是，即使编译器略过了拷贝&#x2F;移动构造函数，但在这个程序点上，拷贝&#x2F;移动构造函数必须是存在且可访问的（例如，不能是private的）。</p><h3 id="13-1-2-拷贝赋值运算符"><a href="#13-1-2-拷贝赋值运算符" class="headerlink" title="13.1.2 拷贝赋值运算符"></a>13.1.2 拷贝赋值运算符</h3><p>如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。</p><p><strong>重载赋值运算符</strong></p><p>重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。</p><p>某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数（参见7.1.2节，第231页）。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p><p>为了与内置类型的赋值（参见4.4节，第129页）保持一致，赋值运算符通常<strong>返回一个指向其左侧运算对象的引用。</strong></p><p><strong>标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</strong></p><blockquote><p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p></blockquote><p><strong>合成拷贝赋值运算符</strong></p><p>对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。</p><h3 id="13-1-3-析构函数"><a href="#13-1-3-析构函数" class="headerlink" title="13.1.3 析构函数"></a>13.1.3 析构函数</h3><p>析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。</p><p>析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数</p><p>由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。</p><p><strong>析构函数完成什么工作</strong></p><p>如同构造函数有一个初始化部分和一个函数体（参见7.5.1节，第257页），析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。<strong>在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。</strong></p><p><strong>什么时候会调用析构函数</strong></p><p>无论何时一个对象被销毁，就会自动调用其析构函数：</p><ul><li>变量在离开其作用域时被销毁。</li><li>当一个对象被销毁时，其成员被销毁。</li><li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li><li>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁（参见12.1.2节，第409页）。</li><li>对于临时对象，当创建它的完整表达式结束时被销毁。</li></ul><p><strong>合成析构函数</strong></p><p>类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁（参见13.1.6节，第450页）。如果不是这种情况，合成析构函数的函数体就为空。</p><p>认识到<strong>析构函数体自身并不直接销毁成员是非常重要的。</strong>成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。</p><h3 id="13-1-4-三-五法则"><a href="#13-1-4-三-五法则" class="headerlink" title="13.1.4 三&#x2F;五法则"></a>13.1.4 三&#x2F;五法则</h3><p>有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符，我们将在13.6节（第470页）中介绍这些内容。</p><p><strong>需要析构函数的类也需要拷贝和赋值操作</strong></p><p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong></p><p>无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</p><h3 id="13-1-5-使用-default"><a href="#13-1-5-使用-default" class="headerlink" title="13.1.5 使用&#x3D;default"></a>13.1.5 使用&#x3D;default</h3><p>我们可以通过将拷贝控制成员定义为&#x3D;default来显式地要求编译器生成合成的版本（参见7.1.4节，第237页）</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240921004332914.png"></p><p>当我们在类内用&#x3D;default修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用&#x3D;default，就像对拷贝赋值运算符所做的那样。</p><h3 id="13-1-6-阻止拷贝"><a href="#13-1-6-阻止拷贝" class="headerlink" title="13.1.6 阻止拷贝"></a>13.1.6 阻止拷贝</h3><blockquote><p>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。</p></blockquote><p>对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。</p><p><strong>定义删除的函数</strong></p><p>在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上&#x3D;delete来指出我们希望将它定义为删除的</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240921004625361.png"></p><p><strong>与&#x3D;default不同，&#x3D;delete必须出现在函数第一次声明的时候</strong></p><p>与&#x3D;default的另一个不同之处是，我们可以对任何函数指定&#x3D;delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用&#x3D;default）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。</p><p><strong>析构函数不能是删除的成员</strong></p><p>值得注意的是，我们不能删除析构函数。</p><p>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象</p><p><strong>合成的拷贝控制成员可能是删除的</strong></p><p>对某些类来说，编译器将这些合成的成员定义为删除的函数：</p><ul><li>如果类的某个成员的<strong>析构函数</strong>是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为删除的。</li><li>如果类的某个成员的<strong>拷贝构造函数</strong>是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。</li><li>如果类的某个成员的<strong>析构函数</strong>是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。</li><li>如果类的某个成员的<strong>拷贝赋值运算符</strong>是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。</li><li>如果类的某个成员的<strong>析构函数</strong>是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器（参见2.6.1节，第65页），或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。</li></ul><p><strong>本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</strong></p><p><strong>private拷贝控制</strong></p><p>在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝</p><p>声明但不定义一个成员函数是合法的（参见6.1.2节，第186页），对此只有一个例外，我们将在15.2.1节（第528页）中介绍。试图访问一个未定义的成员将导致一个链接时错误。通过声明（但不定义）private的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。</p><h2 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h2><p>首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p><p>类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。</p><p>行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。</p><p>在我们使用过的标准库类中，标准库容器和string类的行为像一个值。而不出意外的，shared_ptr类提供类似指针的行为，就像我们的StrBlob类（参见12.1.1节，第405页）一样，IO类型和unique_ptr不允许拷贝或赋值，因此它们的行为既不像值也不像指针。</p><h3 id="13-2-1-行为像值的类"><a href="#13-2-1-行为像值的类" class="headerlink" title="13.2.1 行为像值的类"></a>13.2.1 行为像值的类</h3><p>为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。</p><p><strong>类值拷贝赋值运算符</strong></p><p>赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是，<strong>非常重要的一点是，这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保证正确。</strong>而且，如果可能，我们编写的赋值运算符还应该是异常安全的——当异常发生时能将左侧运算对象置于一个有意义的状态（参见5.6.2节，第175页）。</p><p>通过<strong>先拷贝右侧运算对象</strong>，我们可以处理自赋值情况，并能保证在异常发生时代码也是安全的。</p><p><strong>关键概念：赋值运算符</strong></p><p>当你编写赋值运算符时，有两点需要记住：</p><ul><li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li><li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作。</li></ul><p>当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。</p><h3 id="13-2-2-定义行为像指针的类"><a href="#13-2-2-定义行为像指针的类" class="headerlink" title="13.2.2 定义行为像指针的类"></a>13.2.2 定义行为像指针的类</h3><p>对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。</p><p>析构函数不能单方面地释放关联的string。只有当最后一个指向string的HasPtr销毁时，它才可以释放string。</p><p>令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。</p><p>但是，有时我们希望直接管理资源。在这种情况下，使用<strong>引用计数（reference count）</strong>（参见12.1.1节，第402页）就很有用了。</p><p><strong>引用计数</strong></p><p>引用计数的工作方式如下：</p><ul><li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li><li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。</li><li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li><li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li></ul><p>计数器不能直接作为HasPtr对象的成员。</p><p>解决此问题的一种方法是<strong>将计数器保存在动态内存中</strong>。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。</p><p><strong>定义一个使用引用计数的类</strong></p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240921010258313.png"></p><p><strong>类指针的拷贝成员“篡改”引用计数</strong></p><p>析构函数不能无条件地delete ps——可能还有其他对象指向这块内存。析构函数应该递减引用计数，指出共享string的对象少了一个。如果计数器变为0，则析构函数释放ps和use指向的内存</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240921010338251.png"></p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240921010440242.png"></p><h2 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h2><p>管理资源的类一般会定义自己的 <code>swap</code> 函数。</p><p>对于会重排元素顺序的算法来说，如果类定义了自己的<code>swap</code>函数，则调用该函数，否则使用标准库定义的<code>swap</code>，该函数会进行一次拷贝两次赋值。</p><p><strong>编写我们自己的swap函数</strong></p><blockquote><p>与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。</p></blockquote><p>一个典型的实现方法，由于swap的存在就是为了优化代码，我们将其声明为inline函数（参见6.5.2节，第213页）。</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240922172223746.png"></p><p>需要注意的是，每个swap调用应该都是未加限定的。即，每个调用都应该是swap，而不是std：：swap。如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本，原因我们将在16.3节（第616页）中进行解释。</p><p><strong>在赋值运算符中使用swap</strong></p><blockquote><p>使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。</p></blockquote><p>定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换（copy and swap）的技术。</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240922172705817.png"></p><h2 id="13-4-拷贝控制示例"><a href="#13-4-拷贝控制示例" class="headerlink" title="13.4 拷贝控制示例"></a>13.4 拷贝控制示例</h2><p>通常来说分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己的拷贝控制成员的唯一原因。一些类也需要拷贝控制成员的帮助来进行簿记工作或其他操作。</p><p>两个类命名为Message和Folder，分别表示电子邮件（或者其他类型的）消息和消息目录。每个Message对象可以出现在多个Folder中。但是，任意给定的Message的内容只有一个副本。这样，如果一条Message的内容被改变，则我们从它所在的任何Folder来浏览此Message时，都会看到改变后的内容。为了记录Message位于哪些Folder中，每个Message都会保存一个它所在Folder的指针的set，同样的，每个Folder都保存一个它包含的Message的指针的set。</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240922173022597.png"></p><p>Message类会提供save和remove操作，来向一个给定Folder添加一条Message或是从中删除一条Message。为了创建一个新的Message，我们会指明消息内容，但不会指出Folder。为了将一条Message放到一个特定Folder中，我们必须调用save。</p><p>当我们拷贝一个Message时，副本和原对象将是不同的Message对象，但两个Message都出现在相同的Folder中。因此，拷贝Message的操作包括消息内容和Folder指针set的拷贝。而且，我们必须在每个包含此消息的Folder中都添加一个指向新创建的Message的指针。</p><p>当我们销毁一个Message时，它将不复存在。因此，我们必须从包含此消息的所有Folder中删除指向此Message的指针。</p><p>当我们将一个Message对象赋予另一个Message对象时，左侧Message的内容会被右侧Message的内容所替代。我们还必须更新Folder集合，从原来包含左侧Message的Folder中将它删除，并将它添加到包含右侧Message的Folder中。</p><p>观察这些操作，我们可以看到，析构函数和拷贝赋值运算符都必须从包含一条Message的所有Folder中删除它。类似的，拷贝构造函数和拷贝赋值运算符都要将一个Message添加到给定的一组Folder中。我们将定义两个private的工具函数来完成这些工作。</p><blockquote><p>拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这种情况下，公共的工作应该放在private的工具函数中完成。</p></blockquote><p>Folder类也需要类似的拷贝控制成员，来添加或删除它保存的Message。</p><h2 id="13-5-动态内存管理类"><a href="#13-5-动态内存管理类" class="headerlink" title="13.5 动态内存管理类"></a>13.5 动态内存管理类</h2><p>某些类需要在运行时分配可变大小的内存空间。这种类通常可以（并且如果它们确实可以的话，一般应该）使用标准库容器来保存它们的数据。</p><p>但是，这一策略并不是对每个类都适用；某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。</p><p><strong>StrVec类的设计</strong></p><p>使用一个allocator来获得原始内存（参见12.2.2节，第427页）。由于allocator分配的内存是未构造的，我们将在需要添加新元素时用allocator的construct成员在原始内存中创建对象。类似的，当我们需要删除一个元素时，我们将使用destroy成员来销毁元素。</p><p>每个StrVec有三个指针成员指向其元素所使用的内存：</p><ul><li>elements，指向分配的内存中的首元素</li><li>first_free，指向最后一个实际元素之后的位置</li><li>cap，指向分配的内存末尾之后的位置</li></ul><p><img src="/../images/C-C-Primer-Chapter-13/image-20240922205725442.png"></p><p>StrVec还有一个名为alloc的静态成员，其类型为<code>allocator&lt;string&gt;</code>。</p><p>还有4个工具函数：</p><ul><li>alloc_n_copy会分配内存，并拷贝一个给定范围中的元素。</li><li>free会销毁构造的元素并释放内存。</li><li>chk_n_alloc保证StrVec至少有容纳一个新元素的空间。如果没有空间添加新元素，chk_n_alloc会调用reallocate来分配更多内存。</li><li>reallocate在内存用完时为StrVec分配新内存。</li></ul><p><strong>StrVec类定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrVec</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">StrVec</span>() :                           <span class="hljs-comment">// alloc成员默认初始化</span><br>        <span class="hljs-built_in">elements</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">first_free</span>(<span class="hljs-literal">nullptr</span>),<br>        <span class="hljs-built_in">cap</span>(<span class="hljs-literal">nullptr</span>)<br>    &#123; &#125;<br>    <span class="hljs-built_in">StrVec</span>(<span class="hljs-type">const</span> StrVec &amp;);              <span class="hljs-comment">// 拷贝构造</span><br>    StrVec &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> StrVec &amp;);   <span class="hljs-comment">// 拷贝赋值</span><br>    ~<span class="hljs-built_in">StrVec</span>();                           <span class="hljs-comment">// 析构函数</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;)</span></span>; <span class="hljs-comment">// 拷贝元素并添加到容器末尾</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> first_free - elements; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">capacity</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> cap - elements; &#125;<br>    <span class="hljs-function">std::string *<span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> elements; &#125;<br>    <span class="hljs-function">std::string *<span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> first_free; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">chk_n_alloc</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">        </span>&#123; <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>() == <span class="hljs-built_in">capacity</span>()) <span class="hljs-built_in">reallocate</span>(); &#125;      <span class="hljs-comment">// 至少保证容器有一个空闲空间</span><br>    std::pair&lt;std::string *, std::string *&gt; alloc_n_copy <span class="hljs-comment">// 分配内存并拷贝范围内元素</span><br>        (<span class="hljs-type">const</span> std::string *, <span class="hljs-type">const</span> std::string *);<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">()</span></span>;                                         <span class="hljs-comment">// 销毁元素并释放内存</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reallocate</span><span class="hljs-params">()</span></span>;                                   <span class="hljs-comment">// 重新分配内存并拷贝元素</span><br>    <span class="hljs-type">static</span> std::allocator&lt;std::string&gt; alloc;            <span class="hljs-comment">// 内存分配器</span><br>    std::string *elements;                               <span class="hljs-comment">// 数组首元素</span><br>    std::string *first_free;                             <span class="hljs-comment">// 数组最后一个元素之后的位置</span><br>    std::string *cap;                                    <span class="hljs-comment">// 数组分配内存之后的位置</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>使用construct</strong></p><p>若想使用原始内存，必须调用<code>construct</code>在此原始内存上构造一个对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;ele)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">chk_n_alloc</span>();<br>    alloc.<span class="hljs-built_in">construct</span>(first_free++, ele);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>push_back首先调用chk_n_alloc确保有足够的原始内存来构造对象，然后用allocator来构造一个对象，construct的第一个参数指向内存的起始地址，其他参数用来决定调用哪个构造函数来构造对象，此例中调用string的拷贝构造函数。</p><p><strong>alloc_n_copy成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::pair&lt;std::string *, std::string *&gt; <span class="hljs-title">StrVec::alloc_n_copy</span></span><br><span class="hljs-function">    <span class="hljs-params">(<span class="hljs-type">const</span> std::string *begin, <span class="hljs-type">const</span> std::string *end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> data = alloc.<span class="hljs-built_in">allocate</span>(end - begin);<br>    <span class="hljs-keyword">return</span> &#123;data, std::<span class="hljs-built_in">uninitialized_copy</span>(begin, end, data)&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>free成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::free</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (elements == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = elements; p != first_free; ++p)<br>        alloc.<span class="hljs-built_in">destroy</span>(p);<br>    alloc.<span class="hljs-built_in">deallocate</span>(elements, cap - elements);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，deallocate函数不接受空指针，所以必须要先检查指针是否未空。另外，我们必须首先销毁对象，然后再释放内存。</p><p><strong>拷贝控制成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++">StrVec::<span class="hljs-built_in">StrVec</span>(<span class="hljs-type">const</span> StrVec &amp;other)<br>&#123;<br>    <span class="hljs-keyword">auto</span> data =  <span class="hljs-built_in">alloc_n_copy</span>(other.<span class="hljs-built_in">begin</span>(), other.<span class="hljs-built_in">end</span>());<br>    elements = data.first;<br>    first_free = cap = data.second;<br>&#125;<br><br>StrVec &amp;StrVec::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> StrVec &amp;other)   <br>&#123;<br>    <span class="hljs-keyword">auto</span> data = <span class="hljs-built_in">alloc_n_copy</span>(other.<span class="hljs-built_in">begin</span>(), other.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">free</span>();<br>    elements = data.first;<br>    first_free = cap = data.second;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br>StrVec::~<span class="hljs-built_in">StrVec</span>()                           <br>&#123;<br>    <span class="hljs-built_in">free</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>重载赋值运算符在释放内存之前，先调用alloc_n_copy复制一份数据出来，这样可以处理自赋值问题。</p><p><strong>在重新分配内存的过程中移动而不是拷贝元素</strong></p><p>在编写reallocate成员函数之前，我们稍微思考一下此函数应该做什么。它应该</p><ul><li>为一个新的、更大的string数组分配内存</li><li>在内存空间的前一部分构造对象，保存现有元素</li><li>销毁原内存空间中的元素，并释放这块内存</li></ul><p>string的行为类似值，每个string对构成它的所有字符都会保存自己的一份副本。拷贝一个string必须为这些字符分配内存空间，而销毁一个string必须释放所占用的内存。</p><p>拷贝一个string就必须真的拷贝数据，因为通常情况下，在我们拷贝了一个string之后，它就会有两个用户。但是，如果是reallocate拷贝StrVec中的string，则在拷贝之后，每个string只有唯一的用户。一旦将元素从旧空间拷贝到了新空间，我们就会立即销毁原string。因此，拷贝这些string中的数据是多余的。</p><p><strong>移动构造函数和std：：move</strong></p><p>有一些标准库类，包括string，都定义了所谓的“移动构造函数”。移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。而且我们知道标准库保证“移后源”（moved-from）string仍然保持一个有效的、可析构的状态。</p><p>move的标准库函数，它定义在utility头文件中。当reallocate在新内存中构造string时，它必须调用move来表示希望使用string的移动构造函数，原因我们将在13.6.1节（第470页）中解释。如果它漏掉了move调用，将会使用string的拷贝构造函数。其次，我们通常不为move提供一个using声明（参见3.1节，第74页），原因将在18.2.3节（第706页）中解释。当我们使用move时，直接调用std：：move而不是move。</p><p><strong>reallocate成员</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StrVec::reallocate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> new_size = <span class="hljs-built_in">capacity</span>() ? <span class="hljs-built_in">capacity</span>() * <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">auto</span> new_elements = alloc.<span class="hljs-built_in">allocate</span>(new_size);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i != <span class="hljs-built_in">size</span>(); ++i)<br>        alloc.<span class="hljs-built_in">construct</span>(new_elements + i, std::<span class="hljs-built_in">move</span>(*(elements + i)));<br>    <span class="hljs-built_in">free</span>();<br>    cap = new_elements + new_size; <br>    first_free = new_elements + <span class="hljs-built_in">size</span>();<br>    elements = new_elements;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里需要处理默认初始化后第一次调用reallocate的情况，需要判断。</p><p><strong>测试</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    StrVec vec;<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;World&quot;</span>);<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Test&quot;</span>);<br><br>    <span class="hljs-keyword">auto</span> printVec = [](<span class="hljs-type">const</span> StrVec &amp;vec)<br>    &#123;<br>        std::for_each(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> std::string &amp;s)<br>        &#123;<br>            std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;);<br>        std::cout &lt;&lt; std::endl;<br>    &#125;;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Original vec: &quot;</span>;<br>    <span class="hljs-built_in">printVec</span>(vec);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size: &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;, Capacity: &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 测试拷贝构造函数</span><br>    <span class="hljs-function">StrVec <span class="hljs-title">vecCopy</span><span class="hljs-params">(vec)</span></span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Copied vec: &quot;</span>;<br>    <span class="hljs-built_in">printVec</span>(vecCopy);<br><br>    <span class="hljs-comment">// 测试拷贝赋值操作符</span><br>    StrVec vecAssign;<br>    vecAssign = vec;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Assigned vec: &quot;</span>;<br>    <span class="hljs-built_in">printVec</span>(vecAssign);<br><br>    <span class="hljs-comment">// 添加更多元素以触发重新分配</span><br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;More&quot;</span>);<br>    vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Strings&quot;</span>);<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Original vec after adding more elements: &quot;</span>;<br>    <span class="hljs-built_in">printVec</span>(vec);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Size: &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot;, Capacity: &quot;</span> &lt;&lt; vec.<span class="hljs-built_in">capacity</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923004848131.png"></p><h2 id="13-6-对象移动"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动</h2><blockquote><p>标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。</p></blockquote><p>在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型的对象不能拷贝但可以移动。</p><p>在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。</p><h3 id="13-6-1-右值引用"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用</h3><p>为了支持移动操作，新标准引入了一种新的引用类型——右值引用（rvalue reference）。所谓右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。右值引用有一个重要的性质——<strong>只能绑定到一个将要销毁的对象。</strong></p><p>一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923005310870.png"></p><p><strong>左值持久；右值短暂</strong></p><p>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</p><p>因为右值引用的对象即将被销毁，且没有其他用户，因此我们可以自由的接管该对象管理的资源。</p><p><strong>变量是左值</strong></p><p>因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923005534389.png"></p><p><strong>标准库move函数</strong></p><p>虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。move函数使用了我们将在16.2.6节（第610页）中描述的机制来返回给定对象的右值引用。</p><p>move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，<strong>调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。</strong>在调用move之后，我们不能对移后源对象的值做任何假设。</p><blockquote><p>我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</p></blockquote><p>与大多数标准库名字的使用不同，对move（参见13.5节，第469页）我们不提供using声明（参见3.1节，第74页）。我们直接调用std：：move而不是move，其原因将在18.2.3节（第707页）中解释。</p><h3 id="13-6-2-移动构造函数和移动赋值运算符"><a href="#13-6-2-移动构造函数和移动赋值运算符" class="headerlink" title="13.6.2 移动构造函数和移动赋值运算符"></a>13.6.2 移动构造函数和移动赋值运算符</h3><p>类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。</p><p>除了完成资源移动，<strong>移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。</strong>特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923005824517.png"></p><p><strong>移动操作、标准库容器和异常</strong></p><p>由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。</p><p>一种通知标准库的方法是在我们的构造函数中指明noexcept。noexcept是新标准引入的，我们将在18.1.4节（第690页）中讨论更多细节。目前重要的是要知道，noexcept是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定noexcept。在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间</p><p><strong>我们必须在类头文件的声明中和定义中（如果定义在类外的话）都指定noexcept。</strong></p><blockquote><p>不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。</p></blockquote><p>搞清楚为什么需要noexcept能帮助我们深入理解标准库是如何与我们自定义的类型交互的。</p><p>我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实：首先，虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时其自身的行为提供保障。例如，vector保证，如果我们调用push_back时发生异常，vector自身不会发生改变。</p><p>现在让我们思考push_back内部发生了什么。类似对应的StrVec操作（参见13.5节，第466页），对一个vector调用push_back可能要求为vector重新分配内存空间。当重新分配vector的内存时，vector将元素从旧空间移动到新内存中，就像我们在reallocate中所做的那样（参见13.5节，第469页）。如我们刚刚看到的那样，移动一个对象通常会改变它的值。如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。在此情况下，vector将不能满足自身保持不变的要求。</p><p>另一方面，如果vector使用了拷贝构造函数且发生了异常，它可以很容易地满足要求。在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生了异常，vector可以释放新分配的（但还未成功构造的）内存并返回。vector原有的元素仍然存在。为了避免这种潜在问题，除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。</p><p>如果希望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数（及移动赋值运算符）标记为noexcept来做到这一点。</p><p><strong>移动赋值运算符</strong></p><p>移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923010734523.png"></p><p>我们费心地去检查自赋值情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算对象的一个右值。我们进行检查的原因是此右值可能是move调用的返回结果。与其他任何赋值运算符一样，关键点是我们不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源（可能是相同的资源）。</p><p><strong>移后源对象必须可析构</strong></p><p>除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。</p><p>例如，当我们从一个标准库string或容器对象移动数据时，我们知道移后源对象仍然保持有效。因此，我们可以对它执行诸如empty或size这些操作。但是，我们不知道将会得到什么结果。我们可能期望一个移后源对象是空的，但这并没有保证。</p><p><strong>合成的移动操作</strong></p><p>与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。</p><p>与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。</p><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</p><blockquote><p>只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。</p></blockquote><p>与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成&#x3D;default的（参见7.1.4节，第237页）移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。</p><p><strong>移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝</strong></p><p>如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用move来移动它们时也是如此。</p><p>值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的（赋值运算符的情况类似）。</p><p><strong>拷贝并交换赋值运算符和移动操作</strong></p><p>我们的HasPtr版本定义了一个拷贝并交换赋值运算符（参见13.3节，第459页），它是函数匹配和移动操作间相互关系的一个很好的示例。如果我们为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923011641781.png"></p><p>现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化（参见13.1.1节，第441页）。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。</p><p><strong>建议：更新三&#x2F;五法则</strong></p><p>所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作（参见13.1.4节，第447页）。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。</p><p><strong>移动迭代器</strong></p><p>StrVec的reallocate成员（参见13.5节，第469页）使用了一个for循环来调用construct从旧内存将元素拷贝到新内存中。作为一种替换方法，如果我们能调用uninitialized_copy来构造新分配的内存，将比循环更为简单。但是，uninitialized_copy恰如其名：它对元素进行拷贝操作。标准库中并没有类似的函数将对象“移动”到未构造的内存中。</p><p><strong>新标准库中定义了一种移动迭代器（move iterator）适配器（参见10.4节，第358页）。</strong>一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。</p><p><strong>我们通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。</strong>此函数接受一个迭代器参数，返回一个移动迭代器。</p><p>原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别是，可以将移动迭代器传递给uninitialized_copy</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923012046882.png"></p><p>值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。</p><p><strong>建议：不要随意使用移动操作</strong></p><h3 id="13-6-3-右值引用和成员函数"><a href="#13-6-3-右值引用和成员函数" class="headerlink" title="13.6.3 右值引用和成员函数"></a>13.6.3 右值引用和成员函数</h3><p>除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝&#x2F;移动构造函数和赋值运算符相同的参数模式——<strong>一个版本接受一个指向const的左值引用，第二个版本接受一个指向非const的右值引用。</strong></p><p>例如，定义了push_back的标准库容器提供两个版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。假定X是元素类型，那么这些容器就会定义以下两个push_back版本</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923012349761.png"></p><blockquote><p>区分移动和拷贝的重载函数通常有一个版本接受一个const T&amp;，而另一个版本接受一个T&amp;&amp;。</p></blockquote><p><strong>右值和左值引用成员函数</strong></p><p>通常，我们在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值。例如</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923012527686.png"></p><p>有时，右值的使用方式可能令人惊讶：</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923012611035.png"></p><p>在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望强制左侧运算对象（即，this指向的对象）是一个左值。</p><p>我们指出this的左值&#x2F;右值属性的方式与定义const成员函数相同（参见7.1.2节，第231页），即，在参数列表后放置一个引用限定符（reference qualifier）</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923012654396.png"></p><p>引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值。<strong>类似const限定符，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。</strong></p><p>对于&amp;限定的函数，我们只能将它用于左值；对于&amp;&amp;限定的函数，只能用于右值</p><p>一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后</p><p><strong>重载和引用函数</strong></p><p>就像一个成员函数可以根据是否有const来区分其重载版本一样（参见7.3.2节，第247页），引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和const来区分一个成员函数的重载版本。</p><p>当我们定义const成员函数时，可以定义两个版本，唯一的差别是一个版本有const限定而另一个没有。引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加</p><p><img src="/../images/C-C-Primer-Chapter-13/image-20240923013042247.png"></p><blockquote><p>如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 12</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-12/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-12/</url>
    
    <content type="html"><![CDATA[<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><span id="more"></span><p>静态内存用来保存局部static对象（参见6.6.1节，第185页）、类static数据成员（参见7.6节，第268页）以及定义在任何函数之外的变量。</p><p>栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。</p><p>对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</p><p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间（free store）或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象——即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制。</p><h2 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h2><p>为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。</p><h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><p><img src="/../images/C-C-Primer-Chapter-12/1726455699143.png"></p><p><img src="/../images/C-C-Primer-Chapter-12/1726455732235.png"></p><p><strong>make_shared函数</strong></p><p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p><p>类似顺序容器的emplace成员（参见9.3.1节，第308页），make_shared用其参数来构造给定类型的对象。</p><p>如果我们不传递任何参数，对象就会进行值初始化（参见3.3.1节，第88页）。</p><p><strong>shared_ptr的拷贝和赋值</strong></p><p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。</p><p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数（reference count）。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数（参见6.2.1节，第188页）以及作为函数的返回值（参见6.3.2节，第201页）时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域（参见6.1.1节，第184页））时，计数器就会递减。</p><p>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</p><p><strong>shared_ptr自动销毁所管理的对象，shared_ptr还会自动释放相关联的内存</strong></p><p>由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。share_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某些元素。在这种情况下，你应该确保用erase删除那些不再需要的shared_ptr元素。</p><blockquote><p>如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</p></blockquote><p><strong>使用了动态生存期的资源的类</strong></p><p>程序使用动态内存出于以下三种原因之一：</p><ul><li>程序不知道自己需要使用多少对象</li><li>程序不知道所需对象的准确类型</li><li>程序需要在多个对象间共享数据</li></ul><p>容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因而使用动态内存的例子。在本节中，我们将定义一个类，它使用动态内存是为了让多个对象能共享相同的底层数据。</p><p>某些类分配的资源具有与原对象相独立的生存期。例如，假定我们希望定义一个名为Blob的类，保存一组元素。与容器不同，我们希望Blob对象的不同拷贝之间共享相同的元素。即，当我们拷贝一个Blob时，原Blob对象及其拷贝应该引用相同的底层元素。</p><blockquote><p>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p></blockquote><h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3><p><strong>使用new动态分配和初始化对象</strong></p><p>默认情况下，动态分配的对象是默认初始化的（参见2.2.1节，第40页），这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。也可以对动态分配的对象进行值初始化（参见3.3.1节，第88页），只需在类型名之后跟一对空括号即可</p><p>对于定义了自己的构造函数（参见7.1.4节，第235页）的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的（参见7.1.4节，第236页）。</p><p>如果我们提供了一个括号包围的初始化器，就可以使用auto（参见2.5.2节，第61页）从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto</p><p><img src="/../images/C-C-Primer-Chapter-12/1726457710921.png"></p><p><strong>动态分配的const对象</strong></p><p><img src="/../images/C-C-Primer-Chapter-12/1726457753794.png"></p><p><strong>内存耗尽</strong></p><p>默认情况下，如果new不能分配所要求的内存空间，它会<strong>抛出一个类型为bad_alloc（参见5.6节，第173页）的异常。</strong>我们可以改变使用new的方式来阻止它抛出异常</p><p><img src="/../images/C-C-Primer-Chapter-12/1726457804949.png"></p><p>这种形式的new为定位new（placement new），其原因我们将在19.1.2节（第729页）中解释。定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。</p><p><strong>释放动态内存</strong></p><p><strong>指针值和delete</strong></p><p>我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针（参见2.3.2节，第48页）。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的</p><p><img src="/../images/C-C-Primer-Chapter-12/1726457904246.png"></p><p><strong>动态对象的生存期直到被释放时为止</strong></p><p>返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存</p><p><strong>小心：动态内存的管理非常容易出错</strong></p><p>使用new和delete管理动态内存存在三个常见问题：</p><ul><li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。</li><li>使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。</li><li>同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。相对于查找和修正这些错误来说，制造出这些错误要简单得多。</li></ul><p><strong>delete之后重置指针值，这只是提供了有限的保护</strong></p><h3 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h3><p>如果我们不初始化一个智能指针，它就会被初始化为一个空指针。如表12.3所示，我们还可以用new返回的指针来初始化智能指针</p><p><img src="/../images/C-C-Primer-Chapter-12/1726459676176.png"></p><p>接受指针参数的智能指针构造函数是explicit的（参见7.5.4节，第265页）。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式（参见3.2.1节，第76页）来初始化一个智能指针</p><p><img src="/../images/C-C-Primer-Chapter-12/1726464938912.png"></p><p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。</p><p>我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代delete。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726465035838.png"></p><p><img src="/../images/C-C-Primer-Chapter-12/1726465039905.png"></p><p><strong>不要混合使用普通指针和智能指针</strong></p><p>shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）之间。这也是为什么我们推荐使用make_shared而不是new的原因。这样，我们就能在分配对象的同时就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的shared_ptr上。</p><p><strong>也不要使用get初始化另一个智能指针或为智能指针赋值</strong></p><p>智能指针类型定义了一个名为get的函数（参见表12.1），它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针。</p><p>将另一个智能指针也绑定到get返回的指针上是错误的。</p><blockquote><p><strong>get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。</strong></p></blockquote><h3 id="12-1-4-智能指针和异常"><a href="#12-1-4-智能指针和异常" class="headerlink" title="12.1.4 智能指针和异常"></a>12.1.4 智能指针和异常</h3><p>一个简单的确保资源被释放的方法是使用智能指针。如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放</p><p><strong>智能指针和哑类</strong></p><p>包括所有标准库类在内的很多C++类都定义了析构函数（参见12.1.1节，第402页），负责清理对象使用的资源。但是，不是所有的类都是这样良好定义的。特别是那些为C和C++两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726466771589.png"></p><p>如果connection有一个析构函数，就可以在f结束时由析构函数自动关闭连接。但是，connection没有析构函数。这个问题与我们上一个程序中使用shared_ptr避免内存泄漏几乎是等价的。使用shared_ptr来保证connection被正确关闭，已被证明是一种有效的方法。</p><p><strong>使用我们自己的释放操作</strong></p><p>默认情况下，shared_ptr假定它们指向的是动态内存。因此，当一个shared_ptr被销毁时，它默认地对它管理的指针进行delete操作。为了用shared_ptr来管理一个connection，我们必须首先定义一个函数来代替delete。这个删除器（deleter）函数必须能够完成对shared_ptr中保存的指针进行释放的操作。在本例中，我们的删除器必须接受单个类型为connection＊的参数</p><p><img src="/../images/C-C-Primer-Chapter-12/1726466818477.png"></p><p>当我们创建一个shared_ptr时，可以传递一个（可选的）指向删除器函数的参数（参见6.7节，第221页）</p><p><img src="/../images/C-C-Primer-Chapter-12/1726466848414.png"></p><p><strong>注意：智能指针陷阱</strong></p><p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：</p><ul><li>不使用相同的内置指针值初始化（或reset）多个智能指针。</li><li>不delete get（）返回的指针。</li><li>不使用get（）初始化或reset另一个智能指针。</li><li>如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li><li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（参见12.1.4节，第415页和12.1.5节，第419页）。</li></ul><h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><p>一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726467400523.png"></p><p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作</p><p>虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique</p><p><img src="/../images/C-C-Primer-Chapter-12/1726467583660.png"></p><p><strong>传递unique_ptr参数和返回unique_ptr</strong></p><p>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr</p><p><img src="/../images/C-C-Primer-Chapter-12/1726467663330.png"></p><p>还可以返回一个局部对象的拷贝</p><p><img src="/../images/C-C-Primer-Chapter-12/1726467672422.png"></p><p>对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”，我们将在13.6.2节（第473页）中介绍它。</p><p><strong>向unique_ptr传递删除器</strong></p><p>unique_ptr管理删除器的方式与shared_ptr不同，其原因我们将在16.1.6节（第599页）中介绍。</p><p>重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造（或reset）该类型的对象。与重载关联容器的比较操作（参见11.2.2节，第378页）类似，我们必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或reset一个这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）</p><p><img src="/../images/C-C-Primer-Chapter-12/1726467975308.png"></p><h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><p>weak_ptr（见表12.5）是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726468083703.png"></p><p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它。</p><p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象的shared_ptr。与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就会一直存在。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726468125244.png"></p><h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><p>C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力，原因我们将在12.2.2节（第427页）中解释。</p><p>使用容器的类可以使用默认版本的拷贝、赋值和析构操作（参见7.1.5节，第239页）。分配动态数组的类则必须定义自己版本的操作，在拷贝、复制以及销毁对象时管理所关联的内存。</p><h3 id="12-2-1-new和数组"><a href="#12-2-1-new和数组" class="headerlink" title="12.2.1 new和数组"></a>12.2.1 new和数组</h3><p>为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针</p><p><strong>分配一个数组会得到一个元素类型的指针</strong></p><p>由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end（参见3.5.3节，第106页）。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理（所谓的）动态数组中的元素。</p><blockquote><p>要记住我们所说的动态数组并不是数组类型，这是很重要的。</p></blockquote><p><strong>初始化动态分配对象的数组</strong></p><p>默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化（参见3.3.1节，第88页），方法是在大小之后跟一对空括号。</p><p>在新标准中，我们还可以提供一个元素初始化器的花括号列表。如果初始化器数目小于元素数目，剩余元素将进行值初始化。如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。在本例中，new会抛出一个类型为bad_array_new_length的异常。类似bad_alloc，此类型定义在头文件new中。</p><p><strong>动态分配一个空数组是合法的</strong></p><p>当n等于0时，调用new[n]是合法的。</p><p>new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样（参见3.5.3节，第106页），我们可以像使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。</p><p><strong>释放动态数组</strong></p><p>为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对</p><p><img src="/../images/C-C-Primer-Chapter-12/1726469237720.png"></p><p>数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。</p><p>如果我们在delete一个指向数组的指针时忽略了方括号（或者在delete一个指向单一对象的指针时使用了方括号），其行为是未定义的。</p><p><strong>智能指针和动态数组</strong></p><p>标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号</p><p><img src="/../images/C-C-Primer-Chapter-12/1726469303812.png"></p><p>指向数组的unique_ptr提供的操作与我们在12.1.5节（第417页）中使用的那些操作有一些不同</p><p><img src="/../images/C-C-Primer-Chapter-12/1726469328221.png"></p><p>与unique_ptr不同，shared_ptr不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726469386578.png"></p><p>shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726469425165.png"></p><h3 id="12-2-2-allocator类"><a href="#12-2-2-allocator类" class="headerlink" title="12.2.2 allocator类"></a>12.2.2 allocator类</h3><p>new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。</p><p>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。</p><p><strong>allocator类</strong></p><p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726475054676.png"></p><p>类似vector，allocator是一个模板（参见3.3节，第86页）。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置</p><p><img src="/../images/C-C-Primer-Chapter-12/1726475061308.png"></p><p><strong>allocator分配未构造的内存</strong></p><p>在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。</p><blockquote><p>为了使用allocate返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。</p></blockquote><p>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数（参见12.1.1节，第402页）</p><p>我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。</p><p><strong>拷贝和填充未初始化内存的算法</strong></p><p>标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。表12.8描述了这些函数，它们都定义在头文件memory中。</p><p><img src="/../images/C-C-Primer-Chapter-12/1726475234959.png"></p><p>类似copy，uninitialized_copy返回（递增后的）目的位置迭代器。</p><p>因此，一次uninitialized_copy调用会返回一个指针，指向最后一个构造的元素之后的位置。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 11</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-11/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-11/</url>
    
    <content type="html"><![CDATA[<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><span id="more"></span><p>关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p><p>标准库提供8个关联容器，如表11.1所示。这8个容器间的不同体现在三个维度上：每个容器（1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726389168983.png"></p><h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><p>map是关键字-值对的集合。</p><p>map类型通常被称为关联数组（associative array）。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。</p><p>set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。</p><p><strong>使用map</strong></p><p>为了定义一个map，我们必须指定关键字和值的类型。</p><p>当从map中提取一个元素时，会得到一个pair类型的对象，我们将在11.2.3节（第379页）介绍它。简单来说，pair是一个模板类型，保存两个名为first和second的（公有）数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。</p><p><strong>使用set</strong></p><p>find调用返回一个迭代器。如果给定关键字在set中，迭代器指向该关键字。否则，find返回尾后迭代器。</p><h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p><p>关联容器的迭代器都是双向的。</p><h3 id="11-2-1-定义关联容器"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a>11.2.1 定义关联容器</h3><p><strong>初始化multimap或multiset</strong></p><h3 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h3><p>对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。</p><p><strong>有序容器的关键字类型</strong></p><p>可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个严格弱序（strict weak ordering）。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：</p><ul><li>两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2绝不能“小于等于”k1。</li><li>如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。</li><li>如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价于”k2，且k2“等价于”k3，那么k1必须“等价于”k3。</li></ul><p>如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作map的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。</p><blockquote><p>在实际编程中，重要的是，如果一个类型定义了“行为正常”的&lt;运算符，则它可以用作关键字类型。</p></blockquote><p><strong>使用关键字类型的比较函数</strong></p><p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。</p><p>在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。</p><p>为了使用自己定义的操作，在定义multiset时我们必须提供两个类型：关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型（参见6.7节，第221页），可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726390059889.png"></p><h3 id="11-2-3-pair类型"><a href="#11-2-3-pair类型" class="headerlink" title="11.2.3 pair类型"></a>11.2.3 pair类型</h3><p>定义在头文件utility中。</p><p>一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样</p><p>pair的默认构造函数对数据成员进行值初始化（参见3.3.1节，第88页）。</p><p>与其他标准库类型不同，pair的数据成员是public的（参见7.2节，第240页）。两个成员分别命名为first和second。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726390434783.png"></p><h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><p>除了表9.2（第295页）中列出的类型，关联容器还定义了表11.3中列出的类型。这些类型表示容器关键字和值的类型。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726390657794.png"></p><h3 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h3><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型，其first成员保存const的关键字，second成员保存值</p><p><strong>set的迭代器是const的</strong></p><p>虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改</p><p><strong>遍历关联容器</strong></p><blockquote><p>当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。</p></blockquote><p><strong>关联容器和算法</strong></p><p>我们通常不对关联容器使用泛型算法（参见第10章）。关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。</p><p>关联容器可用于只读取元素的算法。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行（快速）查找，因此对其使用泛型搜索算法几乎总是个坏主意。</p><p>关联容器定义了一个名为find的成员，它通过一个给定的关键字直接获取元素。我们可以用泛型find算法来查找一个元素，但此算法会进行顺序搜索。使用关联容器定义的专用的find成员会比调用泛型find快得多。</p><h3 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h3><p>关联容器的insert成员（见表11.4，第384页）向容器中添加一个元素或一个元素范围。由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响</p><p>insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数（参见11.2.1节，第376页）——对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中。</p><p><strong>向map添加元素</strong></p><p>对一个map进行insert操作时，必须记住元素类型是pair。通常，对于想要插入的数据，并没有一个现成的pair对象。可以在insert的参数列表中创建一个pair</p><p><img src="/../images/C-C-Primer-Chapter-11/1726390972049.png"></p><p><strong>检测insert的返回值</strong></p><p><strong>向multiset或multimap添加元素</strong></p><h3 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h3><p>关联容器定义了三个版本的erase，如表11.5所示。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。这两个版本的erase与对应的顺序容器的操作非常相似：指定的元素被删除，函数返回void。</p><p>关联容器提供一个额外的erase操作，它接受一个key_type参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726391205794.png"></p><h3 id="11-3-4-map的下标操作"><a href="#11-3-4-map的下标操作" class="headerlink" title="11.3.4 map的下标操作"></a>11.3.4 map的下标操作</h3><p>map和unordered_map容器提供了下标运算符和一个对应的at函数（参见9.3.2节，第311页），如表11.6所示。set类型不支持下标，因为set中没有与关键字相关联的“值”。</p><p>我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。</p><p>如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化（参见3.3.1节，第88页）。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726391287199.png"></p><p>将会执行如下操作：</p><ul><li>在word_count中搜索关键字为Anna的元素，未找到。</li><li>将一个新的关键字-值对插入到word_count中。关键字是一个const string，保存Anna。值进行值初始化，在本例中意味着值为0。</li><li>提取出新插入的元素，并将值1赋予它。</li></ul><p>由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726391330440.png"></p><h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><p><img src="/../images/C-C-Primer-Chapter-11/1726391522187.png"></p><p><img src="/../images/C-C-Primer-Chapter-11/1726391528397.png"></p><p><strong>对map使用find代替下标操作</strong></p><p>我们只是想知道一个给定关键字是否在map中，而不想改变map。这样就不能使用下标运算符来检查一个元素是否存在，因为如果关键字不存在的话，下标运算符会插入一个新元素。在这种情况下，应该使用find</p><p><strong>在multimap或multiset中查找元素</strong></p><p>如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。</p><p>例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。</p><p>可以用三种不同方法来解决这个问题。最直观的方法是使用find和count：</p><p><img src="/../images/C-C-Primer-Chapter-11/1726391774290.png"></p><p><strong>一种不同的，面向迭代器的解决方法</strong></p><p>我们还可以用lower_bound和upper_bound来解决此问题。这两个操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置。如果元素不在multimap中，则lower_bound和upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。因此，用相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围（参见9.2.1节，第296页），表示所有具有该关键字的元素的范围。</p><p>这两个操作返回的迭代器可能是容器的尾后迭代器。如果我们查找的元素具有容器中最大的关键字，则此关键字的upper_bound返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则lower_bound返回的也是尾后迭代器。</p><blockquote><p>lower_bound返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则lower_bound会返回关键字的第一个安全插入点——不影响容器中元素顺序的插入位置。</p></blockquote><p><img src="/../images/C-C-Primer-Chapter-11/1726392086527.png"></p><p><strong>equal_range函数</strong></p><p>解决此问题的最后一种方法是三种方法中最直接的：不必再调用upper_bound和lower_bound，直接调用equal_range即可。此函数接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726396333694.png"></p><h3 id="11-3-6-一个单词转换的map"><a href="#11-3-6-一个单词转换的map" class="headerlink" title="11.3.6 一个单词转换的map"></a>11.3.6 一个单词转换的map</h3><p>给定一个string，将它转换为另一个string。程序的输入是两个文件。第一个文件保存的是一些规则，用来转换第二个文件中的文本。每条规则由两部分组成：一个可能出现在输入文件中的单词和一个用来替换它的短语。表达的含义是，每当第一个单词出现在输入中时，我们就将它替换为对应的短语。第二个输入文件包含要转换的文本。</p><h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><p>新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数（hash function）和关键字类型的&#x3D;&#x3D;运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。</p><p><strong>使用无序容器</strong></p><p>通常可以用一个无序容器替换对应的有序容器，反之亦然。</p><p><strong>管理桶</strong></p><p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p><p>对于相同的参数，哈希函数必须总是产生相同的结果。</p><p>当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。</p><p>无序容器提供了一组管理桶的函数，如表11.8所示。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p><p><img src="/../images/C-C-Primer-Chapter-11/1726400739462.png"></p><p><strong>无序容器对关键字类型的要求</strong></p><p>无序容器使用关键字类型的&#x3D;&#x3D;运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要在第12章介绍的智能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针类型的无序容器。</p><p>不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。我们将在16.5节（第626页）中介绍如何做到这一点。</p><p>我们不使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作（参见11.2.2节，第378页）。为了能将Sale_data用作关键字，我们需要提供函数来替代&#x3D;&#x3D;运算符和哈希值计算函数。我们从定义这些重载函数开始</p><p><img src="/../images/C-C-Primer-Chapter-11/1726401255757.png"></p><p><img src="/../images/C-C-Primer-Chapter-11/image-20240922131357012.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 10</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-10/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-10/</url>
    
    <content type="html"><![CDATA[<h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><span id="more"></span><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><p>大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。</p><p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围（参见9.2.1节，第296页）来进行操作。</p><p><strong>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作</strong></p><p><strong>关键概念：算法永远不会执行容器的操作</strong></p><p>算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p><h2 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法</h2><h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><p>一些算法只会读取其输入范围内的元素，而从不改变元素。</p><p>find就是这样一种算法，我们在10.1节练习（第337页）中使用的count函数也是如此。另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。</p><p><strong>算法和元素类型</strong></p><p>对于只读取而不改变元素的算法，通常最好使用cbegin（）和cend（）（参见9.2.3节，第298页）。但是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用begin（）和end（）的结果作为参数。</p><p><strong>操作两个序列的算法</strong></p><p>另一个只读算法是equal，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器：前两个（与以往一样）表示第一个序列中的元素范围，第三个表示第二个序列的首元素。equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。</p><blockquote><p>那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</p></blockquote><h3 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h3><p>算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726201288551.png"></p><p><strong>算法不检查写操作</strong></p><p>函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素。函数fill_n假定写入指定个元素是安全的。</p><p><strong>介绍back_inserter</strong></p><p>一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</p><p>我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。</p><p>back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中</p><p><strong>拷贝算法</strong></p><p>拷贝（copy）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。</p><p>copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。</p><p>多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。</p><p>replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值</p><p>此调用将序列中所有的0都替换为42。如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置</p><p><img src="/../images/C-C-Primer-Chapter-10/1726228439564.png"></p><p>此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42。</p><h3 id="10-2-3-重排容器元素的算法"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a>10.2.3 重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;运算符来实现排序的。</p><p><strong>消除重复单词</strong></p><p>为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作</p><p><img src="/../images/C-C-Primer-Chapter-10/1726228562655.png"></p><p><strong>使用unique</strong></p><p>unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。</p><p>unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。</p><p><strong>使用容器操作删除元素</strong></p><h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><h3 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h3><p>为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个谓词（predicate）。</p><p><strong>谓词</strong></p><p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate，意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。</p><p>接受一个二元谓词参数的sort版本用这个谓词代替&lt;来比较元素。我们提供给sort的谓词必须满足将在11.2.2节（第378页）中所介绍的条件。</p><p><strong>排序算法</strong></p><p>为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726229177622.png"></p><p>标准库定义了名为partition的算法，它接受一个谓词，对容器内容进行划分，使得谓词为true的值会排在容器的前半部分，而使谓词为false的值会排在后半部分。算法返回一个迭代器，指向最后一个使谓词为true的元素之后的位置。</p><h3 id="10-3-2-lambda表达式"><a href="#10-3-2-lambda表达式" class="headerlink" title="10.3.2 lambda表达式"></a>10.3.2 lambda表达式</h3><p>我们可以使用标准库find_if算法来查找第一个具有特定大小的元素。类似find（参见10.1节，第336页），find_if算法接受一对迭代器，表示一个范围。但与find不同的是，find_if的第三个参数是一个谓词。find_if算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。</p><p>find_if接受一元谓词——我们传递给find_if的任何函数都必须严格接受一个参数，以便能用来自输入序列的一个元素调用它。没有任何办法能传递给它第二个参数来表示长度。为了解决此问题，需要使用另外一些语言特性。</p><p><strong>介绍lambda</strong></p><p>我们可以向一个算法传递任何类别的<strong>可调用对象（callable object）。</strong>对于一个对象或一个表达式，如果可以对其使用调用运算符（参见1.5.2节，第21页），则称它为可调用的。即，如果e是一个可调用的表达式，则我们可以编写代码e（args），其中args是一个逗号分隔的一个或多个参数的列表。</p><p>我们使用过的仅有的两种可调用对象是函数和函数指针（参见6.7节，第221页）。还有其他两种可调用对象：重载了函数调用运算符的类，我们将在14.8节（第506页）介绍，以及lambda表达式（lambda expression）。</p><p>一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726229740080.png"></p><p>capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）；return type、parameter list和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，lambda必须使用尾置返回（参见6.3.3节，第206页）来指定返回类型。我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p><blockquote><p>如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。</p></blockquote><p><strong>向lambda传递参数</strong></p><p>lambda不能有默认参数（参见6.5.1节，第211页）。</p><p><strong>使用捕获列表</strong></p><p>虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。</p><blockquote><p>一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p></blockquote><p><strong>for_each算法</strong></p><p>此算法接受一个可调用对象，并对输入序列中每个元素调用此对象</p><p>一个lambda可以直接使用定义在当前函数之外的名字。</p><blockquote><p>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。</p></blockquote><h3 id="10-3-3-lambda捕获和返回"><a href="#10-3-3-lambda捕获和返回" class="headerlink" title="10.3.3 lambda捕获和返回"></a>10.3.3 lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。</p><p>可以这样理解，当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。</p><p>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。</p><p><strong>值捕获</strong></p><p>与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝</p><p><img src="/../images/C-C-Primer-Chapter-10/1726231363510.png"></p><p>由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对应的值。</p><p><strong>引用捕获</strong></p><p>引用捕获与返回引用（参见6.3.2节，第201页）有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就<strong>必须确保被引用的对象在lambda执行的时候是存在的。</strong>lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。</p><p>我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。</p><p><strong>建议：尽量保持lambda的变量捕获简单化</strong></p><p>一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。</p><p><strong>隐式捕获</strong></p><p>可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或&#x3D;。&amp;告诉编译器采用捕获引用方式，&#x3D;则表示采用值捕获方式。</p><p>如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获</p><p><img src="/../images/C-C-Primer-Chapter-10/1726231669244.png"></p><p>当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或&#x3D;。此符号指定了默认捕获方式为引用或值。</p><p>当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726231713032.png"></p><p><strong>可变lambda</strong></p><p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726231941506.png"></p><p>一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型</p><p><img src="/../images/C-C-Primer-Chapter-10/1726231959765.png"></p><p><strong>指定lambda返回类型</strong></p><p>函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。</p><p>当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型（参见6.3.3节，第206页）</p><p><img src="/../images/C-C-Primer-Chapter-10/1726232047309.png"></p><h3 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h3><p>如果lambda的捕获列表为空，通常可以用函数来代替它。</p><p>但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。</p><p><strong>标准库bind函数</strong></p><p>我们可以解决向check_size传递一个长度参数的问题，方法是使用一个新的名为bind的标准库函数，它定义在头文件functional中。可以将bind函数看作一个通用的函数适配器（参见9.6节，第329页），它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726233370917.png"></p><p>newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。</p><p>arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，依此类推。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726233503447.png"></p><p>此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&amp;。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726233561900.png"></p><p><strong>使用placeholders名字</strong></p><p>名字_n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间（参见3.1节，第74页）中。为了使用这些名字，两个命名空间都要写上。</p><p><strong>bind的参数</strong></p><p>我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。</p><p>例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用</p><p><img src="/../images/C-C-Primer-Chapter-10/1726233710338.png"></p><p>生成一个新的可调用对象，它有两个参数，分别用占位符_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑定到给定的值a、b和c上。传递给g的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。</p><p><strong>用bind重排参数顺序</strong></p><p><strong>绑定引用参数</strong></p><p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。</p><p>如果我们希望传递给bind一个对象而又不拷贝它，就<strong>必须使用标准库ref函数</strong></p><p><img src="/../images/C-C-Primer-Chapter-10/1726233958032.png"></p><p>函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。</p><h2 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h2><p>除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。</p><ul><li>插入迭代器（insert iterator）：这些迭代器被绑定到一个容器上，可用来向容器插入元素。</li><li>流迭代器（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</li><li>反向迭代器（reverse iterator）：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。</li><li>移动迭代器（move iterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它们。我们将在13.6.2节（第480页）介绍移动迭代器。</li></ul><h3 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h3><p>插入器是一种迭代器适配器（参见9.6节，第329页），它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726234353465.png"></p><p>插入器有三种类型，差异在于元素插入的位置：</p><ul><li>back_inserter（参见10.2.2节，第341页）创建一个使用push_back的迭代器</li><li>front_inserter创建一个使用push_front的迭代器。</li><li>inserter创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</li></ul><blockquote><p>只有在容器支持push_front的情况下，我们才可以使用front_inserter。类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter。</p></blockquote><p>当调用inserter（c，iter）时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如果it是由inserter生成的迭代器，则下面这样的赋值语句</p><p><img src="/../images/C-C-Primer-Chapter-10/1726234467621.png"></p><p>其效果与下面代码一样</p><p><img src="/../images/C-C-Primer-Chapter-10/1726234477582.png"></p><p>front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726234621651.png"></p><h3 id="10-4-2-iostream迭代器"><a href="#10-4-2-iostream迭代器" class="headerlink" title="10.4.2 iostream迭代器"></a>10.4.2 iostream迭代器</h3><p>istream_iterator（参见表10.3）读取输入流，ostream_iterator（参见表10.4节，第361页）向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</p><p><strong>istream_iterator操作</strong></p><p>当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。</p><p>一个istream_iterator使用&gt;&gt;来读取流。因此，istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726234818281.png"></p><p>下面是一个用istream_iterator从标准输入读取数据，存入一个vector的例子：</p><p><img src="/../images/C-C-Primer-Chapter-10/1726234827719.png"></p><p>此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空的istream_iterator，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。</p><p>我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726234885880.png"></p><p>这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726234931737.png"></p><p><strong>使用算法操作流迭代器</strong></p><p>由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。我们在10.5.1节（第365页）会看到如何分辨哪些算法可以用于流迭代器。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726300333345.png"></p><p><strong>istream_iterator允许使用懒惰求值</strong></p><p>当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。</p><p><strong>ostream_iterator操作</strong></p><p>我们可以对任何具有输出运算符（&lt;&lt;运算符）的类型定义ostream_iterator。当创建一个ostream_iterator时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726300458868.png"></p><p><img src="/../images/C-C-Primer-Chapter-10/1726300619260.png"></p><p>out_iter++实际不对迭代器做任何操作，但还是推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。</p><p>可以通过调用copy来打印vec中的元素，这比编写循环更为简单</p><p><img src="/../images/C-C-Primer-Chapter-10/1726300802026.png"></p><p><strong>使用流迭代器处理类类型</strong></p><h3 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（–it）会移动到下一个元素。</p><p>除了forward_list之外，其他容器都支持反向迭代器。</p><p>我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726302994585.png"></p><p>虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做使我们可以用算法透明地向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减序：</p><p><img src="/../images/C-C-Primer-Chapter-10/1726303038287.png"></p><p><strong>反向迭代器需要递减运算符</strong></p><p>流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。</p><p><strong>反向迭代器和其他迭代器间的关系</strong></p><p>我们使用的是反向迭代器，会反向处理string。因此，上述输出语句从crbegin开始反向打印line中内容。而我们希望按正常顺序打印从rcomma开始到line末尾间的字符。但是，我们不能直接使用rcomma。因为它是一个反向迭代器，意味着它会反向朝着string的开始位置移动。需要做的是，将rcomma转换回一个普通迭代器，能在line中正向移动。我们通过调用reverse_iterator的base成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器：</p><p><img src="/../images/C-C-Primer-Chapter-10/1726303307514.png"></p><p><img src="/../images/C-C-Primer-Chapter-10/1726303318130.png" alt="1726303318130"></p><h2 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别（iterator category），如表10.5所示。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726303617577.png"></p><p>第二种算法分类的方式（如我们在本章开始所做的）是按照是否读、写或是重排序列中的元素来分类。附录A按这种分类方法列出了所有算法。</p><h3 id="10-5-1-5类迭代器"><a href="#10-5-1-5类迭代器" class="headerlink" title="10.5.1 5类迭代器"></a>10.5.1 5类迭代器</h3><p><strong>迭代器类别</strong></p><p>1.输入迭代器（input iterator）：可以读取序列中的元素。</p><p>一个输入迭代器必须支持:</p><ul><li>用于比较两个迭代器的相等和不相等运算符（&#x3D;&#x3D;、！&#x3D;）</li><li>用于推进迭代器的前置和后置递增运算（++）</li><li>用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧</li><li>箭头运算符（-&gt;），等价于（*it）.member，即，解引用迭代器，并提取对象的成员</li></ul><p>输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法find和accumulate要求输入迭代器；而istream_iterator是一种输入迭代器。</p><p>2.输出迭代器（output iterator）：可以看作输入迭代器功能上的补集——只写而不读元素。</p><p>输出迭代器必须支持</p><ul><li>用于推进迭代器的前置和后置递增运算（++）</li><li>解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）</li></ul><p>我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器。</p><p>3.前向迭代器（forward iterator）：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。</p><p>4.双向迭代器（bidirectional iterator）：可以正向&#x2F;反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（–）。算法reverse要求双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。</p><p>5.随机访问迭代器（random-access iterator）：提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持表3.7（第99页）中的操作：</p><ul><li>用于比较两个迭代器相对位置的关系运算符（&lt;、&lt;&#x3D;、&gt;和&gt;&#x3D;）</li><li>迭代器和一个整数值的加减运算（+、+&#x3D;、-和-&#x3D;），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置</li><li>用于两个迭代器上的减法运算符（-），得到两个迭代器的距离</li><li>下标运算符（iter[n]），与＊（iter[n]）等价</li></ul><p>算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</p><h3 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h3><p>大多数算法具有如下4种形式之一：</p><p><img src="/../images/C-C-Primer-Chapter-10/1726307764902.png"></p><p><strong>接受单个目标迭代器的算法</strong></p><p>dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。</p><p><strong>接受第二个输入序列的算法</strong></p><p>接受单独的beg2或是接受beg2和end2的算法用这些迭代器表示第二个输入范围。这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。</p><h3 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h3><p>算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个操作代替默认的&lt;或&#x3D;&#x3D;运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p><p><strong>一些算法使用重载形式传递一个谓词</strong></p><p>接受谓词参数来代替&lt;或&#x3D;&#x3D;运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替&lt;或&#x3D;&#x3D;：</p><p><img src="/../images/C-C-Primer-Chapter-10/1726307944623.png"></p><p><strong>_if版本的算法</strong></p><p>接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词（参见10.3.1节，第344页）代替元素值。接受谓词参数的算法都有附加的_if前缀：</p><p><img src="/../images/C-C-Primer-Chapter-10/1726307986000.png"></p><p><strong>区分拷贝元素的版本和不拷贝的版本</strong></p><p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个_copy（参见10.2.2节，第341页）：</p><p><img src="/../images/C-C-Primer-Chapter-10/1726308018039.png"></p><p>一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词：</p><p><img src="/../images/C-C-Primer-Chapter-10/1726308043920.png"></p><h2 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h2><p>与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法，如表10.6所示。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726308113330.png"></p><p><img src="/../images/C-C-Primer-Chapter-10/1726308167608.png"></p><p><strong>splice成员</strong></p><p>此算法是链表数据结构所特有的，因此不需要通用版本。</p><p><img src="/../images/C-C-Primer-Chapter-10/1726308197673.png"></p><p><strong>链表特有的操作会改变容器</strong></p><p>链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，remove的链表版本会删除指定的元素。unique的链表版本会删除第二个和后继的重复元素。</p><p>类似的，merge和splice会销毁其参数。例如，通用版本的merge将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。在merge之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 9</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-9/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-9/</url>
    
    <content type="html"><![CDATA[<h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><span id="more"></span><p>一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的，我们将在第11章介绍的有序和无序关联容器，则根据关键字的值来存储元素。</p><h2 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h2><p>表9.1列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p><ul><li>向容器添加或从容器中删除元素的代价</li><li>非顺序访问容器中元素的代价</li></ul><p><img src="/../images/C-C-Primer-Chapter-9/1726125028655.png"></p><p>1.string和vector</p><p>将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时</p><p>2.list和forward_list</p><p>何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问。与vector、deque和array相比，这两个容器的额外内存开销也很大。</p><p>3.deque</p><p>与string和vector类似，deque支持快速的随机访问。与string和vector一样，在deque的中间位置添加或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的，与list或forward_list添加删除元素的速度相当。</p><p>4.forward_list和array是新C++标准增加的类型。</p><p>与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。</p><p>forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。</p><p>对其他容器而言，size保证是一个快速的常量时间的操作。</p><blockquote><p>新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。</p></blockquote><p><strong>确定使用哪种顺序容器</strong></p><p>以下是一些选择容器的基本原则：</p><ul><li>除非你有很好的理由选择其他容器，否则应使用vector。</li><li>如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。</li><li>如果程序要求随机访问元素，应使用vector或deque。</li><li>如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。</li><li>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。</li><li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则<ul><li>首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数（我们将在10.2.3节介绍sort（第343页））来重排容器中的元素，从而避免在中间位置添加元素。</li><li>如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。</li><li>如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那该怎么办？答案取决于在list或forward_list中访问元素与vector或deque中插入&#x2F;删除元素的相对性能。一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入&#x2F;删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。</li></ul></li></ul><h2 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h2><p>容器类型上的操作形成了一种层次：</p><ul><li>某些操作是所有容器类型都提供的（参见表9.2，第295页）。</li><li>另外一些操作仅针对顺序容器（参见表9.3，第299页）、关联容器（参见表11.7，第388页）或无序容器（参见表11.8，第395页）。</li><li>还有一些操作只适用于一小部分容器。</li></ul><p>本节介绍对所有容器都适用的操作。</p><p><strong>对容器可以保存的元素类型的限制</strong></p><p>但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726125619215.png"></p><p><img src="/../images/C-C-Primer-Chapter-9/1726125625747.png"></p><p><img src="/../images/C-C-Primer-Chapter-9/1726125631614.png"></p><h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><p><strong>迭代器范围</strong></p><p>这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为</p><p><img src="/../images/C-C-Primer-Chapter-9/image-20240922131109226.png"></p><p><strong>使用左闭合范围蕴含的编程假定</strong></p><ul><li>如果begin与end相等，则范围为空</li><li>如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</li><li>我们可以对begin递增若干次，使得begin&#x3D;&#x3D;end</li></ul><h3 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726126013015.png"></p><h3 id="9-2-3-begin和end成员"><a href="#9-2-3-begin和end成员" class="headerlink" title="9.2.3 begin和end成员"></a>9.2.3 begin和end成员</h3><blockquote><p>当不需要写访问时，应使用cbegin和cend。</p></blockquote><h3 id="9-2-4-容器定义和初始化"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726126194086.png"></p><p><strong>将一个容器初始化为另一个容器的拷贝</strong></p><p>为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换（参见4.11节，第141页）为要初始化的容器的元素类型即可。</p><p><strong>列表初始化</strong></p><p><img src="/../images/C-C-Primer-Chapter-9/1726126304682.png"></p><p><strong>与顺序容器大小相关的构造函数</strong></p><p>顺序容器（array除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器（参见3.3.1节，第88页)</p><blockquote><p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p></blockquote><p><strong>标准库array具有固定大小</strong></p><p>与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小</p><p><img src="/../images/C-C-Primer-Chapter-9/1726126472765.png"></p><p>与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化（参见2.2.1节，第40页），就像一个内置数组（参见3.5.1节，第102页）中的元素那样。如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小。如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余元素都会进行值初始化（参见3.3.1节，第88页）。</p><p>值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作（参见3.5.1节，第102页），但array并无此限制</p><h3 id="9-2-5-赋值和swap"><a href="#9-2-5-赋值和swap" class="headerlink" title="9.2.5 赋值和swap"></a>9.2.5 赋值和swap</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726126984472.png"></p><p><strong>使用assign（仅顺序容器）</strong></p><p>顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。</p><p>assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素。</p><p><strong>使用swap</strong></p><p>swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换</p><p>除array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个容器的内部数据结构。</p><p>除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。</p><p>元素不会被移动的事实意味着，<strong>除string外</strong>，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。</p><p><strong>与其他容器不同</strong>，对一个string调用swap会导致迭代器、引用和指针失效。</p><p><strong>与其他容器不同</strong>，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。</p><blockquote><p>在新标准库中，容器既提供成员函数版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个好习惯。</p></blockquote><h3 id="9-2-6-容器大小操作"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作</h3><p>成员函数size（参见3.2.2节，第78页）返回容器中元素的数目；</p><p>empty当size为0时返回布尔值true，否则返回false；</p><p>max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。</p><p>forward_list支持max_size和empty，但不支持size</p><h3 id="9-2-7-关系运算符"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符</h3><p>每个容器类型都支持相等运算符（&#x3D;&#x3D;和！&#x3D;）；除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。</p><p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算（参见3.2.2节，第79页）类似</p><p><strong>容器的关系运算符使用元素的关系运算符完成比较</strong></p><blockquote><p><strong>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</strong></p></blockquote><h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><h3 id="9-3-1-向顺序容器添加元素"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726129802754.png"></p><p><strong>使用push_back</strong></p><p>除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。</p><p><strong>关键概念：容器元素是拷贝</strong></p><p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数（参见3.2.2节，第79页）一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</p><p><strong>使用push_front</strong></p><p>list、forward_list和deque容器还支持名为push_front的类似操作。</p><p>注意，deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间。</p><p><strong>在容器中的特定位置添加元素</strong></p><p>insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员，我们将在9.3.4节（第312页）中介绍。</p><p>每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，所以<strong>insert函数将元素插入到迭代器所指定的位置</strong>之前。</p><p><strong>插入范围内元素</strong></p><p>接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化</p><p>接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前</p><p>如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。</p><p>在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。（在旧版本的标准库中，这些操作返回void。）如果范围为空，不插入任何元素，insert操作会将第一个参数返回。</p><p><strong>使用insert的返回值</strong></p><p>通过使用insert的返回值，可以在容器中一个特定位置反复插入元素</p><p><img src="/../images/C-C-Primer-Chapter-9/1726151272102.png"></p><p><strong>使用emplace操作</strong></p><p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。</p><blockquote><p>emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。</p></blockquote><h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><p>如果容器中没有元素，访问操作的结果是未定义的。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726151419791.png"></p><p><strong>访问成员函数返回的是引用</strong></p><p>如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。</p><p><strong>下标操作和安全的随机访问</strong></p><p>如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常（参见5.6节，第173页）</p><h3 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726151897306.png"></p><blockquote><p>删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它（们）是存在的。</p></blockquote><p><strong>pop_front和pop_back成员函数</strong></p><p>这些操作返回void。如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它</p><p><strong>从容器内部删除一个元素</strong></p><p>两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。</p><p><strong>删除多个元素</strong></p><h3 id="9-3-4-特殊的forward-list操作"><a href="#9-3-4-特殊的forward-list操作" class="headerlink" title="9.3.4 特殊的forward_list操作"></a>9.3.4 特殊的forward_list操作</h3><p>forward_list并未定义insert、emplace和erase，而是定义了名为insert_after、emplace_after和erase_after的操作</p><p><img src="/../images/C-C-Primer-Chapter-9/1726152308687.png"></p><p>forward_list也定义了before_begin，它返回一个首前（off-the-beginning）迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。</p><h3 id="9-3-5-改变容器大小"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小</h3><p>我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部</p><p>resize操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化（参见3.3.1节，第88页）。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726152646667.png"></p><h3 id="9-3-6-容器操作可能使迭代器失效"><a href="#9-3-6-容器操作可能使迭代器失效" class="headerlink" title="9.3.6 容器操作可能使迭代器失效"></a>9.3.6 容器操作可能使迭代器失效</h3><p>在向容器添加元素后：</p><ul><li>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</li><li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li><li>对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。</li></ul><p>当我们删除一个元素后：</p><ul><li>对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。</li><li>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</li><li>对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。</li></ul><p><strong>建议：管理迭代器</strong></p><p>当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p><p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector、string和deque尤为重要。</p><p><strong>编写改变容器的循环程序</strong></p><p>添加&#x2F;删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新</p><p><img src="/../images/C-C-Primer-Chapter-9/1726152845237.png"></p><p><strong>不要保存end返回的迭代器</strong></p><p>当我们添加&#x2F;删除vector或string的元素后，或在deque中首元素之外任何位置添加&#x2F;删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当作容器末尾使用。通常C++标准库的实现中end（）操作都很快，部分就是因为这个原因。</p><h2 id="9-4-vector对象是如何增长的"><a href="#9-4-vector对象是如何增长的" class="headerlink" title="9.4 vector对象是如何增长的"></a>9.4 vector对象是如何增长的</h2><p>当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。</p><p><strong>管理容量的成员函数</strong></p><p><img src="/../images/C-C-Primer-Chapter-9/1726153094106.png"></p><p>只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。</p><p>如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。</p><p>如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。</p><p>因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。这样，调用reserve永远也不会减少容器占用的内存空间。</p><p>类似的，resize成员函数（参见9.3.5节，第314页）只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。</p><p>在新标准库中，我们可以调用shrink_to_fit来要求deque、vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。</p><p><strong>capacity和size</strong></p><p>虽然不同的实现可以采用不同的分配策略，但所有实现都应遵循一个原则：确保用push_back向vector添加元素的操作有高效率。从技术角度说，就是通过在一个初始为空的vector上调用n次push_back来创建一个n个元素的vector，所花费的时间不能超过n的常数倍。</p><h2 id="9-5-额外的string操作"><a href="#9-5-额外的string操作" class="headerlink" title="9.5 额外的string操作"></a>9.5 额外的string操作</h2><p>后面用到的时候再来查</p><h3 id="9-5-1-构造string的其他方法"><a href="#9-5-1-构造string的其他方法" class="headerlink" title="9.5.1 构造string的其他方法"></a>9.5.1 构造string的其他方法</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726153366845.png"></p><p><strong>substr操作</strong></p><p>substr操作（参见表9.12）返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substr一个可选的开始位置和计数值</p><p>如果开始位置超过了string的大小，则substr函数抛出一个out_of_range异常（参见5.6节，第173页）。如果开始位置加上计数值大于string的大小，则substr会调整计数值，只拷贝到string的末尾。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726153449111.png"></p><h3 id="9-5-2-改变string的其他方法"><a href="#9-5-2-改变string的其他方法" class="headerlink" title="9.5.2 改变string的其他方法"></a>9.5.2 改变string的其他方法</h3><p>除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到给定值之前的位置</p><p><strong>append和replace函数</strong></p><p><img src="/../images/C-C-Primer-Chapter-9/1726153581945.png"></p><p><img src="/../images/C-C-Primer-Chapter-9/1726153593456.png"></p><p><strong>改变string的多种重载函数</strong></p><h3 id="9-5-3-string搜索操作"><a href="#9-5-3-string搜索操作" class="headerlink" title="9.5.3 string搜索操作"></a>9.5.3 string搜索操作</h3><p>string类提供了6个不同的搜索函数，每个函数都有4个重载版本。表9.14描述了这些搜索成员函数及其参数。每个搜索操作都返回一个string：：size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string：：npos的static成员（参见7.6节，第268页）。标准库将npos定义为一个const string：：size_type类型，并初始化为值-1。由于npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可能大小（参见2.1.2节，第32页）。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726153688759.png"></p><p><img src="/../images/C-C-Primer-Chapter-9/1726153692156.png"></p><h3 id="9-5-4-compare函数"><a href="#9-5-4-compare函数" class="headerlink" title="9.5.4 compare函数"></a>9.5.4 compare函数</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726153729745.png"></p><h3 id="9-5-5-数值转换"><a href="#9-5-5-数值转换" class="headerlink" title="9.5.5 数值转换"></a>9.5.5 数值转换</h3><p>新标准引入了多个函数，可以实现数值数据与标准库string之间的转换</p><p><img src="/../images/C-C-Primer-Chapter-9/1726153770508.png"></p><p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符</p><p>string参数中第一个非空白符必须是符号（+ 或 -）或数字。它可以以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函数，string参数也可以以小数点（.）开头，并可以包含e或E来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，string参数可以包含字母字符，对应大于数字9的数。</p><p>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常（参见5.6节，第173页）。如果转换得到的数值无法用任何类型来表示，则抛出一个out_of_range异常。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726153854406.png"></p><h2 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h2><p>除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。适配器（adaptor）是标准库中的一个通用概念。容器、迭代器和函数都有适配器。</p><p>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list外），并使其操作起来像一个stack一样。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726153935087.png"></p><p><strong>定义一个适配器</strong></p><p>每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。</p><p>默认情况下，<strong>stack和queue是基于deque实现的</strong>，<strong>priority_queue是在vector之上实现的</strong>。</p><p>我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726154019522.png"></p><p>对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用forward_list来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力。</p><p>stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack。</p><p>queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。</p><p>priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。</p><p><strong>栈适配器</strong></p><p>stack类型定义在stack头文件中。表9.18列出了stack所支持的操作。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726154101439.png"></p><p><img src="/../images/C-C-Primer-Chapter-9/1726154156115.png"></p><p><strong>队列适配器</strong></p><p>queue和priority_queue适配器定义在queue头文件中。</p><p><img src="/../images/C-C-Primer-Chapter-9/1726154196324.png" alt="1726154196324"></p><p><img src="/../images/C-C-Primer-Chapter-9/image-20240922131124573.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 8</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-8/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-8/</url>
    
    <content type="html"><![CDATA[<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><span id="more"></span><p>C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO，即，从string读取数据，向string写入数据。</p><h2 id="8-1-IO类"><a href="#8-1-IO类" class="headerlink" title="8.1 IO类"></a>8.1 IO类</h2><p><img src="/../images/C-C-Primer-Chapter-8/1726120413211.png"></p><p><strong>IO类型间的关系</strong></p><p>类型ifstream和istringstream都继承自istream。因此，我们可以像使用istream对象一样来使用ifstream和istringstream对象。也就是说，我们是如何使用cin的，就可以同样地使用这些类型的对象。例如，可以对一个ifstream或istringstream对象调用getline，也可以使用&gt;&gt;从一个ifstream或istringstream对象中读取数据。类似的，类型ofstream和ostringstream都继承自ostream。因此，我们是如何使用cout的，就可以同样地使用这些类型的对象。</p><blockquote><p>本节剩下部分所介绍的标准库流特性都可以无差别地应用于普通流、文件流和string流，以及char或宽字符流版本。</p></blockquote><h3 id="8-1-1-IO对象无拷贝或赋值"><a href="#8-1-1-IO对象无拷贝或赋值" class="headerlink" title="8.1.1 IO对象无拷贝或赋值"></a>8.1.1 IO对象无拷贝或赋值</h3><p>我们不能拷贝或对IO对象赋值。</p><p>我们也不能将形参或返回类型设置为流类型（参见6.2.1节，第188页）。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p><h3 id="8-1-2-条件状态"><a href="#8-1-2-条件状态" class="headerlink" title="8.1.2 条件状态"></a>8.1.2 条件状态</h3><p><img src="/../images/C-C-Primer-Chapter-8/1726120976621.png"></p><p><img src="/../images/C-C-Primer-Chapter-8/1726120982490.png"></p><p><img src="/../images/C-C-Primer-Chapter-8/1726121084201.png"></p><p>如果我们在标准输入上键入Boo，读操作就会失败。代码中的输入运算符期待读取一个int，但却得到了一个字符B。这样，cin会进入错误状态。类似的，如果我们输入一个文件结束标识，cin也会进入错误状态。</p><p>一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用</p><p><img src="/../images/C-C-Primer-Chapter-8/1726121103849.png"></p><p><strong>查询流的状态</strong></p><p>将流作为条件使用，只能告诉我们流是否有效，而无法告诉我们具体发生了什么。</p><p>IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用</p><p>IO库定义了4个iostate类型的constexpr值（参见2.4.4节，第58页），表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符（参见4.8节，第137页）一起使用来一次性检测或设置多个标志位。</p><p>badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。</p><p>在发生可恢复错误后，failbit被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。</p><p>如果到达文件结束位置，eofbit和failbit都会被置位。</p><p>goodbit的值为0，表示流未发生错误。如果badbit、failbit和eofbit任一个被置位，则检测流状态的条件会失败。</p><p>操作good在所有错误位均未置位的情况下返回true，而bad、fail和eof则在对应错误位被置位时返回true。此外，在badbit被置位时，fail也会返回true。这意味着，使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于！fail（）。而eof和bad操作只能表示特定的错误。</p><p><strong>管理条件状态</strong></p><p>流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。clear成员是一个重载的成员（参见6.4节，第206页）：它有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数。clear不接受参数的版本清除（复位）所有错误标志位。执行clear（）后，调用good会返回true。我们可以这样使用这些成员：</p><p><img src="/../images/C-C-Primer-Chapter-8/1726121320970.png"></p><p>带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。例如，下面的代码将failbit和badbit复位，但保持eofbit不变：</p><p><img src="/../images/C-C-Primer-Chapter-8/1726121388256.png"></p><h3 id="8-1-3-管理输出缓冲"><a href="#8-1-3-管理输出缓冲" class="headerlink" title="8.1.3 管理输出缓冲"></a>8.1.3 管理输出缓冲</h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。</p><p>导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：</p><ul><li>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。</li><li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li><li>我们可以使用操纵符如endl（参见1.2节，第6页）来显式刷新缓冲区。</li><li>在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</li><li>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。</li></ul><p><strong>刷新输出缓冲区</strong></p><p>我们已经使用过操纵符endl，它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符：flush和ends。flush刷新缓冲区，但不输出任何额外的字符；ends向缓冲区插入一个空字符，然后刷新缓冲区</p><p><img src="/../images/C-C-Primer-Chapter-8/1726121607348.png"></p><p><strong>unitbuf操纵符</strong></p><p>如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制</p><p><img src="/../images/C-C-Primer-Chapter-8/1726121637902.png"></p><blockquote><p>警告：如果程序崩溃，输出缓冲区不会被刷新</p></blockquote><p><strong>关联输入和输出流</strong></p><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起。</p><blockquote><p>交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。</p></blockquote><p>tie有两个重载的版本（参见6.4节，第206页）：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即，x.tie（&amp;o）将流x关联到输出流o。</p><p>我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream：</p><p><img src="/../images/C-C-Primer-Chapter-8/1726122679237.png"></p><p>每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。</p><h2 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h2><p>除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。在表8.3中列出了这些操作，我们可以对fstream、ifstream和ofstream对象调用这些操作，但不能对其他IO类型调用这些操作。</p><p><img src="/../images/C-C-Primer-Chapter-8/1726122800709.png"></p><h3 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h3><p>当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。</p><p>创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则open会自动被调用。</p><p><strong>用fstream代替iostream&amp;</strong></p><p>如果有一个函数接受一个ostream&amp;参数，我们在调用这个函数时，可以传递给它一个ofstream对象，对istream&amp;和ifstream也是类似的。</p><p><strong>成员函数open和close</strong></p><p>如果调用open失败，failbit会被置位（参见8.1.2节，第280页）。因为调用open可能失败，进行open是否成功的检测通常是一个好习惯。</p><p><img src="/../images/C-C-Primer-Chapter-8/1726123055436.png"></p><p><img src="/../images/C-C-Primer-Chapter-8/1726123059038.png"></p><p>对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。</p><p><strong>自动构造和析构</strong></p><p><img src="/../images/C-C-Primer-Chapter-8/1726123162740.png"></p><p>当一个fstream对象离开其作用域时，与之关联的文件会自动关闭。在下一步循环中，input会再次被创建。</p><blockquote><p>当一个fstream对象被销毁时，close会自动被调用。</p></blockquote><h3 id="8-2-2-文件模式"><a href="#8-2-2-文件模式" class="headerlink" title="8.2.2 文件模式"></a>8.2.2 文件模式</h3><p>每个流都有一个关联的文件模式（file mode），用来指出如何使用文件。</p><p><img src="/../images/C-C-Primer-Chapter-8/1726123208713.png"></p><p>指定文件模式有如下限制：</p><ul><li>只可以对ofstream或fstream对象设定out模式。</li><li>只可以对ifstream或fstream对象设定in模式。</li><li>只有当out也被设定时才可设定trunc模式。</li><li>只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式被打开。</li><li>默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作（参见17.5.3节，第676页，将介绍对同一个文件既进行输入又进行输出的方法）。</li><li>ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。</li></ul><p>每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。</p><p><strong>以out模式打开文件会丢弃已有数据</strong></p><p><img src="/../images/C-C-Primer-Chapter-8/1726123354564.png"></p><blockquote><p>保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式。</p></blockquote><p><strong>每次调用open时都会确定文件模式</strong></p><p>对于一个给定流，每当打开文件时，都可以改变其文件模式。</p><h2 id="8-3-string流"><a href="#8-3-string流" class="headerlink" title="8.3 string流"></a>8.3 string流</h2><p>istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream既可从string读数据也可向string写数据。</p><p>除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p><p><img src="/../images/C-C-Primer-Chapter-8/1726123827260.png"></p><h3 id="8-3-1-使用istringstream"><a href="#8-3-1-使用istringstream" class="headerlink" title="8.3.1 使用istringstream"></a>8.3.1 使用istringstream</h3><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。</p><p><img src="/../images/C-C-Primer-Chapter-8/1726124057228.png"></p><h3 id="8-3-2-使用ostringstream"><a href="#8-3-2-使用ostringstream" class="headerlink" title="8.3.2 使用ostringstream"></a>8.3.2 使用ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p><p><img src="/../images/C-C-Primer-Chapter-8/image-20240922130926153.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 7</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-7/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-7/</url>
    
    <content type="html"><![CDATA[<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><span id="more"></span><p>类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程（以及设计）技术。</p><p>类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p><p>类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。</p><h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><h3 id="7-1-1-设计Sales-data类"><a href="#7-1-1-设计Sales-data类" class="headerlink" title="7.1.1 设计Sales_data类"></a>7.1.1 设计Sales_data类</h3><p>由于14.1节（第490页）将要解释的原因，执行加法和IO的函数不作为Sales_data的成员，相反的，我们将其定义成普通函数；执行复合赋值运算的函数是成员函数。</p><h3 id="7-1-2-定义改进的Sales-data类"><a href="#7-1-2-定义改进的Sales-data类" class="headerlink" title="7.1.2 定义改进的Sales_data类"></a>7.1.2 定义改进的Sales_data类</h3><p><strong>引入this</strong></p><p>this是一个常量指针，指向“这个”对象。</p><p><strong>引入const成员函数</strong></p><p>把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。</p><blockquote><p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p></blockquote><p><strong>类作用域和成员函数</strong></p><p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p><p><strong>在类的外部定义成员函数</strong></p><p><strong>定义一个返回this对象的函数</strong></p><p>内置的赋值运算符把它的左侧运算对象当成<strong>左值</strong>返回（参见4.4节，第129页），因此为了与它保持一致，combine函数（重载赋值运算符）必须返回引用类型（参见6.3.2节，第202页）。因为此时的左侧运算对象是一个Sales_data的对象，所以返回类型应该是Sales_data&amp;。</p><h3 id="7-1-3-定义类相关的非成员函数"><a href="#7-1-3-定义类相关的非成员函数" class="headerlink" title="7.1.3 定义类相关的非成员函数"></a>7.1.3 定义类相关的非成员函数</h3><p>我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来（参见6.1.2节，第168页）。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。</p><blockquote><p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</p></blockquote><p><strong>定义read和print函数</strong></p><p><img src="/../images/C-C-Primer-Chapter-7/1726041043380.png"></p><p>第一点，read和print分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能被拷贝的类型，因此我们只能通过引用来传递它们（参见6.2.2节，第188页）。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。</p><p>第二点，print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。</p><p><strong>定义add函数</strong></p><p><img src="/../images/C-C-Primer-Chapter-7/1726041120522.png"></p><h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数（constructor）。</p><p>不同于其他成员函数，构造函数不能被声明成const的（参见7.1.2节，第231页）。</p><p><strong>合成的默认构造函数</strong></p><p>类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数（default constructor）。默认构造函数无须任何实参。</p><p>如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：</p><p>如果存在类内的初始值（参见2.6.1节，第64页），用它来初始化成员。</p><p>否则，默认初始化（参见2.2.1节，第40页）该成员。</p><p><strong>某些类不能依赖于合成的默认构造函数</strong></p><blockquote><p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</p></blockquote><blockquote><p>如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。</p></blockquote><p>如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。</p><p><strong>&#x3D; default的含义</strong></p><p>在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上&#x3D; default来要求编译器生成构造函数。其中，&#x3D; default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果&#x3D; default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。</p><p><strong>构造函数初始值列表</strong></p><blockquote><p>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p></blockquote><h3 id="7-1-5-拷贝、赋值和析构"><a href="#7-1-5-拷贝、赋值和析构" class="headerlink" title="7.1.5 拷贝、赋值和析构"></a>7.1.5 拷贝、赋值和析构</h3><h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h2><p>在C++语言中，我们使用访问说明符（access specifiers）加强类的封装性</p><p>定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。</p><p>定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。</p><h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可</p><p><img src="/../images/C-C-Primer-Chapter-7/1726041734487.png"></p><p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。</p><blockquote><p>一般来说，最好在类定义开始或结束前的位置集中声明友元。</p></blockquote><p><strong>关键概念：封装的益处</strong></p><p>封装有两个重要的优点：</p><p>确保用户代码不会无意间破坏封装对象的状态。</p><p>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</p><p><strong>友元的声明</strong></p><p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p><p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。</p><h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><h3 id="7-3-1-类成员再探"><a href="#7-3-1-类成员再探" class="headerlink" title="7.3.1 类成员再探"></a>7.3.1 类成员再探</h3><p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。用来定义类型的成员必须先定义后使用。</p><p><img src="/../images/C-C-Primer-Chapter-7/1726041953519.png"></p><p><strong>令成员作为内联函数</strong></p><p>我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，<strong>最好</strong>只在类外部定义的地方说明inline，这样可以使类更容易理解。</p><blockquote><p>inline成员函数也应该与相应的类定义在同一个头文件中。</p></blockquote><p><strong>重载成员函数</strong></p><p><strong>可变数据成员</strong></p><p>有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。</p><p>一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。</p><p><strong>类数据成员的初始值</strong></p><p>类内初始值必须使用&#x3D;的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。</p><blockquote><p>当我们提供一个类内初始值时，必须以符号&#x3D;或者花括号表示。</p></blockquote><h3 id="7-3-2-返回-this的成员函数"><a href="#7-3-2-返回-this的成员函数" class="headerlink" title="7.3.2 返回*this的成员函数"></a>7.3.2 返回*this的成员函数</h3><p><strong>从const成员函数返回＊this</strong></p><blockquote><p>一个const成员函数如果以引用的形式返回＊this，那么它的返回类型将是常量引用。</p></blockquote><p><strong>基于const的重载</strong></p><p>通过区分成员函数是否是const的，我们可以对其进行重载</p><p><img src="/../images/C-C-Primer-Chapter-7/1726042483856.png"></p><p><strong>建议：对于公共代码使用私有功能函数</strong></p><h3 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a>7.3.3 类类型</h3><p>每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。</p><p><strong>类的声明</strong></p><p>我们也能仅仅声明类而暂时不定义它</p><p>这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。</p><p>不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。</p><p>一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针</p><h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h3><p>类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。</p><p><strong>类之间的友元关系</strong></p><p>友元关系不存在传递性。</p><p><strong>令成员函数作为友元</strong></p><p>除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类</p><p><img src="/../images/C-C-Primer-Chapter-7/1726042842056.png"></p><p>首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。</p><p>接下来定义Screen，包括对于clear的友元声明。</p><p>最后定义clear，此时它才可以使用Screen的成员。</p><p><strong>函数重载和友元</strong></p><p>尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明</p><p><strong>友元声明和作用域</strong></p><p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中（参见7.2.1节，第241页）。</p><p>甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的</p><p><img src="/../images/C-C-Primer-Chapter-7/1726043654206.png"></p><p>友元声明的作用是影响访问权限，它本身并非普通意义上的声明。</p><h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><p><strong>作用域和定义在类外部的成员</strong></p><p>一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。</p><p>函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。</p><p><img src="/../images/C-C-Primer-Chapter-7/1726044971921.png"></p><h3 id="7-4-1-名字查找与类的作用域"><a href="#7-4-1-名字查找与类的作用域" class="headerlink" title="7.4.1 名字查找与类的作用域"></a>7.4.1 名字查找与类的作用域</h3><blockquote><p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p></blockquote><p><strong>用于类成员声明的名字查找</strong></p><p>这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。</p><p><strong>类型名要特殊处理</strong></p><p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字</p><p><img src="/../images/C-C-Primer-Chapter-7/1726045253509.png"></p><blockquote><p>类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。</p></blockquote><p><strong>成员定义中的普通块作用域的名字查找</strong></p><p>成员函数中使用的名字按照如下方式解析：</p><p>首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。</p><p>如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。</p><p>如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。</p><p><strong>类作用域之后，在外围的作用域中查</strong></p><blockquote><p>尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符访问它。</p></blockquote><h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><h3 id="7-5-1-构造函数初始值列表"><a href="#7-5-1-构造函数初始值列表" class="headerlink" title="7.5.1 构造函数初始值列表"></a>7.5.1 构造函数初始值列表</h3><p>随着构造函数体一开始执行，初始化就完成了。</p><p><strong>建议：使用构造函数初始值</strong></p><p>在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。</p><p><strong>成员初始化的顺序</strong></p><p>构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。</p><p>成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p><blockquote><p>最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。</p></blockquote><p><strong>默认实参和构造函数</strong></p><h3 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a>7.5.2 委托构造函数</h3><p>C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。</p><p>当这些受委托的构造函数执行完后，接着执行istream&amp;构造函数体的内容。</p><h3 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3 默认构造函数的作用"></a>7.5.3 默认构造函数的作用</h3><p>默认初始化在以下情况下发生：</p><p>当我们在块作用域内不使用任何初始值定义一个非静态变量（参见2.2.1节，第39页）或者数组时（参见3.5.1节，第101页）。</p><p>当一个类本身含有类类型的成员且使用合成的默认构造函数时（参见7.1.4节，第235页）。</p><p>当类类型的成员没有在构造函数初始值列表中显式地初始化时（参见7.1.4节，第237页）。</p><p>值初始化在以下情况下发生：</p><p>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时（参见3.5.1节，第101页）。</p><p>当我们不使用初始值定义一个局部静态变量时（参见6.1.1节，第185页）。</p><p>当我们通过书写形如T（ ）的表达式显式地请求值初始化时，其中T是类型名（vector的一个构造函数只接受一个实参用于说明vector大小（参见3.3.1节，第88页），它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。</p><h3 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a>7.5.4 隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数（converting constructor）。</p><blockquote><p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p></blockquote><p><strong>只允许一步类类型转换</strong></p><p>编译器只会自动地执行一步类型转换</p><p><strong>抑制构造函数定义的隐式转换</strong></p><p>关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复</p><p><strong>explicit构造函数只能用于直接初始化</strong></p><p>发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用&#x3D;）（参见3.2.1节，第76页）。此时，我们只能使用直接初始化而不能使用explicit构造函数</p><p><img src="/../images/C-C-Primer-Chapter-7/1726047200089.png"></p><p><strong>为转换显式地使用构造函数</strong></p><p><img src="/../images/C-C-Primer-Chapter-7/1726047246654.png"></p><h3 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a>7.5.5 聚合类</h3><p>聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：</p><p>所有成员都是public的。</p><p>没有定义任何构造函数。</p><p>没有类内初始值（参见2.6.1节，第64页）。</p><p>没有基类，也没有virtual函数</p><p>我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员</p><p><img src="/../images/C-C-Primer-Chapter-7/1726047334451.png"></p><p>初始值的顺序必须与声明的顺序一致，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化（参见3.5.1节，第101页）。</p><h3 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a>7.5.6 字面值常量类</h3><p>数据成员都是字面值类型的聚合类（参见7.5.5节，第266页）是字面值常量类。</p><p>如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：</p><p>数据成员都必须是字面值类型。</p><p>类必须至少含有一个constexpr构造函数。</p><p>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式（参见2.4.4节，第58页）；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。</p><p>类必须使用析构函数的默认定义，该成员负责销毁类的对象（参见7.1.5节，第239页）。</p><p><strong>constexpr构造函数</strong></p><p>尽管构造函数不能是const的（参见7.1.4节，第235页），但是字面值常量类的构造函数可以是constexpr（参见6.5.2节，第213页）函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。</p><p>constexpr构造函数可以声明成&#x3D; default（参见7.1.4节，第237页）的形式（或者是删除函数的形式，我们将在13.1.6节（第449页）介绍相关知识）。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句（参见6.5.2节，第214页））。综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数了</p><p><img src="/../images/C-C-Primer-Chapter-7/1726047654646.png"></p><p>constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型</p><p><img src="/../images/C-C-Primer-Chapter-7/1726047729145.png"></p><h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><p><strong>声明静态成员</strong></p><p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。</p><p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</p><p>静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。</p><p><strong>使用类的静态成员</strong></p><p>使用作用域运算符直接访问静态成员。</p><p><strong>定义静态成员</strong></p><p>当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句</p><p>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。</p><blockquote><p>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。</p></blockquote><p><strong>静态成员的类内初始化</strong></p><p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr（参见7.5.6节，第267页）。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。</p><blockquote><p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p></blockquote><p><strong>静态成员能用于某些场景，而普通成员不能</strong></p><p>静态数据成员可以是不完全类型（参见7.3.3节，第249页）。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用</p><p><img src="/../images/C-C-Primer-Chapter-7/1726054107164.png"></p><p>静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参</p><p><img src="/../images/C-C-Primer-Chapter-7/image-20240922130807902.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 6</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-6/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-6/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><span id="more"></span><h3 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h3><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。</p><p>执行函数的第一步是（隐式地）定义并初始化它的形参。因此，当调用fact函数时，首先创建一个名为val的int变量，然后将它初始化为调用时所用的实参5。</p><p>当遇到一条return语句时函数结束执行过程。和函数调用一样，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。</p><p><strong>形参和实参</strong></p><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是<strong>并没有规定实参的求值顺序</strong>（参见4.1.3节，第123页）。编译器能以任意可行的顺序对实参求值。</p><h3 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h3><p>在C++语言中，名字有作用域（参见2.2.4节，第43页），对象有生命周期（lifetime）。理解这两个概念非常重要。</p><p>名字的作用域是程序文本的一部分，名字在其中可见。</p><p>对象的生命周期是程序执行过程中该对象存在的一段时间。</p><p>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。</p><p><strong>自动对象</strong></p><p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。</p><p><strong>局部静态对象</strong></p><p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。<strong>局部静态对象（local static object）</strong>在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p><h3 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a>6.1.2 函数声明</h3><p>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型（function prototype）。</p><p><strong>在头文件中进行函数声明</strong></p><p>我们建议变量在头文件（参见2.6.3节，第68页）中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。</p><blockquote><p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p></blockquote><h3 id="6-1-3-分离式编译"><a href="#6-1-3-分离式编译" class="headerlink" title="6.1.3 分离式编译"></a>6.1.3 分离式编译</h3><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。</p><p><strong>编译和链接多个源文件</strong></p><p>假设fact函数的定义位于一个名为fact.cc的文件中，它的声明位于名为Chapter6.h的头文件中。显然与其他所有用到fact函数的文件一样，fact.cc应该包含Chapter6.h头文件。另外，我们在名为factMain.cc的文件中创建main函数，main函数将调用fact函数。要生成可执行文件（executable file），必须告诉编译器我们用到的代码在哪里。</p><h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><p>每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。</p><blockquote><p>形参初始化的机理与变量初始化一样。</p></blockquote><h3 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h3><blockquote><p>在C++语言中，建议使用引用类型的形参替代指针。</p></blockquote><h3 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h3><p><strong>使用引用避免拷贝</strong></p><p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p><p><strong>使用引用形参返回额外信息</strong></p><h3 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h3><p><strong>尽量使用常量引用</strong></p><p>把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。就像刚刚看到的，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</p><p>当一个a函数的形参是const，a函数要将这个参数作为实参传递给另外一个b函数，最理想的方法是b函数的参数应该也是const，如果无法满足，正确的做法应该是在a函数内部定义一个局部对象，拷贝一份这个形参，然后将局部对象作为参数传递给b函数。</p><h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h3><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组（参见3.5.1节，第102页）以及使用数组时（通常）会将其转换成指针（参见3.5.3节，第105页）。</p><p><img src="/../images/C-C-Primer-Chapter-6/1725946405478.png"></p><p>尽管表现形式不同，但上面的三个函数是等价的：每个函数的唯一形参都是const int＊类型的。当编译器处理对print函数的调用时，只检查传入的参数是否是const int＊类型</p><p>管理指针形参有三种常用的技术：</p><p><strong>使用标记指定数组长度</strong></p><p>管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串（参见3.5.4节，第109页）。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符停止</p><p><img src="/../images/C-C-Primer-Chapter-6/1725946548477.png"></p><p><strong>使用标准库规范</strong></p><p>管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库技术的启发，关于其细节将在第II部分详细介绍。使用该方法，我们可以按照如下形式输出元素内容</p><p><img src="/../images/C-C-Primer-Chapter-6/1725946542490.png"></p><p><strong>显式传递一个表示数组大小的形参</strong></p><p>第三种管理数组实参的方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。使用该方法，可以将print函数重写成如下形式</p><p><img src="/../images/C-C-Primer-Chapter-6/1725946585366.png"></p><p><strong>数组形参和const</strong></p><p>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针（参见2.4.2节，第56页）。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针</p><p><strong>数组引用形参</strong></p><p>C++语言允许将变量定义成数组的引用（参见3.5.1节，第101页），基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上</p><p><img src="/../images/C-C-Primer-Chapter-6/1725946674459.png"></p><p>因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组</p><p>16.1.1节（第578页）将要介绍我们应该如何编写这个函数，使其可以给引用类型的形参传递任意大小的数组</p><p><strong>传递多维数组</strong></p><p>当将多维数组传递给函数时，真正传递的是指向数组首元素的指针（参见3.6节，第115页）。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略</p><p><img src="/../images/C-C-Primer-Chapter-6/1725946770314.png"></p><p><img src="/../images/C-C-Primer-Chapter-6/1725946799107.png"></p><h3 id="6-2-5-main：处理命令行选项"><a href="#6-2-5-main：处理命令行选项" class="headerlink" title="6.2.5 main：处理命令行选项"></a>6.2.5 main：处理命令行选项</h3><p><img src="/../images/C-C-Primer-Chapter-6/1725946835300.png"></p><p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。</p><p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0</p><blockquote><p>当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。</p></blockquote><h3 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节（第618页）介绍。</p><p>C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。本节将简要介绍省略符形参，不过需要注意的是，这种功能一般只用于与C函数交互的接口程序。</p><p><strong>initializer_list形参</strong></p><p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组（参见3.5节，第101页）。initializer_list类型定义在同名的头文件中，它提供的操作如表6.1所示。</p><p><img src="/../images/C-C-Primer-Chapter-6/1725947030833.png"></p><p>initializer_list对象中的<strong>元素永远是常量值</strong>，我们无法改变initializer_list对象中元素的值。</p><p>如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内</p><p><strong>省略符形参</strong></p><p>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。</p><blockquote><p>省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p></blockquote><p>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种</p><p><img src="/../images/C-C-Primer-Chapter-6/1725947187334.png"></p><h2 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h2><h3 id="6-3-1-无返回值函数"><a href="#6-3-1-无返回值函数" class="headerlink" title="6.3.1 无返回值函数"></a>6.3.1 无返回值函数</h3><h3 id="6-3-2-有返回值函数"><a href="#6-3-2-有返回值函数" class="headerlink" title="6.3.2 有返回值函数"></a>6.3.2 有返回值函数</h3><blockquote><p>在含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的。很多编译器都无法发现此类错误。运行时的行为是未定义的。</p></blockquote><p><strong>值是如何被返回的</strong></p><p>返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p><p><strong>不要返回局部对象的引用或指针</strong></p><p><strong>返回类类型的函数和调用运算符</strong></p><p><strong>引用返回左值</strong></p><p><strong>列表初始化返回值</strong></p><p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化（参见3.3.1节，第88页）；否则，返回的值由函数的返回类型决定。</p><p><strong>主函数main的返回值</strong></p><p>为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量（参见2.3.2节，第49页），我们可以使用这两个变量分别表示成功与失败</p><p><img src="/../images/C-C-Primer-Chapter-6/1725947537988.png"></p><p><strong>递归</strong></p><p>如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数（recursive function）。</p><h3 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a>6.3.3 返回数组指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用（参见3.5.1节，第102页）。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名（参见2.5.1节，第60页）</p><p><img src="/../images/C-C-Primer-Chapter-6/1725947623474.png"></p><p><strong>声明一个返回数组指针的函数</strong></p><p><img src="/../images/C-C-Primer-Chapter-6/1725947705178.png"></p><p><strong>使用尾置返回类型</strong></p><p>在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。</p><p>尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto</p><p><img src="/../images/C-C-Primer-Chapter-6/1725947829947.png"></p><p><strong>使用decltype</strong></p><p>如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。</p><p><img src="/../images/C-C-Primer-Chapter-6/1725947866943.png"></p><p>arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd的类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。<strong>有一个地方需要注意：</strong>decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个＊符号。</p><h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。</p><p><strong>定义重载函数</strong></p><p>对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。</p><p>不允许两个函数除了返回类型外其他所有的要素都相同。</p><p><strong>重载和const形参</strong></p><p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p><p>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的</p><p>当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。</p><p><strong>const_cast和重载</strong></p><p>const_cast在重载函数的情景中最有用</p><p><img src="/../images/C-C-Primer-Chapter-6/1725948182712.png"></p><p>这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用。因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点</p><p><img src="/../images/C-C-Primer-Chapter-6/1725948295464.png"></p><p>在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&amp;，这显然是安全的。</p><p><strong>调用重载的函数</strong></p><p>当调用重载函数时有三种可能的结果：</p><p>1.编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。</p><p>2.找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配（no match）的错误信息。</p><p>3.有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用（ambiguous call）。</p><h3 id="6-4-1-重载与作用域"><a href="#6-4-1-重载与作用域" class="headerlink" title="6.4.1 重载与作用域"></a>6.4.1 重载与作用域</h3><p>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名</p><h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h3><p>我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><p><strong>使用默认实参调用函数</strong></p><p>尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p><p><strong>默认实参声明</strong></p><p>在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p><blockquote><p>通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p></blockquote><p><strong>默认实参初始值</strong></p><p>局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参</p><h3 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a>6.5.2 内联函数和constexpr函数</h3><p><strong>内联函数可避免函数调用的开销</strong></p><p>将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。</p><blockquote><p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p></blockquote><p><strong>constexpr函数</strong></p><p>constexpr函数（constexpr function）是指能用于常量表达式（参见2.4.4节，第58页）的函数。</p><p>定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型（参见2.4.4节，第59页），而且函数体中必须有且只有一条return语句</p><p><img src="/../images/C-C-Primer-Chapter-6/1725949081206.png"></p><p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名（参见2.5.1节，第60页）以及using声明。</p><blockquote><p>constexpr函数不一定返回常量表达式。</p></blockquote><p><strong>把内联函数和constexpr函数放在头文件内</strong></p><p>和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。</p><h3 id="6-5-3-调试帮助"><a href="#6-5-3-调试帮助" class="headerlink" title="6.5.3 调试帮助"></a>6.5.3 调试帮助</h3><p>C++程序员有时会用到一种类似于头文件保护（参见2.6.3节，第67页）的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。</p><p><strong>assert预处理宏</strong></p><p>assert是一种预处理宏（preprocessor marco）。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：</p><p><img src="/../images/C-C-Primer-Chapter-6/image-20240922130516672.png"></p><p>首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。</p><p><strong>NDEBUG预处理变量</strong></p><p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。</p><p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：</p><p><img src="/../images/C-C-Primer-Chapter-6/1725949430286.png"></p><p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。</p><p>assert应该仅用于验证那些确实不可能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。</p><p>除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定义了NDEBUG，这些代码将被忽略掉：</p><p><img src="/../images/C-C-Primer-Chapter-6/1725949488042.png"></p><p>我们使用变量__func__输出当前调试的函数的名字。编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。</p><p>除了C++编译器定义的__func__外，预处理器还定义了另外4个对于程序调试很有用的名字：</p><p>__FILE__存放文件名的字符串字面值。</p><p>__LINE__存放当前行号的整型字面值。</p><p>__TIME__存放文件编译时间的字符串字面值。</p><p>__DATE__存放文件编译日期的字符串字面值。</p><h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h2><p><strong>确定候选函数和可行函数</strong></p><p>函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。</p><p>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数（viable function）。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p><p>在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。和一般的函数调用类似，实参与形参匹配的含义可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。</p><p><strong>寻找最佳匹配（如果有的话）</strong></p><p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。</p><blockquote><p>调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。</p></blockquote><h3 id="6-6-1-实参类型转换"><a href="#6-6-1-实参类型转换" class="headerlink" title="6.6.1 实参类型转换"></a>6.6.1 实参类型转换</h3><p>有时间再看。</p><h2 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p><p>要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可</p><p><img src="/../images/C-C-Primer-Chapter-6/1725950202450.png"></p><p><strong>使用函数指针</strong></p><p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</p><p><img src="/../images/C-C-Primer-Chapter-6/1725950254391.png"></p><p>我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针</p><p><strong>重载函数的指针</strong></p><p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配</p><p><strong>函数指针形参</strong></p><p>虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用</p><p><img src="/../images/C-C-Primer-Chapter-6/1725950359746.png"></p><p>直接使用函数指针类型显得冗长而烦琐。类型别名（参见2.5.1节，第60页）和decltype（参见2.5.3节，第62页）能让我们简化使用了函数指针的代码</p><p><img src="/../images/C-C-Primer-Chapter-6/1725950417865.png"></p><p><strong>返回指向函数的指针</strong></p><p>虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。</p><p>要想声明一个返回函数指针的函数，最简单的办法是使用类型别名</p><p><img src="/../images/C-C-Primer-Chapter-6/1725950505765.png"></p><p>和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针</p><p><img src="/../images/C-C-Primer-Chapter-6/1725950529974.png"></p><p><img src="/../images/C-C-Primer-Chapter-6/1725950564265.png"></p><p><img src="/../images/C-C-Primer-Chapter-6/1725950558981.png"></p><p><strong>将auto和decltype用于函数指针类型</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 5</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-5/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-5/</url>
    
    <content type="html"><![CDATA[<h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><span id="more"></span><h2 id="5-1-简单语句"><a href="#5-1-简单语句" class="headerlink" title="5.1 简单语句"></a>5.1 简单语句</h2><h2 id="5-2-语句作用域"><a href="#5-2-语句作用域" class="headerlink" title="5.2 语句作用域"></a>5.2 语句作用域</h2><h2 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3 条件语句"></a>5.3 条件语句</h2><h3 id="5-3-1-if语句"><a href="#5-3-1-if语句" class="headerlink" title="5.3.1 if语句"></a>5.3.1 if语句</h3><h3 id="5-3-2-switch语句"><a href="#5-3-2-switch语句" class="headerlink" title="5.3.2 switch语句"></a>5.3.2 switch语句</h3><p>switch语句（switch statement）提供了一条便利的途径使得我们能够在若干固定选项中做出选择。</p><p><img src="/../images/C-C-Primer-Chapter-5/1725942532319.png"></p><p>case关键字和它对应的值一起被称为case标签（case label）。case标签必须是整型常量表达式。</p><p><img src="/../images/C-C-Primer-Chapter-5/1725942502014.png"></p><p>即使不准备在default标签下做任何工作，定义一个default标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做。</p><p><strong>switch内部的变量定义</strong></p><p>switch的执行流程有可能会跨过某些case标签。如果程序跳转到了某个特定的case，则switch结构中该case标签之前的部分会被忽略掉。这种忽略掉一部分代码的行为引出了一个有趣的问题：如果被略过的代码中含有变量的定义该怎么办？</p><p>答案是：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。</p><p><img src="/../images/C-C-Primer-Chapter-5/1725942726914.png"></p><p>如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之外。</p><p><img src="/../images/C-C-Primer-Chapter-5/1725942745906.png"></p><h2 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h2><h3 id="5-4-1-while语句"><a href="#5-4-1-while语句" class="headerlink" title="5.4.1 while语句"></a>5.4.1 while语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725942801324.png"></p><blockquote><p>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程。</p></blockquote><h3 id="5-4-2-for语句"><a href="#5-4-2-for语句" class="headerlink" title="5.4.2 for语句"></a>5.4.2 for语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725942926719.png"></p><p>init-statement必须是以下三种形式中的一种：声明语句、表达式语句或者空语句</p><p>init-statement负责初始化一个值，这个值将随着循环的进行而改变。condition作为循环控制的条件，只要condition为真，就执行一次statement。如果condition第一次的求值结果就是false，则statement一次也不会执行。expression负责修改init-statement初始化的变量，这个变量正好就是condition检查的对象，修改发生在每次循环迭代之后。</p><h3 id="5-4-3-范围for语句"><a href="#5-4-3-范围for语句" class="headerlink" title="5.4.3 范围for语句"></a>5.4.3 范围for语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725943065748.png"></p><p>expression表示的必须是一个序列，比如用花括号括起来的初始值列表（参见3.3.1节，第88页）、数组（参见3.5节，第101页）或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员（参见3.4节，第95页）。</p><p>在范围for语句中，预存了end（）的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了（参见3.4.1节，第98页）。</p><h3 id="5-4-4-do-while语句"><a href="#5-4-4-do-while语句" class="headerlink" title="5.4.4 do while语句"></a>5.4.4 do while语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725943185144.png"></p><h2 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h2><p>跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break、continue、goto和return。</p><h3 id="5-5-1-break语句"><a href="#5-5-1-break语句" class="headerlink" title="5.5.1 break语句"></a>5.5.1 break语句</h3><h3 id="5-5-2-continue语句"><a href="#5-5-2-continue语句" class="headerlink" title="5.5.2 continue语句"></a>5.5.2 continue语句</h3><h3 id="5-5-3-goto语句"><a href="#5-5-3-goto语句" class="headerlink" title="5.5.3 goto语句"></a>5.5.3 goto语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725943324855.png"></p><p>其中，label是用于标识一条语句的标示符。带标签语句（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p><p><img src="/../images/C-C-Primer-Chapter-5/1725943337648.png"></p><blockquote><p>不要在程序中使用goto语句，因为它使得程序既难理解又难修改。</p></blockquote><h2 id="5-2-try语句块和异常处理"><a href="#5-2-try语句块和异常处理" class="headerlink" title="5.2 try语句块和异常处理"></a>5.2 try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。</p><p>在C++语言中，异常处理包括：</p><p><strong>throw表达式（throw expression）</strong>，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise）了异常。</p><p><strong>try语句块（try block）</strong>，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句（catch clause）结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码（exception handler）。</p><p><strong>一套异常类（exception class）</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</p><h3 id="5-6-1-throw表达式"><a href="#5-6-1-throw表达式" class="headerlink" title="5.6.1 throw表达式"></a>5.6.1 throw表达式</h3><p>throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。</p><p><img src="/../images/C-C-Primer-Chapter-5/1725943584527.png"></p><p>在这段代码中，如果ISBN不一样就抛出一个异常，该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。</p><p>类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。关于标准库异常类型更多的知识将在5.6.3节（第176页）介绍。我们必须初始化runtime_error的对象，方式是给它提供一个string对象或者一个C风格的字符串（参见3.5.4节，第109页），这个字符串中有一些关于异常的辅助信息。</p><h3 id="5-6-2-try语句块"><a href="#5-6-2-try语句块" class="headerlink" title="5.6.2 try语句块"></a>5.6.2 try语句块</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725943641521.png"></p><p>try语句块的一开始是关键字try，随后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列。</p><p>跟在try块之后的是一个或多个catch子句。catch子句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明（称作异常声明，exception declaration）以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。</p><p><img src="/../images/C-C-Primer-Chapter-5/1725943730068.png"></p><p>每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串（即const char＊）。其中，runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。</p><p>在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。</p><p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p><p>对于那些没有任何try语句块定义的异常，也按照类似的方式处理：毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。</p><p><strong>编写异常安全的代码非常困难</strong></p><p>异常中断了程序的正常流程。异常发生时，调用者请求的一部分计算可能已经完成了，另一部分则尚未完成。通常情况下，略过部分程序意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。</p><p>那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全（exception safe）的代码。然而经验表明，编写异常安全的代码非常困难，这部分知识也（远远）超出了本书的范围。对于一些程序来说，当异常发生时只是简单地终止程序。此时，我们不怎么需要担心异常安全的问题。但是对于那些确实要处理异常并继续执行的程序，就要加倍注意了。我们必须时刻清楚异常何时发生，异常发生后程序应如何确保对象有效、资源无泄漏、程序处于合理状态，等等。</p><h3 id="5-6-3-标准异常"><a href="#5-6-3-标准异常" class="headerlink" title="5.6.3 标准异常"></a>5.6.3 标准异常</h3><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中</p><p>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。</p><p>stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。</p><p><img src="/../images/C-C-Primer-Chapter-5/1725944160121.png"></p><p>new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节（第407页）详细介绍。</p><p>type_info头文件定义了bad_cast异常类型，这种类型将在19.2节（第731页）详细介绍。</p><p>我们只能以默认初始化（参见2.2.1节，第40页）的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。</p><p>其他异常类型的行为则恰好相反：应该使用string对象或者C风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。</p><p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串（参见3.5.4节，第109页）的const char＊。该字符串的目的是提供关于异常的一些文本信息。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 4</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-4/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-4/</url>
    
    <content type="html"><![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><span id="more"></span><h2 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h2><h3 id="4-1-1-基本概念"><a href="#4-1-1-基本概念" class="headerlink" title="4.1.1 基本概念"></a>4.1.1 基本概念</h3><p><strong>左值和右值</strong></p><p>在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。可以做一个简单的归纳：<strong>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。</strong></p><h3 id="4-1-2-优先级与结合律"><a href="#4-1-2-优先级与结合律" class="headerlink" title="4.1.2 优先级与结合律"></a>4.1.2 优先级与结合律</h3><h3 id="4-1-3-求值顺序"><a href="#4-1-3-求值顺序" class="headerlink" title="4.1.3 求值顺序"></a>4.1.3 求值顺序</h3><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。对于如下的表达式</p><p><img src="/../images/C-C-Primer-Chapter-4/1725501309710.png"></p><p>我们知道f1和f2一定会在执行乘法之前被调用，因为毕竟相乘的是这两个函数的返回值。但是我们无法知道到底f1在f2之前调用还是f2在f1之前调用。</p><p>有4种运算符<strong>明确规定了运算对象的求值顺序</strong>：</p><p>1.逻辑与（&amp;&amp;）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。</p><p>2.逻辑或（||）运算符（参见4.3节，第126页）、</p><p>3.条件（？：）运算符（参见4.7节，第134页）</p><p>4.逗号（，）运算符（参见4.10节，第140页）。</p><h2 id="4-2-算术运算符"><a href="#4-2-算术运算符" class="headerlink" title="4.2 算术运算符"></a>4.2 算术运算符</h2><p>C++11新标准则规定商一律向0取整（即直接切除小数部分）。</p><h2 id="4-3-逻辑和关系运算符"><a href="#4-3-逻辑和关系运算符" class="headerlink" title="4.3　逻辑和关系运算符"></a>4.3　逻辑和关系运算符</h2><h2 id="4-4-赋值运算符"><a href="#4-4-赋值运算符" class="headerlink" title="4.4　赋值运算符"></a>4.4　赋值运算符</h2><p>赋值运算返回的是其左侧的运算对象</p><p><strong>赋值运算满足右结合律</strong></p><h2 id="4-5-递增和递减运算符"><a href="#4-5-递增和递减运算符" class="headerlink" title="4.5 递增和递减运算符"></a>4.5 递增和递减运算符</h2><p>递增和递减运算符有两种形式：前置版本和后置版本。到目前为止，本书使用的都是前置版本，这种形式的运算符首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。后置版本也会将运算对象加1（或减1），但是求值结果是运算对象改变之前那个值的副本</p><p>这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。</p><blockquote><p>建议：除非必须，否则不用递增递减运算符的后置版本</p></blockquote><p><strong>运算对象可按任意顺序求值</strong></p><p>大多数运算符都没有规定运算对象的求值顺序（参见4.1.3节，第123页），这在一般情况下不会有什么影响。然而，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。</p><h2 id="4-6-成员访问运算符"><a href="#4-6-成员访问运算符" class="headerlink" title="4.6 成员访问运算符"></a>4.6 成员访问运算符</h2><h2 id="4-7-条件运算符"><a href="#4-7-条件运算符" class="headerlink" title="4.7 条件运算符"></a>4.7 条件运算符</h2><p><img src="/../images/C-C-Primer-Chapter-4/1725504101689.png"></p><p>其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。条件运算符的执行过程是：首先求cond的值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值。</p><p>当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。</p><h2 id="4-8-位运算符、"><a href="#4-8-位运算符、" class="headerlink" title="4.8 位运算符、"></a>4.8 位运算符、</h2><p>位运算符作用于整数类型的运算对象或者bitset类型</p><p><img src="/../images/C-C-Primer-Chapter-4/1725504481938.png"></p><p>关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。</p><p>如果运算对象是“小整型”，则它的值会被自动提升（参见4.11.1节，第142页）成较大的整数类型。</p><p><strong>移位运算符</strong></p><p>左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。</p><h2 id="4-9-sizeof运算符"><a href="#4-9-sizeof运算符" class="headerlink" title="4.9 sizeof运算符"></a>4.9 sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型（参见3.5.2节，第103页）的<strong>常量表达式</strong>（参见2.4.4节，第58页）。</p><p>sizeof并不实际计算其运算对象的值。因为sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针（参见2.3.2节，第47页）也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。</p><p>sizeof运算符的结果部分地依赖于其作用的类型：</p><p>· 对char或者类型为char的表达式执行sizeof运算，结果得1。</p><p>· 对引用类型执行sizeof运算得到被引用对象所占空间的大小。</p><p>· 对指针执行sizeof运算得到指针本身所占空间的大小。</p><p>· 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。</p><p>· 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。</p><p>· 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</p><h2 id="4-10-逗号运算符"><a href="#4-10-逗号运算符" class="headerlink" title="4.10 逗号运算符"></a>4.10 逗号运算符</h2><p>逗号运算符（comma operator）含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了运算对象求值的顺序。</p><p>对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。</p><h2 id="4-11-类型转换"><a href="#4-11-类型转换" class="headerlink" title="4.11 类型转换"></a>4.11 类型转换</h2><p>算术类型之间的隐式转换被设计得尽可能避免损失精度。</p><p><strong>何时发生隐式类型转换</strong></p><p>在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。</p><p>在条件中，非布尔值转换成布尔类型</p><p>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。</p><p>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。</p><h3 id="4-11-1-算术转换"><a href="#4-11-1-算术转换" class="headerlink" title="4.11.1 算术转换"></a>4.11.1 算术转换</h3><p><strong>整型提升</strong></p><p>整型提升（integral promotion）负责把小整数类型转换成较大的整数类型。对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都能存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。就如我们所熟知的，布尔值false提升成0、true提升成1。</p><p>较大的char类型（wchar_t、char16_t、char32_t）提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。</p><p><strong>无符号类型的运算对象</strong></p><p>如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。</p><p>像往常一样，首先执行整型提升。如果结果的类型匹配，无须进行进一步的转换。</p><p>如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。</p><p>如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned int和int，则int类型的运算对象转换成unsigned int类型。需要注意的是，如果int型的值恰好为负值，其结果将以2.1.2节（第32页）介绍的方法转换，并带来该节描述的所有副作用。</p><p>剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。</p><p>如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。</p><p>如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是long和unsigned int，并且int和long的大小相同，则long类型的运算对象转换成unsigned int类型；如果long类型占用的空间比int更多，则unsigned int类型的运算对象转换成long类型。</p><h3 id="4-11-2-其他隐式类型转换"><a href="#4-11-2-其他隐式类型转换" class="headerlink" title="4.11.2　其他隐式类型转换"></a>4.11.2　其他隐式类型转换</h3><p><strong>数组转换成指针</strong></p><p>在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针</p><p>当数组被用作decltype关键字的参数，或者作为取地址符（&amp;）、sizeof及typeid（第19.2.2节，732页将介绍）等运算符的运算对象时，上述转换不会发生。</p><h3 id="4-11-3-显式转换"><a href="#4-11-3-显式转换" class="headerlink" title="4.11.3 显式转换"></a>4.11.3 显式转换</h3><p><strong>命名的强制类型转换</strong></p><p><img src="/../images/C-C-Primer-Chapter-4/1725505896584.png"></p><p>ype是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。</p><p><strong>static_cast</strong></p><p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。</p><p>用处：</p><p>1.当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。</p><p>2.static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void＊指针（参见2.3.2节，第50页）中的值</p><p><strong>const_cast</strong></p><p><img src="/../images/C-C-Primer-Chapter-4/1725506017345.png"></p><p>用处：</p><p>const_cast常常用于有函数重载的上下文中，关于函数重载将在6.4节（第208页）进行详细介绍。</p><p><strong>reinterpret_cast</strong></p><p>reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。</p><p><img src="/../images/C-C-Primer-Chapter-4/1725506142397.png"></p><h2 id="4-12-运算符优先级表"><a href="#4-12-运算符优先级表" class="headerlink" title="4.12 运算符优先级表"></a>4.12 运算符优先级表</h2><p><img src="/../images/C-C-Primer-Chapter-4/1725506197060.png"></p><p><img src="/../images/C-C-Primer-Chapter-4/1725506211875.png"></p><p><img src="/../images/C-C-Primer-Chapter-4/image-20240922122249300.png"></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 3</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-3/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-3/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串、向量和数组"><a href="#字符串、向量和数组" class="headerlink" title="字符串、向量和数组"></a>字符串、向量和数组</h1><span id="more"></span><h2 id="3-1-命名空间的using声明"><a href="#3-1-命名空间的using声明" class="headerlink" title="3.1 命名空间的using声明"></a>3.1 命名空间的using声明</h2><h2 id="3-2-标准库类型string"><a href="#3-2-标准库类型string" class="headerlink" title="3.2 标准库类型string"></a>3.2 标准库类型string</h2><h3 id="3-2-1-定义和初始化string对象"><a href="#3-2-1-定义和初始化string对象" class="headerlink" title="3.2.1 定义和初始化string对象"></a>3.2.1 定义和初始化string对象</h3><p><img src="/../images/C-C-Primer-Chapter-3/1720604744927.png"></p><p><strong>直接初始化和拷贝初始化</strong></p><h3 id="3-2-2-string对象上的操作"><a href="#3-2-2-string对象上的操作" class="headerlink" title="3.2.2 string对象上的操作"></a>3.2.2 string对象上的操作</h3><p><img src="/../images/C-C-Primer-Chapter-3/1720604877481.png"></p><p><strong>读写string对象</strong></p><p>从流读：在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。</p><p>getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。</p><p>getline也会返回它的流参数。因此既然输入运算符能作为判断的条件（参见1.4.3节，第13页），我们也能用getline的结果作为条件。</p><p><strong>string：：size_type类型</strong></p><p>它是一个无符号类型的值（参见2.1.1节，第30页）而且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string：：size_type类型的。</p><p><strong>比较string对象</strong></p><p>1.如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。</p><p>2.如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。</p><h3 id="3-2-3-处理string对象中的字符"><a href="#3-2-3-处理string对象中的字符" class="headerlink" title="3.2.3　处理string对象中的字符"></a>3.2.3　处理string对象中的字符</h3><p><img src="/../images/C-C-Primer-Chapter-3/1725353182437.png"></p><h2 id="3-3-标准库类型vector"><a href="#3-3-标准库类型vector" class="headerlink" title="3.3 标准库类型vector"></a>3.3 标准库类型vector</h2><h3 id="3-3-1-定义和初始化vector对象"><a href="#3-3-1-定义和初始化vector对象" class="headerlink" title="3.3.1　定义和初始化vector对象"></a>3.3.1　定义和初始化vector对象</h3><p><img src="/../images/C-C-Primer-Chapter-3/1725416150548.png"></p><h3 id="3-3-2-向vector对象中添加元素"><a href="#3-3-2-向vector对象中添加元素" class="headerlink" title="3.3.2　向vector对象中添加元素"></a>3.3.2　向vector对象中添加元素</h3><blockquote><p>范围for语句体内不应改变其所遍历序列的大小。</p></blockquote><h3 id="3-3-3-其他vector操作"><a href="#3-3-3-其他vector操作" class="headerlink" title="3.3.3　其他vector操作"></a>3.3.3　其他vector操作</h3><p><img src="/../images/C-C-Primer-Chapter-3/1725416497671.png"></p><h2 id="3-4-迭代器介绍"><a href="#3-4-迭代器介绍" class="headerlink" title="3.4 迭代器介绍"></a>3.4 迭代器介绍</h2><h3 id="3-4-1-使用迭代器"><a href="#3-4-1-使用迭代器" class="headerlink" title="3.4.1 使用迭代器"></a>3.4.1 使用迭代器</h3><p><strong>begin和end运算符</strong></p><p>begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator</p><p>为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend</p><p>已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效</p><p><img src="/../images/C-C-Primer-Chapter-3/1726125798970.png"></p><h3 id="3-4-2-迭代器运算"><a href="#3-4-2-迭代器运算" class="headerlink" title="3.4.2 迭代器运算"></a>3.4.2 迭代器运算</h3><p><img src="/../images/C-C-Primer-Chapter-3/1725417124401.png"></p><p>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可正可负，所以difference_type是带符号类型的。</p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。</p><blockquote><p>如果不清楚元素的确切个数，使用vector</p></blockquote><h3 id="3-5-1-定义和初始化内置数组"><a href="#3-5-1-定义和初始化内置数组" class="headerlink" title="3.5.1　定义和初始化内置数组"></a>3.5.1　定义和初始化内置数组</h3><p>数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式（参见2.4.4节，第58页）</p><p><strong>字符数组的特殊性</strong></p><p>我们可以用字符串字面值（参见2.1.3节，第36页）对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去</p><p><strong>不允许拷贝和赋值</strong></p><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</p><p><strong>理解复杂的数组声明</strong></p><p><img src="/../images/C-C-Primer-Chapter-3/1725418297827.png"></p><p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</p><h3 id="3-5-2-访问数组元素"><a href="#3-5-2-访问数组元素" class="headerlink" title="3.5.2 访问数组元素"></a>3.5.2 访问数组元素</h3><p>数组的元素也能使用范围for语句或下标运算符来访问。</p><p>在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。</p><h3 id="3-5-3-指针和数组"><a href="#3-5-3-指针和数组" class="headerlink" title="3.5.3 指针和数组"></a>3.5.3 指针和数组</h3><p>使用数组的时候编译器一般会把它转换成指针。</p><p>在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针</p><p><img src="/../images/C-C-Primer-Chapter-3/1725418997234.png"></p><p>当使用数组作为一个auto（参见2.5.2节，第61页）变量的初始值时，推断得到的类型是指针而非数组</p><p>当使用decltype关键字（参见2.5.3节，第62页）时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组</p><p><strong>标准库函数begin和end</strong></p><p>C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员（参见3.4.1节，第95页）功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数</p><p><img src="/../images/C-C-Primer-Chapter-3/1725419199440.png"></p><p>两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型</p><p>内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。</p><h3 id="3-5-4-C风格字符串"><a href="#3-5-4-C风格字符串" class="headerlink" title="3.5.4 C风格字符串"></a>3.5.4 C风格字符串</h3><p>C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\0’）。一般利用指针来操作这些字符串。</p><p><img src="/../images/C-C-Primer-Chapter-3/1725419546643.png"></p><h3 id="3-5-5-与旧代码的接口"><a href="#3-5-5-与旧代码的接口" class="headerlink" title="3.5.5 与旧代码的接口"></a>3.5.5 与旧代码的接口</h3><p>如果执行完c_str（）函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p><p><strong>使用数组初始化vector对象</strong></p><p>允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了：</p><p><img src="/../images/C-C-Primer-Chapter-3/1725420062654.png"></p><h2 id="3-6-多维数组"><a href="#3-6-多维数组" class="headerlink" title="3.6 多维数组"></a>3.6 多维数组</h2><p>要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 2</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-2/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-2/</url>
    
    <content type="html"><![CDATA[<h1 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h1><span id="more"></span><h2 id="2-1-基本内置类型"><a href="#2-1-基本内置类型" class="headerlink" title="2.1 基本内置类型"></a>2.1 基本内置类型</h2><p>C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。</p><h3 id="2-1-1-算术类型"><a href="#2-1-1-算术类型" class="headerlink" title="2.1.1 算术类型"></a>2.1.1 算术类型</h3><p>包括整型（integral type，包括字符和布尔类型在内）和浮点型。</p><h3 id="2-1-3-字面值常量"><a href="#2-1-3-字面值常量" class="headerlink" title="2.1.3 字面值常量"></a>2.1.3 字面值常量</h3><p>一个形如42的值被称作字面值常量（literal），这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。</p><p><strong>1.整型和浮点型字面值</strong></p><ul><li>整型字面值具体的数据类型由它的值和符号决定。</li><li>默认的，浮点型字面值是一个double。</li></ul><p><strong>2.字符和字符串字面值</strong></p><ul><li>由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。</li><li>字符串字面值的类型实际上是由常量字符构成的数组（array）</li><li>编译器在每个字符串的结尾处添加一个空字符（′\0′），因此，字符串字面值的实际长度要比它的内容多1。</li></ul><p><strong>3.布尔字面值和指针字面值</strong></p><ul><li>true和false是布尔类型的字面值</li><li>nullptr是指针字面值</li></ul><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p>变量提供一个具名的、可供程序操作的存储空间。</p><h3 id="2-2-1-变量定义"><a href="#2-2-1-变量定义" class="headerlink" title="2.2.1 变量定义"></a>2.2.1 变量定义</h3><p><strong>1.列表初始化</strong></p><ul><li>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错</li></ul><p><strong>2.默认初始化</strong></p><ul><li>默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。</li><li>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。</li><li>定义于任何函数体之外的变量被初始化为0。</li><li>定义在函数体内部的内置类型变量将不被初始化（uninitialized）。</li></ul><h3 id="2-2-2-变量声明和定义的关系"><a href="#2-2-2-变量声明和定义的关系" class="headerlink" title="2.2.2 变量声明和定义的关系"></a>2.2.2 变量声明和定义的关系</h3><p><strong>声明（declaration）</strong>使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而<strong>定义（definition）</strong>负责创建与名字关联的实体。</p><ul><li>如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量</li><li>如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，<strong>变量的定义</strong>必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。</li></ul><blockquote><p>静态类型</p><p>C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。程序越复杂，静态类型检查越有助于发现问题。</p></blockquote><h3 id="2-2-3-标识符"><a href="#2-2-3-标识符" class="headerlink" title="2.2.3 标识符"></a>2.2.3 标识符</h3><h3 id="2-2-4-名字的作用域"><a href="#2-2-4-名字的作用域" class="headerlink" title="2.2.4 名字的作用域"></a>2.2.4 名字的作用域</h3><h2 id="2-3-复合类型"><a href="#2-3-复合类型" class="headerlink" title="2.3 复合类型"></a>2.3 复合类型</h2><p>复合类型（compound type）是指基于其他类型定义的类型。</p><h3 id="2-3-1-引用"><a href="#2-3-1-引用" class="headerlink" title="2.3.1 引用"></a>2.3.1 引用</h3><blockquote><p>引用即别名</p></blockquote><blockquote><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。</p></blockquote><h3 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2 指针"></a>2.3.2 指针</h3><h4 id="指针引用对比"><a href="#指针引用对比" class="headerlink" title="指针引用对比"></a>指针引用对比</h4><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。</li><li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li></ul><h4 id="void-指针"><a href="#void-指针" class="headerlink" title="void*指针"></a>void*指针</h4><ul><li>void＊是一种特殊的指针类型，可用于存放任意对象的地址。</li><li>利用void＊指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void＊指针。不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span> pi = &amp;i;<br><span class="hljs-type">int</span> *&amp;r = pi;<br></code></pre></td></tr></table></figure><p>从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号＊说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。</p><h2 id="2-4-const限定符"><a href="#2-4-const限定符" class="headerlink" title="2.4 const限定符"></a>2.4 const限定符</h2><p>因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。</p><h4 id="默认状态下，const对象仅在文件内有效"><a href="#默认状态下，const对象仅在文件内有效" class="headerlink" title="默认状态下，const对象仅在文件内有效"></a><strong>默认状态下，const对象仅在文件内有效</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize = <span class="hljs-number">512</span>;<br></code></pre></td></tr></table></figure><p>编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。</p><p>为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义（参见2.2.2节，第41页）。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。</p><p>某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// file1.cc</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize = <span class="hljs-built_in">fcn</span>();<br><span class="hljs-comment">// file1.h</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> buffSize;<br></code></pre></td></tr></table></figure><p>如上述程序所示，file_1.cc定义并初始化了bufSize。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用。file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。</p><h3 id="2-4-1-const的引用"><a href="#2-4-1-const的引用" class="headerlink" title="2.4.1 const的引用"></a>2.4.1 const的引用</h3><p>对常量的引用，简称为常量引用，对常量的引用必须添加const限定符。</p><h4 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h4><p>在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成（参见2.1.2节，第32页）引用的类型即可。尤其是，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</p><h3 id="2-4-2-指针和const"><a href="#2-4-2-指针和const" class="headerlink" title="2.4.2 指针和const"></a>2.4.2 指针和const</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 指向常量的指针</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = &amp;i;<br><br><span class="hljs-comment">// 常量指针</span><br><span class="hljs-type">int</span> *<span class="hljs-type">const</span> q = &amp;i;<br></code></pre></td></tr></table></figure><h3 id="2-4-3-顶层const"><a href="#2-4-3-顶层const" class="headerlink" title="2.4.3 顶层const"></a>2.4.3 顶层const</h3><p>顶层const（top-level const）表示指针本身是个常量</p><p>底层const（low-level const）表示指针所指的对象是一个常量。</p><h3 id="2-4-4-constexpr和常量表达式"><a href="#2-4-4-constexpr和常量表达式" class="headerlink" title="2.4.4 constexpr和常量表达式"></a>2.4.4 constexpr和常量表达式</h3><p>常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p>显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。</p><p><strong>constexpr变量</strong></p><p>C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化</p><p><strong>字面值类型</strong></p><p>常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。</p><p>算术类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。</p><p>尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p><p>函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。</p><p><strong>指针和constexpr</strong></p><p>必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *q = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>p是底层const，q是顶层const</p><h2 id="2-5-处理类型"><a href="#2-5-处理类型" class="headerlink" title="2.5 处理类型"></a>2.5 处理类型</h2><h3 id="2-5-1-类型别名"><a href="#2-5-1-类型别名" class="headerlink" title="2.5.1 类型别名"></a>2.5.1 类型别名</h3><p>typedef和using</p><p>不要把原始类型替换进去，这种理解是错误的。</p><h3 id="2-5-2-auto类型说明符"><a href="#2-5-2-auto类型说明符" class="headerlink" title="2.5.2 auto类型说明符"></a>2.5.2 auto类型说明符</h3><p>1.使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型</p><p>2.auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时。如果希望推导出顶层const，需要显示声明。</p><h3 id="2-5-3-decltype类型指示符"><a href="#2-5-3-decltype类型指示符" class="headerlink" title="2.5.3 decltype类型指示符"></a>2.5.3 decltype类型指示符</h3><p>它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。</p><p>decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。</p><blockquote><p>decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[C++]C++Primer Chapter 1</title>
    <link href="/2024/09/22/C-C-Primer-Chapter-1/"/>
    <url>/2024/09/22/C-C-Primer-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><span id="more"></span><h2 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h2><ul><li>每个C++程序都包含一个或多个函数（function），其中一个必须命名为main。操作系统通过调用main来运行C++程序。</li><li>函数 &lt; 返回类型 + 函数名 + 形参列表 + 函数体&gt;</li><li>内置类型（built-in type），语言自身定义的类型。</li></ul><h2 id="1-2-输入输出"><a href="#1-2-输入输出" class="headerlink" title="1.2 输入输出"></a>1.2 输入输出</h2><ul><li>c++由标准库来提供IO机制。</li><li>标准库定义了4个IO对象 <code>&lt;cin cout cerr clog&gt;</code></li></ul><h2 id="1-4-控制流"><a href="#1-4-控制流" class="headerlink" title="1.4 控制流"></a>1.4 控制流</h2><ul><li>当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时（例如读入的值不是一个整数），istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[MIT 6.S081]Lab1 Xv6 and Unix utilities</title>
    <link href="/2024/09/21/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/"/>
    <url>/2024/09/21/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/</url>
    
    <content type="html"><![CDATA[<h2 id="1-通过gdb调试"><a href="#1-通过gdb调试" class="headerlink" title="1 通过gdb调试"></a>1 通过gdb调试</h2><p>参考链接</p><ul><li><a href="https://web.archive.org/web/20190308091152/http://zoo.cs.yale.edu:80/classes/cs422/2011/lec/l2-hw">Homework: running and debugging xv6 (archive.org)</a></li><li><a href="https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html">MIT 6.S081 xv6调试不完全指北 - KatyuMarisa - 博客园 (cnblogs.com)</a></li><li><a href="https://gabriellesc.github.io/teaching/resources/GDB-cheat-sheet.pdf">GDB-cheat-sheet.pdf (gabriellesc.github.io)</a></li></ul><span id="more"></span><h2 id="2-sleep（easy）"><a href="#2-sleep（easy）" class="headerlink" title="2 sleep（easy）"></a>2 sleep（easy）</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240919005050483.png" alt="图2-1"></p><p>结果如下：</p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921092721550.png" alt="图2-2"></p><h2 id="3-pingpong-easy"><a href="#3-pingpong-easy" class="headerlink" title="3 pingpong(easy)"></a>3 pingpong(easy)</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240919005125509.png" alt="图3-1"></p><p>本题考查的是管道通信相关内容的理解。</p><blockquote><p>If no data is available, a read on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed; in the latter case, read will return 1, just as if the end of a data file had been reached.</p></blockquote><p>xv6书中指出，<code>read</code>会一直阻塞直到有数据被写入管道或者所有指向管道写端的文件描述符都被关闭。</p><p>一种简单的实现是创建两个管道，一个管道的流向为父进程到子进程，另外一个的流向为子进程到父进程。</p><p>另外一种实现只需要创建一个管道，但是由于父子进程读写的都是同一个管道，需要通过wait来同步父子进程读写的顺序，防止出现死锁的情况。代码如下，注意55行的 <code>wait((int*)0)</code>，父进程一定要等待子进程退出后，才可以从管道中读取数据，否则可能会出现父进程自写自读的情况，导致子进程阻塞在21行处。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br><br>    <span class="hljs-type">int</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// fork failed</span><br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;fork failure\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span> buf = <span class="hljs-string">&#x27;1&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) <br>    &#123;<br>        <span class="hljs-comment">// child </span><br>        pid = getpid(); <span class="hljs-comment">// acquire the pid of the child process</span><br><br>        <span class="hljs-comment">// read a byte from pipe</span><br>        <span class="hljs-keyword">if</span> (read(p[<span class="hljs-number">0</span>], &amp;buf, <span class="hljs-keyword">sizeof</span>(buf)) != <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;child process read failed\n&quot;</span>);<br>            close(p[<span class="hljs-number">0</span>]);<br>            close(p[<span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125; <br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: received ping\n&quot;</span>, pid); <br>        <span class="hljs-comment">// write a byte to pipe</span><br>        <span class="hljs-keyword">if</span> (write(p[<span class="hljs-number">1</span>], &amp;buf, <span class="hljs-keyword">sizeof</span>(buf)) != <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;child process write failed\n&quot;</span>);<br>            close(p[<span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125; <br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <br>    &#123;<br>        <span class="hljs-comment">// father</span><br>        pid = getpid(); <span class="hljs-comment">// acquire the pid of the parent process</span><br>        <span class="hljs-comment">// write a byte to pipe</span><br>        <span class="hljs-keyword">if</span> (write(p[<span class="hljs-number">1</span>], &amp;buf, <span class="hljs-keyword">sizeof</span>(buf)) != <span class="hljs-number">1</span>) <br>        &#123;<br>            close(p[<span class="hljs-number">0</span>]);<br>            close(p[<span class="hljs-number">1</span>]);<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;parent process write failed\n&quot;</span>);<br>            wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">1</span>]);<br><br>        wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// read a byte from pipe</span><br>        <span class="hljs-keyword">if</span> (read(p[<span class="hljs-number">0</span>], &amp;buf, <span class="hljs-keyword">sizeof</span>(buf)) != <span class="hljs-number">1</span>) <br>        &#123;<br>            close(p[<span class="hljs-number">0</span>]);<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;father process read failed\n&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d:received pong\n&quot;</span>, pid);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下</p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921092958561.png" alt="图3-2"></p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921152718120.png" alt="图3-3"></p><h2 id="4-primes-moderate-hard"><a href="#4-primes-moderate-hard" class="headerlink" title="4 primes (moderate)&#x2F;(hard)"></a>4 primes (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)&#x2F;(<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">hard</a>)</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240919005317618.png" alt="图4-1"></p><p>这道题目考察的是利用 <code>fork</code> 进行多进程编程。</p><p>重点是理解下面的图和伪代码。本题用到了一种编程思想（<a href="https://swtch.com/~rsc/thread/">Bell Labs and CSP Threads (swtch.com)</a>），通过未缓冲的命名的通道来同时进行通信和同步。因为管道未缓冲，所以可以通过读写阻塞来进行同步。</p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240919005607473.png" alt="图4-2"></p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240919005544805.png" alt="图4-3"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">int</span> left[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> right[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> end = <span class="hljs-number">35</span>;<br><br>    pipe(left);<br><br>    <span class="hljs-type">int</span> pid = fork();<br><br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;fork failed pid = &lt;%d&gt;\n&quot;</span>, getpid());<br>        close(left[<span class="hljs-number">0</span>]);<br>        close(left[<span class="hljs-number">1</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// child</span><br>        close(left[<span class="hljs-number">1</span>]); <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// parent</span><br>        close(left[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = start; num &lt;= end; ++num)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (write(left[<span class="hljs-number">1</span>], &amp;num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) != <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write failed pid = &lt;%d&gt;\n&quot;</span>, getpid());<br>                close(left[<span class="hljs-number">1</span>]);<br>                wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        close(left[<span class="hljs-number">1</span>]);<br>        wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>); <span class="hljs-comment">// waits for its child to exit</span><br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> num, prime, ret_r = <span class="hljs-number">0</span>, ret_w = <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>);<br>    <span class="hljs-comment">// if there is any number in the left pipe</span><br>    <span class="hljs-comment">// the first number must be a prime</span><br>    <span class="hljs-keyword">while</span> ((ret_r = read(left[<span class="hljs-number">0</span>], &amp;prime, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;primes %d\n&quot;</span>, prime);<br>        <span class="hljs-comment">// if there is still any number in the left pipe</span><br>        <span class="hljs-keyword">if</span> ((ret_r = read(left[<span class="hljs-number">0</span>], &amp;num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))<br>        &#123;<br>            pipe(right);<br>            <span class="hljs-keyword">if</span> ((pid = fork()) == <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-comment">// child</span><br>                <span class="hljs-comment">// the parent&#x27;s right is the child&#x27;s left</span><br>                <span class="hljs-comment">// note that the sequence of the next 4 lines cannot be changed </span><br>                <span class="hljs-comment">// first close the read end of the left pipe</span><br>                <span class="hljs-comment">// cuz it is the parent&#x27;s left pipe which the child doesn&#x27;t need</span><br>                close(left[<span class="hljs-number">0</span>]); <br>                <span class="hljs-comment">// then change the child&#x27;s left to its right pipe</span><br>                <span class="hljs-comment">// cuz the right pipe right now is the parent&#x27;s right pipe </span><br>                <span class="hljs-comment">// which is also the child&#x27;s left pipe</span><br>                left[<span class="hljs-number">0</span>] = right[<span class="hljs-number">0</span>];<br>                left[<span class="hljs-number">1</span>] = right[<span class="hljs-number">1</span>];<br>                <span class="hljs-comment">// close the write end of the left pipe </span><br>                close(left[<span class="hljs-number">1</span>]);<br>                <span class="hljs-comment">// continue the loop</span><br>                <span class="hljs-keyword">continue</span>;   <br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;fork failed pid = &lt;%d&gt;\n&quot;</span>, getpid());<br>                close(right[<span class="hljs-number">0</span>]);<br>                close(right[<span class="hljs-number">1</span>]);<br>                close(left[<span class="hljs-number">0</span>]);<br>                <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-comment">// parent</span><br>                close(right[<span class="hljs-number">0</span>]);<br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-keyword">if</span> (num % prime == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((ret_w = write(right[<span class="hljs-number">1</span>], &amp;num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">else</span> <br>                    &#123;<br>                        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;write failed pid = &lt;%d&gt;\n&quot;</span>, getpid());<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">while</span>((ret_r = read(left[<span class="hljs-number">0</span>], &amp;num, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>))) == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>                close(left[<span class="hljs-number">0</span>]);<br>                close(right[<span class="hljs-number">1</span>]);<br>                wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (ret_r) <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read failed pid = &lt;%d&gt;\n&quot;</span>, getpid());<br>                ret_r == <span class="hljs-number">0</span> &amp;&amp; ret_w == <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) ? <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>) : <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// only the last process in the pipeline will excute here</span><br>    close(left[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">if</span> (ret_r) <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read failed pid = &lt;%d&gt;\n&quot;</span>, getpid());<br>    ret_r == <span class="hljs-number">0</span> ? <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>) : <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921093230617.png" alt="图4-4"></p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921152817290.png" alt="图4-5"></p><h2 id="5-find-moderate"><a href="#5-find-moderate" class="headerlink" title="5 find (moderate)"></a>5 find (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240919165143206.png" alt="图5-1"></p><p>这道题目考察的是对xv6文件系统的理解，比较简单，参考 <code>user/ls.c</code> 即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *dir, <span class="hljs-type">char</span>* file)</span><br>&#123;   <br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(dir) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span> ((fd = open(dir, O_RDONLY)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, dir);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st.type != T_DIR)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: %s is not a directory\n&quot;</span>, dir);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find [directory] &lt;filename&gt;\n&quot;</span>);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <br>    <span class="hljs-built_in">strcpy</span>(buf, dir);<br>    p = buf + <span class="hljs-built_in">strlen</span>(dir);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>    &#123;<br>        <span class="hljs-comment">// skip invalid dir entry</span><br>        <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        memmove(p, de.name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(de.name, file) == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br>        <br>        <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (st.type == T_DIR) find(buf, file);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span> &amp;&amp; argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find [directory] &lt;filename&gt;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) find(<span class="hljs-string">&quot;.&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">else</span> find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921093608610.png" alt="图5-2"></p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921152930352.png" alt="图5-3"></p><h2 id="6-xargs-moderate"><a href="#6-xargs-moderate" class="headerlink" title="6 xargs (moderate)"></a>6 xargs (<a href="https://pdos.csail.mit.edu/6.828/2021/labs/guidance.html">moderate</a>)</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240920200532745.png" alt="图6-1"></p><p>这道题目的难点主要在于对c语言数组的处理。</p><p>大致思路如下：</p><p>1.首先将<code>xargs</code>的参数拷贝到数组的前段。</p><p>2.然后从标准输入读取一行的内容作为额外参数拼接到数组后面，这里我们一行的内容只作为一个参数处理。</p><p>3.<code>fork</code>一个子进程出来调用<code>exec</code>执行命令</p><p>4.父进程调用<code>wait</code>等待子进程执行完毕，之后跳转到2继续执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">char</span> *cmd[MAXARG + <span class="hljs-number">5</span>];<br>    <span class="hljs-type">int</span> args_cnter = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">// 默认使用echo命令 </span><br>        cmd[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;echo&quot;</span>;<br>        args_cnter = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (; args_cnter &lt; argc; ++args_cnter) <br>    &#123;<br>        <span class="hljs-comment">// 将参数拷贝到命令数组中</span><br>        <span class="hljs-comment">// shallow copy</span><br>        cmd[args_cnter] = argv[args_cnter];<br>    &#125;<br><br><br>    <span class="hljs-comment">// b - 每次读取的起始位置 </span><br>    <span class="hljs-comment">// e - 每次读取完成后的最后有效位的下一位 </span><br>    <span class="hljs-comment">// r - 每次读取了多少字节 </span><br>    <span class="hljs-comment">// s - 每行参数的起始 </span><br>    <span class="hljs-comment">// 每次将数据读取到buf[b, e)中 buf[0, b)为上次未处理完的内容 </span><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>, e = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, s;<br>    <span class="hljs-keyword">while</span> ((r = read(<span class="hljs-number">0</span>, buf + b, <span class="hljs-number">256</span> - b)) &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        e = b + r;<br>        s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; e; ++i)<br>        &#123;<br>            <span class="hljs-comment">// 如果遇到了换行符</span><br>            <span class="hljs-keyword">if</span> (buf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>            &#123;<br>                <span class="hljs-comment">// 将参数拷贝到数组中</span><br>                <span class="hljs-comment">// deep copy</span><br>                buf[i] = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">char</span> *p = (<span class="hljs-type">char</span>*) <span class="hljs-built_in">malloc</span>(i - s + <span class="hljs-number">1</span>);<br><br>                <span class="hljs-keyword">if</span> (!p)<br>                &#123;<br>                    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;malloc failed\n&quot;</span>);<br>                    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>                &#125;<br><br>                memmove(p, buf + s, i - s + <span class="hljs-number">1</span>);<br>                cmd[args_cnter++] = p;<br>                <span class="hljs-comment">// 更新s</span><br>                s = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">// child</span><br>                    cmd[args_cnter] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span> (exec(cmd[<span class="hljs-number">1</span>], cmd + <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;exec failed&quot;</span>);<br>                        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span>    <br>                &#123;<br>                    <span class="hljs-comment">// parent</span><br>                    wait((<span class="hljs-type">int</span>*)<span class="hljs-number">0</span>);<br>                    <span class="hljs-built_in">free</span>(cmd[--args_cnter]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 将未处理完的内容移动到数组首部</span><br>        memmove(buf, buf + s, e - s);<br>        b = e - s;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">0</span>) <br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;read failed\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921154626369.png" alt="图6-2"></p><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921154654189.png" alt="图6-3"></p><h2 id="7-测试结果"><a href="#7-测试结果" class="headerlink" title="7 测试结果"></a>7 测试结果</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921160442352.png" alt="图7-1"></p><h2 id="8-uptime（easy）"><a href="#8-uptime（easy）" class="headerlink" title="8 uptime（easy）"></a>8 uptime（easy）</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240920203828103.png" alt="图8-1"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;uptime&lt;%d&gt;\n&quot;</span>, uptime());<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-improve-find（easy）"><a href="#9-improve-find（easy）" class="headerlink" title="9 improve find（easy）"></a>9 improve find（easy）</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240920205838353.png" alt="图9-1"></p><p>这道题目直接参考<code>grep.c</code>，把其中正则表达式匹配的代码拿过来，修改<code>find</code>中判断匹配的条件即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fcntl.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">match</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *dir, <span class="hljs-type">char</span>* pattern)</span><br>&#123;   <br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(dir) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span> ((fd = open(dir, O_RDONLY)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, dir);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, dir);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (st.type != T_DIR)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: %s is not a directory\n&quot;</span>, dir);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find [directory] &lt;pattern&gt;\n&quot;</span>);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <br>    <span class="hljs-built_in">strcpy</span>(buf, dir);<br>    p = buf + <span class="hljs-built_in">strlen</span>(dir);<br>    *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br><br>    <span class="hljs-keyword">while</span> (read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))<br>    &#123;<br>        <span class="hljs-comment">// skip invalid dir entry</span><br>        <span class="hljs-keyword">if</span> (de.inum == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;.&quot;</span>) == <span class="hljs-number">0</span> || <span class="hljs-built_in">strcmp</span>(de.name, <span class="hljs-string">&quot;..&quot;</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        memmove(p, de.name, DIRSIZ);<br>        p[DIRSIZ] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// if (strcmp(de.name, file) == 0)</span><br>        <span class="hljs-comment">//     printf(&quot;%s\n&quot;, buf);</span><br><br>        <span class="hljs-keyword">if</span> (match(pattern, de.name)) <br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, buf);<br><br>        <span class="hljs-keyword">if</span> (stat(buf, &amp;st) &lt; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (st.type == T_DIR) find(buf, pattern);<br>    &#125;<br>    close(fd);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span> &amp;&amp; argc != <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: find [directory] &lt;pattern&gt;\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) find(<span class="hljs-string">&quot;.&quot;</span>, argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">else</span> find(argv[<span class="hljs-number">1</span>], argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-comment">// Regexp matcher from Kernighan &amp; Pike,</span><br><span class="hljs-comment">// The Practice of Programming, Chapter 9.</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">matchhere</span><span class="hljs-params">(<span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*)</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">matchstar</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">char</span>*, <span class="hljs-type">char</span>*)</span>;<br><br><span class="hljs-type">int</span><br><span class="hljs-title function_">match</span><span class="hljs-params">(<span class="hljs-type">char</span> *re, <span class="hljs-type">char</span> *text)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(re[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;^&#x27;</span>)<br>    <span class="hljs-keyword">return</span> matchhere(re+<span class="hljs-number">1</span>, text);<br>  <span class="hljs-keyword">do</span>&#123;  <span class="hljs-comment">// must look at empty string</span><br>    <span class="hljs-keyword">if</span>(matchhere(re, text))<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">while</span>(*text++ != <span class="hljs-string">&#x27;\0&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// matchhere: search for re at beginning of text</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">matchhere</span><span class="hljs-params">(<span class="hljs-type">char</span> *re, <span class="hljs-type">char</span> *text)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(re[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">if</span>(re[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>)<br>    <span class="hljs-keyword">return</span> matchstar(re[<span class="hljs-number">0</span>], re+<span class="hljs-number">2</span>, text);<br>  <span class="hljs-keyword">if</span>(re[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;$&#x27;</span> &amp;&amp; re[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    <span class="hljs-keyword">return</span> *text == <span class="hljs-string">&#x27;\0&#x27;</span>;<br>  <span class="hljs-keyword">if</span>(*text!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; (re[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;.&#x27;</span> || re[<span class="hljs-number">0</span>]==*text))<br>    <span class="hljs-keyword">return</span> matchhere(re+<span class="hljs-number">1</span>, text+<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// matchstar: search for c*re at beginning of text</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">matchstar</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">char</span> *re, <span class="hljs-type">char</span> *text)</span><br>&#123;<br>  <span class="hljs-keyword">do</span>&#123;  <span class="hljs-comment">// a * matches zero or more instances</span><br>    <span class="hljs-keyword">if</span>(matchhere(re, text))<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<span class="hljs-keyword">while</span>(*text!=<span class="hljs-string">&#x27;\0&#x27;</span> &amp;&amp; (*text++==c || c==<span class="hljs-string">&#x27;.&#x27;</span>));<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-improve-shell（easy-moderate）"><a href="#10-improve-shell（easy-moderate）" class="headerlink" title="10 improve shell（easy&#x2F;moderate）"></a>10 improve shell（easy&#x2F;moderate）</h2><p><img src="/../images/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/image-20240921160546811.png" alt="图10-1"></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MIT 6.1810</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[const cards = document.querySelectorAll('.index-card')if (cards.length) {  document.querySelector('.row').setAttribute('style', 'overflow: hidden;')  const coefficient = document.documentElement.clientWidth > 768 ? .5 : .3  const origin = document.documentElement.clientHeight - cards[0].getBoundingClientRect().height * coefficient  function throttle(fn, wait) {    let timer = null;    return function () {      const context = this;      const args = arguments;      if (!timer) {        timer = setTimeout(function () {          fn.apply(context, args);          timer = null;        }, wait)      }    }  }  function handle() {    cards.forEach(card => {      card.setAttribute('style', `--state: ${(card.getBoundingClientRect().top - origin) < 0 ? 1 : 0};`)    })    console.log(1)  }  document.addEventListener("scroll", throttle(handle, 100));}]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[.index-card {  transition: all 0.5s;  transform: scale(calc(1.5 - 0.5 * var(--state)));  opacity: var(--state);  margin-bottom: 2rem;}.index-img img {  margin: 20px 0;}]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[// document//   .querySelector('#web_bg')//   .setAttribute('style', `background-image: ${document.querySelector('.banner').style.background.split(' ')[0]};position: fixed;width: 100%;height: 100%;z-index: -1;background-size: cover;`);// document//   .querySelector("#banner")//   .setAttribute('style', 'background-image: url()')// document//   .querySelector("#banner .mask")//   .setAttribute('style', 'background-color:rgba(0,0,0,0)')]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[#board {  -webkit-backdrop-filter: blur(5px);  backdrop-filter: blur(5px);}]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>categories</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[]]></content>
    
  </entry>
  
  
  
</search>
