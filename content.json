{"posts":[{"title":"[MIT 6.S081]Lab1 Xv6 and Unix utilities","text":"1 通过gdb调试参考链接 Homework: running and debugging xv6 (archive.org) MIT 6.S081 xv6调试不完全指北 - KatyuMarisa - 博客园 (cnblogs.com) GDB-cheat-sheet.pdf (gabriellesc.github.io) 2 sleep（easy） 结果如下： 3 pingpong(easy) 本题考查的是管道通信相关内容的理解。 If no data is available, a read on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed; in the latter case, read will return 1, just as if the end of a data file had been reached. xv6书中指出，read会一直阻塞直到有数据被写入管道或者所有指向管道写端的文件描述符都被关闭。 一种简单的实现是创建两个管道，一个管道的流向为父进程到子进程，另外一个的流向为子进程到父进程。 另外一种实现只需要创建一个管道，但是由于父子进程读写的都是同一个管道，需要通过wait来同步父子进程读写的顺序，防止出现死锁的情况。代码如下，注意55行的 wait((int*)0)，父进程一定要等待子进程退出后，才可以从管道中读取数据，否则可能会出现父进程自写自读的情况，导致子进程阻塞在21行处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]){ int p[2]; pipe(p); int pid = fork(); if (pid &lt; 0) { // fork failed fprintf(2, &quot;fork failure\\n&quot;); exit(1); } char buf = '1'; if (pid == 0) { // child pid = getpid(); // acquire the pid of the child process // read a byte from pipe if (read(p[0], &amp;buf, sizeof(buf)) != 1) { fprintf(2, &quot;child process read failed\\n&quot;); close(p[0]); close(p[1]); exit(1); } close(p[0]); printf(&quot;%d: received ping\\n&quot;, pid); // write a byte to pipe if (write(p[1], &amp;buf, sizeof(buf)) != 1) { fprintf(2, &quot;child process write failed\\n&quot;); close(p[1]); exit(1); } close(p[1]); exit(0); } else { // father pid = getpid(); // acquire the pid of the parent process // write a byte to pipe if (write(p[1], &amp;buf, sizeof(buf)) != 1) { close(p[0]); close(p[1]); fprintf(2, &quot;parent process write failed\\n&quot;); wait((int*)0); exit(1); } close(p[1]); wait((int*)0); // read a byte from pipe if (read(p[0], &amp;buf, sizeof(buf)) != 1) { close(p[0]); fprintf(2, &quot;father process read failed\\n&quot;); exit(1); } close(p[0]); printf(&quot;%d:received pong\\n&quot;, pid); exit(0); }} 结果如下 4 primes (moderate)/(hard) 这道题目考察的是利用 fork 进行多进程编程。 重点是理解下面的图和伪代码。本题用到了一种编程思想（Bell Labs and CSP Threads (swtch.com)），通过未缓冲的命名的通道来同时进行通信和同步。因为管道未缓冲，所以可以通过读写阻塞来进行同步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]){ int left[2]; int right[2]; int start = 2; int end = 35; pipe(left); int pid = fork(); if (pid &lt; 0) { fprintf(2, &quot;fork failed pid = &lt;%d&gt;\\n&quot;, getpid()); close(left[0]); close(left[1]); exit(1); } if (pid == 0) { // child close(left[1]); } else { // parent close(left[0]); for (int num = start; num &lt;= end; ++num) { if (write(left[1], &amp;num, sizeof(int)) != sizeof(int)) { fprintf(2, &quot;write failed pid = &lt;%d&gt;\\n&quot;, getpid()); close(left[1]); wait((int*)0); exit(1); } } close(left[1]); wait((int*)0); // waits for its child to exit exit(0); } int num, prime, ret_r = 0, ret_w = sizeof(int); // if there is any number in the left pipe // the first number must be a prime while ((ret_r = read(left[0], &amp;prime, sizeof(int))) == sizeof(int)) { printf(&quot;primes %d\\n&quot;, prime); // if there is still any number in the left pipe if ((ret_r = read(left[0], &amp;num, sizeof(int))) == sizeof(int)) { pipe(right); if ((pid = fork()) == 0) { // child // the parent's right is the child's left // note that the sequence of the next 4 lines cannot be changed // first close the read end of the left pipe // cuz it is the parent's left pipe which the child doesn't need close(left[0]); // then change the child's left to its right pipe // cuz the right pipe right now is the parent's right pipe // which is also the child's left pipe left[0] = right[0]; left[1] = right[1]; // close the write end of the left pipe close(left[1]); // continue the loop continue; } else if (pid &lt; 0) { fprintf(2, &quot;fork failed pid = &lt;%d&gt;\\n&quot;, getpid()); close(right[0]); close(right[1]); close(left[0]); exit(1); } else { // parent close(right[0]); do { if (num % prime == 0) continue; else if ((ret_w = write(right[1], &amp;num, sizeof(int))) == sizeof(int)) continue; else { fprintf(2, &quot;write failed pid = &lt;%d&gt;\\n&quot;, getpid()); break; } } while((ret_r = read(left[0], &amp;num, sizeof(int))) == sizeof(int)); close(left[0]); close(right[1]); wait((int*)0); if (ret_r) fprintf(2, &quot;read failed pid = &lt;%d&gt;\\n&quot;, getpid()); ret_r == 0 &amp;&amp; ret_w == sizeof(int) ? exit(0) : exit(1); } } else break; } // only the last process in the pipeline will excute here close(left[0]); if (ret_r) fprintf(2, &quot;read failed pid = &lt;%d&gt;\\n&quot;, getpid()); ret_r == 0 ? exit(0) : exit(1);} 结果如下： 5 find (moderate) 这道题目考察的是对xv6文件系统的理解，比较简单，参考 user/ls.c 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;#include &quot;kernel/fcntl.h&quot;void find(char *dir, char* file){ char buf[512], *p; if (strlen(dir) + 1 + DIRSIZ + 1 &gt; sizeof buf) { fprintf(2, &quot;find: path too long\\n&quot;); return; } int fd; struct dirent de; struct stat st; if ((fd = open(dir, O_RDONLY)) &lt; 0) { fprintf(2, &quot;find: cannot open %s\\n&quot;, dir); return; } if (fstat(fd, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, dir); close(fd); return; } if (st.type != T_DIR) { fprintf(2, &quot;find: %s is not a directory\\n&quot;, dir); fprintf(2, &quot;Usage: find [directory] &lt;filename&gt;\\n&quot;); close(fd); return; } strcpy(buf, dir); p = buf + strlen(dir); *p++ = '/'; while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) { // skip invalid dir entry if (de.inum == 0 || strcmp(de.name, &quot;.&quot;) == 0 || strcmp(de.name, &quot;..&quot;) == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if (strcmp(de.name, file) == 0) printf(&quot;%s\\n&quot;, buf); if (stat(buf, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, buf); continue; } if (st.type == T_DIR) find(buf, file); } close(fd); return;}int main(int argc, char *argv[]){ if (argc != 2 &amp;&amp; argc != 3) { fprintf(2, &quot;Usage: find [directory] &lt;filename&gt;\\n&quot;); exit(1); } if (argc == 2) find(&quot;.&quot;, argv[1]); else find(argv[1], argv[2]); exit(0);} 结果如下： 6 xargs (moderate) 这道题目的难点主要在于对c语言数组的处理。 大致思路如下： 1.首先将xargs的参数拷贝到数组的前段。 2.然后从标准输入读取一行的内容作为额外参数拼接到数组后面，这里我们一行的内容只作为一个参数处理。 3.fork一个子进程出来调用exec执行命令 4.父进程调用wait等待子进程执行完毕，之后跳转到2继续执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &quot;kernel/param.h&quot;#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]){ char buf[256]; char *cmd[MAXARG + 5]; int args_cnter = 1; if (argc == 1) { // 默认使用echo命令 cmd[1] = &quot;echo&quot;; args_cnter = 2; } for (; args_cnter &lt; argc; ++args_cnter) { // 将参数拷贝到命令数组中 // shallow copy cmd[args_cnter] = argv[args_cnter]; } // b - 每次读取的起始位置 // e - 每次读取完成后的最后有效位的下一位 // r - 每次读取了多少字节 // s - 每行参数的起始 // 每次将数据读取到buf[b, e)中 buf[0, b)为上次未处理完的内容 int b = 0, e = 0, r = 0, s; while ((r = read(0, buf + b, 256 - b)) &gt; 0) { e = b + r; s = 0; for (int i = 0; i &lt; e; ++i) { // 如果遇到了换行符 if (buf[i] == '\\n') { // 将参数拷贝到数组中 // deep copy buf[i] = 0; char *p = (char*) malloc(i - s + 1); if (!p) { fprintf(2, &quot;malloc failed\\n&quot;); exit(1); } memmove(p, buf + s, i - s + 1); cmd[args_cnter++] = p; // 更新s s = i + 1; if (fork() == 0) { // child cmd[args_cnter] = 0; if (exec(cmd[1], cmd + 1) &lt; 0) { fprintf(2, &quot;exec failed&quot;); exit(1); } } else { // parent wait((int*)0); free(cmd[--args_cnter]); } } } // 将未处理完的内容移动到数组首部 memmove(buf, buf + s, e - s); b = e - s; } if (r &lt; 0) { fprintf(2, &quot;read failed\\n&quot;); exit(1); } exit(0);} 结果如下： 7 测试结果 8 uptime（easy） 123456789#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]){ printf(&quot;uptime&lt;%d&gt;\\n&quot;, uptime()); exit(0);} 9 improve find（easy） 这道题目直接参考grep.c，把其中正则表达式匹配的代码拿过来，修改find中判断匹配的条件即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;#include &quot;kernel/fcntl.h&quot;int match(char*, char*);void find(char *dir, char* pattern){ char buf[512], *p; if (strlen(dir) + 1 + DIRSIZ + 1 &gt; sizeof buf) { fprintf(2, &quot;find: path too long\\n&quot;); return; } int fd; struct dirent de; struct stat st; if ((fd = open(dir, O_RDONLY)) &lt; 0) { fprintf(2, &quot;find: cannot open %s\\n&quot;, dir); return; } if (fstat(fd, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, dir); close(fd); return; } if (st.type != T_DIR) { fprintf(2, &quot;find: %s is not a directory\\n&quot;, dir); fprintf(2, &quot;Usage: find [directory] &lt;pattern&gt;\\n&quot;); close(fd); return; } strcpy(buf, dir); p = buf + strlen(dir); *p++ = '/'; while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) { // skip invalid dir entry if (de.inum == 0 || strcmp(de.name, &quot;.&quot;) == 0 || strcmp(de.name, &quot;..&quot;) == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; // if (strcmp(de.name, file) == 0) // printf(&quot;%s\\n&quot;, buf); if (match(pattern, de.name)) printf(&quot;%s\\n&quot;, buf); if (stat(buf, &amp;st) &lt; 1) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, buf); continue; } if (st.type == T_DIR) find(buf, pattern); } close(fd); return;}int main(int argc, char *argv[]){ if (argc != 2 &amp;&amp; argc != 3) { fprintf(2, &quot;Usage: find [directory] &lt;pattern&gt;\\n&quot;); exit(1); } if (argc == 2) find(&quot;.&quot;, argv[1]); else find(argv[1], argv[2]); exit(0);}// Regexp matcher from Kernighan &amp; Pike,// The Practice of Programming, Chapter 9.int matchhere(char*, char*);int matchstar(int, char*, char*);intmatch(char *re, char *text){ if(re[0] == '^') return matchhere(re+1, text); do{ // must look at empty string if(matchhere(re, text)) return 1; }while(*text++ != '\\0'); return 0;}// matchhere: search for re at beginning of textint matchhere(char *re, char *text){ if(re[0] == '\\0') return 1; if(re[1] == '*') return matchstar(re[0], re+2, text); if(re[0] == '$' &amp;&amp; re[1] == '\\0') return *text == '\\0'; if(*text!='\\0' &amp;&amp; (re[0]=='.' || re[0]==*text)) return matchhere(re+1, text+1); return 0;}// matchstar: search for c*re at beginning of textint matchstar(int c, char *re, char *text){ do{ // a * matches zero or more instances if(matchhere(re, text)) return 1; }while(*text!='\\0' &amp;&amp; (*text++==c || c=='.')); return 0;} 10 improve shell（easy/moderate）","link":"/2024/09/21/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/"},{"title":"[C++]C++Primer Chapter 1","text":"开始 1.1 每个C++程序都包含一个或多个函数（function），其中一个必须命名为main。操作系统通过调用main来运行C++程序。 函数 &lt; 返回类型 + 函数名 + 形参列表 + 函数体&gt; 内置类型（built-in type），语言自身定义的类型。 1.2 输入输出 c++由标准库来提供IO机制。 标准库定义了4个IO对象 &lt;cin cout cerr clog&gt; 1.4 控制流 当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时（例如读入的值不是一个整数），istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。","link":"/2024/09/22/C-C-Primer-Chapter-1/"},{"title":"[C++]C++Primer Chapter 2","text":"变量和基本类型 2.1 基本内置类型C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。 2.1.1 算术类型包括整型（integral type，包括字符和布尔类型在内）和浮点型。 2.1.3 字面值常量一个形如42的值被称作字面值常量（literal），这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。 1.整型和浮点型字面值 整型字面值具体的数据类型由它的值和符号决定。 默认的，浮点型字面值是一个double。 2.字符和字符串字面值 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。 字符串字面值的类型实际上是由常量字符构成的数组（array） 编译器在每个字符串的结尾处添加一个空字符（′\\0′），因此，字符串字面值的实际长度要比它的内容多1。 3.布尔字面值和指针字面值 true和false是布尔类型的字面值 nullptr是指针字面值 2.2 变量变量提供一个具名的、可供程序操作的存储空间。 2.2.1 变量定义1.列表初始化 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错 2.默认初始化 默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。 定义于任何函数体之外的变量被初始化为0。 定义在函数体内部的内置类型变量将不被初始化（uninitialized）。 2.2.2 变量声明和定义的关系声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。 静态类型 C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。程序越复杂，静态类型检查越有助于发现问题。 2.2.3 标识符2.2.4 名字的作用域2.3 复合类型复合类型（compound type）是指基于其他类型定义的类型。 2.3.1 引用 引用即别名 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。 2.3.2 指针指针引用对比 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 void*指针 void＊是一种特殊的指针类型，可用于存放任意对象的地址。 利用void＊指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void＊指针。不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。 123int i = 42;int pi = &amp;i;int *&amp;r = pi; 从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号＊说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。 2.4 const限定符因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。 默认状态下，const对象仅在文件内有效1const int buffSize = 512; 编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。 为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义（参见2.2.2节，第41页）。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。 某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了 1234// file1.ccextern const int buffSize = fcn();// file1.hextern const int buffSize; 如上述程序所示，file_1.cc定义并初始化了bufSize。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用。file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。 2.4.1 const的引用对常量的引用，简称为常量引用，对常量的引用必须添加const限定符。 初始化和对const的引用在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成（参见2.1.2节，第32页）引用的类型即可。尤其是，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式 2.4.2 指针和const123456// 指向常量的指针const int i = 42;const int *p = &amp;i;// 常量指针int *const q = &amp;i; 2.4.3 顶层const顶层const（top-level const）表示指针本身是个常量 底层const（low-level const）表示指针所指的对象是一个常量。 2.4.4 constexpr和常量表达式常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。 显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。 constexpr变量 C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化 字面值类型 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。 算术类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。 指针和constexpr 必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关 12const int *p = nullptr;constexpr int *q = nullptr; p是底层const，q是顶层const 2.5 处理类型2.5.1 类型别名typedef和using 不要把原始类型替换进去，这种理解是错误的。 2.5.2 auto类型说明符1.使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型 2.auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时。如果希望推导出顶层const，需要显示声明。 2.5.3 decltype类型指示符它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。 decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。","link":"/2024/09/22/C-C-Primer-Chapter-2/"},{"title":"[C++]C++Primer Chapter 11","text":"关联容器 关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。 标准库提供8个关联容器，如表11.1所示。这8个容器间的不同体现在三个维度上：每个容器（1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头。 11.1 使用关联容器map是关键字-值对的集合。 map类型通常被称为关联数组（associative array）。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。 set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。 使用map 为了定义一个map，我们必须指定关键字和值的类型。 当从map中提取一个元素时，会得到一个pair类型的对象，我们将在11.2.3节（第379页）介绍它。简单来说，pair是一个模板类型，保存两个名为first和second的（公有）数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。 使用set find调用返回一个迭代器。如果给定关键字在set中，迭代器指向该关键字。否则，find返回尾后迭代器。 11.2 关联容器概述关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。 关联容器的迭代器都是双向的。 11.2.1 定义关联容器初始化multimap或multiset 11.2.2 关键字类型的要求对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。 有序容器的关键字类型 可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个严格弱序（strict weak ordering）。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质： 两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2绝不能“小于等于”k1。 如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。 如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价于”k2，且k2“等价于”k3，那么k1必须“等价于”k3。 如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作map的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。 在实际编程中，重要的是，如果一个类型定义了“行为正常”的&lt;运算符，则它可以用作关键字类型。 使用关键字类型的比较函数 用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。 在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。 为了使用自己定义的操作，在定义multiset时我们必须提供两个类型：关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型（参见6.7节，第221页），可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。 11.2.3 pair类型定义在头文件utility中。 一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样 pair的默认构造函数对数据成员进行值初始化（参见3.3.1节，第88页）。 与其他标准库类型不同，pair的数据成员是public的（参见7.2节，第240页）。两个成员分别命名为first和second。 11.3 关联容器操作除了表9.2（第295页）中列出的类型，关联容器还定义了表11.3中列出的类型。这些类型表示容器关键字和值的类型。 11.3.1 关联容器迭代器当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型，其first成员保存const的关键字，second成员保存值 set的迭代器是const的 虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改 遍历关联容器 当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。 关联容器和算法 我们通常不对关联容器使用泛型算法（参见第10章）。关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。 关联容器可用于只读取元素的算法。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行（快速）查找，因此对其使用泛型搜索算法几乎总是个坏主意。 关联容器定义了一个名为find的成员，它通过一个给定的关键字直接获取元素。我们可以用泛型find算法来查找一个元素，但此算法会进行顺序搜索。使用关联容器定义的专用的find成员会比调用泛型find快得多。 11.3.2 添加元素关联容器的insert成员（见表11.4，第384页）向容器中添加一个元素或一个元素范围。由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响 insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数（参见11.2.1节，第376页）——对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中。 向map添加元素 对一个map进行insert操作时，必须记住元素类型是pair。通常，对于想要插入的数据，并没有一个现成的pair对象。可以在insert的参数列表中创建一个pair 检测insert的返回值 向multiset或multimap添加元素 11.3.3 删除元素关联容器定义了三个版本的erase，如表11.5所示。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。这两个版本的erase与对应的顺序容器的操作非常相似：指定的元素被删除，函数返回void。 关联容器提供一个额外的erase操作，它接受一个key_type参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。 11.3.4 map的下标操作map和unordered_map容器提供了下标运算符和一个对应的at函数（参见9.3.2节，第311页），如表11.6所示。set类型不支持下标，因为set中没有与关键字相关联的“值”。 我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。 如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化（参见3.3.1节，第88页）。 将会执行如下操作： 在word_count中搜索关键字为Anna的元素，未找到。 将一个新的关键字-值对插入到word_count中。关键字是一个const string，保存Anna。值进行值初始化，在本例中意味着值为0。 提取出新插入的元素，并将值1赋予它。 由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作。 11.3.5 访问元素 对map使用find代替下标操作 我们只是想知道一个给定关键字是否在map中，而不想改变map。这样就不能使用下标运算符来检查一个元素是否存在，因为如果关键字不存在的话，下标运算符会插入一个新元素。在这种情况下，应该使用find 在multimap或multiset中查找元素 如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。 例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。 可以用三种不同方法来解决这个问题。最直观的方法是使用find和count： 一种不同的，面向迭代器的解决方法 我们还可以用lower_bound和upper_bound来解决此问题。这两个操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置。如果元素不在multimap中，则lower_bound和upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。因此，用相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围（参见9.2.1节，第296页），表示所有具有该关键字的元素的范围。 这两个操作返回的迭代器可能是容器的尾后迭代器。如果我们查找的元素具有容器中最大的关键字，则此关键字的upper_bound返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则lower_bound返回的也是尾后迭代器。 lower_bound返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则lower_bound会返回关键字的第一个安全插入点——不影响容器中元素顺序的插入位置。 equal_range函数 解决此问题的最后一种方法是三种方法中最直接的：不必再调用upper_bound和lower_bound，直接调用equal_range即可。此函数接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。 11.3.6 一个单词转换的map给定一个string，将它转换为另一个string。程序的输入是两个文件。第一个文件保存的是一些规则，用来转换第二个文件中的文本。每条规则由两部分组成：一个可能出现在输入文件中的单词和一个用来替换它的短语。表达的含义是，每当第一个单词出现在输入中时，我们就将它替换为对应的短语。第二个输入文件包含要转换的文本。 11.4 无序容器新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数（hash function）和关键字类型的==运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。 使用无序容器 通常可以用一个无序容器替换对应的有序容器，反之亦然。 管理桶 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。 对于相同的参数，哈希函数必须总是产生相同的结果。 当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。 无序容器提供了一组管理桶的函数，如表11.8所示。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。 无序容器对关键字类型的要求 无序容器使用关键字类型的==运算符来比较元素，它们还使用一个hash类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要在第12章介绍的智能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针类型的无序容器。 不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。我们将在16.5节（第626页）中介绍如何做到这一点。 我们不使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作（参见11.2.2节，第378页）。为了能将Sale_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数。我们从定义这些重载函数开始","link":"/2024/09/22/C-C-Primer-Chapter-11/"},{"title":"[C++]C++Primer Chapter 10","text":"泛型算法 10.1 概述大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围（参见9.2.1节，第296页）来进行操作。 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作 关键概念：算法永远不会执行容器的操作 算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。 10.2 初识泛型算法10.2.1 只读算法一些算法只会读取其输入范围内的元素，而从不改变元素。 find就是这样一种算法，我们在10.1节练习（第337页）中使用的count函数也是如此。另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。 算法和元素类型 对于只读取而不改变元素的算法，通常最好使用cbegin（）和cend（）（参见9.2.3节，第298页）。但是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用begin（）和end（）的结果作为参数。 操作两个序列的算法 另一个只读算法是equal，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器：前两个（与以往一样）表示第一个序列中的元素范围，第三个表示第二个序列的首元素。equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。 10.2.2 写容器元素的算法算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。 算法不检查写操作 函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素。函数fill_n假定写入指定个元素是安全的。 介绍back_inserter 一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。 我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。 back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中 拷贝算法 拷贝（copy）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。 copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。 多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。 replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值 此调用将序列中所有的0都替换为42。如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置 此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42。 10.2.3 重排容器元素的算法某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;运算符来实现排序的。 消除重复单词 为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作 使用unique unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。 unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。 使用容器操作删除元素 10.3 定制操作10.3.1 向算法传递函数为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个谓词（predicate）。 谓词 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate，意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。 接受一个二元谓词参数的sort版本用这个谓词代替&lt;来比较元素。我们提供给sort的谓词必须满足将在11.2.2节（第378页）中所介绍的条件。 排序算法 为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。 标准库定义了名为partition的算法，它接受一个谓词，对容器内容进行划分，使得谓词为true的值会排在容器的前半部分，而使谓词为false的值会排在后半部分。算法返回一个迭代器，指向最后一个使谓词为true的元素之后的位置。 10.3.2 lambda表达式我们可以使用标准库find_if算法来查找第一个具有特定大小的元素。类似find（参见10.1节，第336页），find_if算法接受一对迭代器，表示一个范围。但与find不同的是，find_if的第三个参数是一个谓词。find_if算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。 find_if接受一元谓词——我们传递给find_if的任何函数都必须严格接受一个参数，以便能用来自输入序列的一个元素调用它。没有任何办法能传递给它第二个参数来表示长度。为了解决此问题，需要使用另外一些语言特性。 介绍lambda 我们可以向一个算法传递任何类别的可调用对象（callable object）。对于一个对象或一个表达式，如果可以对其使用调用运算符（参见1.5.2节，第21页），则称它为可调用的。即，如果e是一个可调用的表达式，则我们可以编写代码e（args），其中args是一个逗号分隔的一个或多个参数的列表。 我们使用过的仅有的两种可调用对象是函数和函数指针（参见6.7节，第221页）。还有其他两种可调用对象：重载了函数调用运算符的类，我们将在14.8节（第506页）介绍，以及lambda表达式（lambda expression）。 一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。 capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）；return type、parameter list和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，lambda必须使用尾置返回（参见6.3.3节，第206页）来指定返回类型。我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体 如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。 向lambda传递参数 lambda不能有默认参数（参见6.5.1节，第211页）。 使用捕获列表 虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。 for_each算法 此算法接受一个可调用对象，并对输入序列中每个元素调用此对象 一个lambda可以直接使用定义在当前函数之外的名字。 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。 10.3.3 lambda捕获和返回当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。 可以这样理解，当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。 默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。 值捕获 与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝 由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对应的值。 引用捕获 引用捕获与返回引用（参见6.3.2节，第201页）有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在lambda执行的时候是存在的。lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。 我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。 建议：尽量保持lambda的变量捕获简单化 一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。 隐式捕获 可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或=。&amp;告诉编译器采用捕获引用方式，=则表示采用值捕获方式。 如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获 当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或=。此符号指定了默认捕获方式为引用或值。 当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。 可变lambda 默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。 一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型 指定lambda返回类型 函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。 当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型（参见6.3.3节，第206页） 10.3.4 参数绑定如果lambda的捕获列表为空，通常可以用函数来代替它。 但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。 标准库bind函数 我们可以解决向check_size传递一个长度参数的问题，方法是使用一个新的名为bind的标准库函数，它定义在头文件functional中。可以将bind函数看作一个通用的函数适配器（参见9.6节，第329页），它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。 newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。 arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，依此类推。 此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&amp;。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。 使用placeholders名字 名字_n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间（参见3.1节，第74页）中。为了使用这些名字，两个命名空间都要写上。 bind的参数 我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。 例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用 生成一个新的可调用对象，它有两个参数，分别用占位符_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑定到给定的值a、b和c上。传递给g的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。 用bind重排参数顺序 绑定引用参数 默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。 如果我们希望传递给bind一个对象而又不拷贝它，就必须使用标准库ref函数 函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。 10.4 再探迭代器除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。 插入迭代器（insert iterator）：这些迭代器被绑定到一个容器上，可用来向容器插入元素。 流迭代器（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。 反向迭代器（reverse iterator）：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。 移动迭代器（move iterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它们。我们将在13.6.2节（第480页）介绍移动迭代器。 10.4.1 插入迭代器插入器是一种迭代器适配器（参见9.6节，第329页），它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。 插入器有三种类型，差异在于元素插入的位置： back_inserter（参见10.2.2节，第341页）创建一个使用push_back的迭代器 front_inserter创建一个使用push_front的迭代器。 inserter创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。 只有在容器支持push_front的情况下，我们才可以使用front_inserter。类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter。 当调用inserter（c，iter）时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如果it是由inserter生成的迭代器，则下面这样的赋值语句 其效果与下面代码一样 front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。 10.4.2 iostream迭代器istream_iterator（参见表10.3）读取输入流，ostream_iterator（参见表10.4节，第361页）向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。 istream_iterator操作 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。 一个istream_iterator使用&gt;&gt;来读取流。因此，istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。 下面是一个用istream_iterator从标准输入读取数据，存入一个vector的例子： 此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空的istream_iterator，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。 我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方。 这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。 使用算法操作流迭代器 由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。我们在10.5.1节（第365页）会看到如何分辨哪些算法可以用于流迭代器。 istream_iterator允许使用懒惰求值 当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。 ostream_iterator操作 我们可以对任何具有输出运算符（&lt;&lt;运算符）的类型定义ostream_iterator。当创建一个ostream_iterator时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。 out_iter++实际不对迭代器做任何操作，但还是推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。 可以通过调用copy来打印vec中的元素，这比编写循环更为简单 使用流迭代器处理类类型 10.4.3 反向迭代器反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（–it）会移动到下一个元素。 除了forward_list之外，其他容器都支持反向迭代器。 我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。 虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做使我们可以用算法透明地向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减序： 反向迭代器需要递减运算符 流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。 反向迭代器和其他迭代器间的关系 我们使用的是反向迭代器，会反向处理string。因此，上述输出语句从crbegin开始反向打印line中内容。而我们希望按正常顺序打印从rcomma开始到line末尾间的字符。但是，我们不能直接使用rcomma。因为它是一个反向迭代器，意味着它会反向朝着string的开始位置移动。需要做的是，将rcomma转换回一个普通迭代器，能在line中正向移动。我们通过调用reverse_iterator的base成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器： 10.5 泛型算法结构任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别（iterator category），如表10.5所示。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。 第二种算法分类的方式（如我们在本章开始所做的）是按照是否读、写或是重排序列中的元素来分类。附录A按这种分类方法列出了所有算法。 10.5.1 5类迭代器迭代器类别 1.输入迭代器（input iterator）：可以读取序列中的元素。 一个输入迭代器必须支持: 用于比较两个迭代器的相等和不相等运算符（==、！=） 用于推进迭代器的前置和后置递增运算（++） 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧 箭头运算符（-&gt;），等价于（*it）.member，即，解引用迭代器，并提取对象的成员 输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法find和accumulate要求输入迭代器；而istream_iterator是一种输入迭代器。 2.输出迭代器（output iterator）：可以看作输入迭代器功能上的补集——只写而不读元素。 输出迭代器必须支持 用于推进迭代器的前置和后置递增运算（++） 解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素） 我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器。 3.前向迭代器（forward iterator）：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。 4.双向迭代器（bidirectional iterator）：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（–）。算法reverse要求双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。 5.随机访问迭代器（random-access iterator）：提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持表3.7（第99页）中的操作： 用于比较两个迭代器相对位置的关系运算符（&lt;、&lt;=、&gt;和&gt;=） 迭代器和一个整数值的加减运算（+、+=、-和-=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置 用于两个迭代器上的减法运算符（-），得到两个迭代器的距离 下标运算符（iter[n]），与＊（iter[n]）等价 算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。 10.5.2 算法形参模式大多数算法具有如下4种形式之一： 接受单个目标迭代器的算法 dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。 接受第二个输入序列的算法 接受单独的beg2或是接受beg2和end2的算法用这些迭代器表示第二个输入范围。这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。 10.5.3 算法命名规范算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个操作代替默认的&lt;或==运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。 一些算法使用重载形式传递一个谓词 接受谓词参数来代替&lt;或==运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替&lt;或==： _if版本的算法 接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词（参见10.3.1节，第344页）代替元素值。接受谓词参数的算法都有附加的_if前缀： 区分拷贝元素的版本和不拷贝的版本 默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个_copy（参见10.2.2节，第341页）： 一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词： 10.6 特定容器算法与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法，如表10.6所示。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。 splice成员 此算法是链表数据结构所特有的，因此不需要通用版本。 链表特有的操作会改变容器 链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，remove的链表版本会删除指定的元素。unique的链表版本会删除第二个和后继的重复元素。 类似的，merge和splice会销毁其参数。例如，通用版本的merge将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。在merge之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。","link":"/2024/09/22/C-C-Primer-Chapter-10/"},{"title":"[C++]C++Primer Chapter 12","text":"动态内存 静态内存用来保存局部static对象（参见6.6.1节，第185页）、类static数据成员（参见7.6节，第268页）以及定义在任何函数之外的变量。 栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。 对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。 除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间（free store）或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象——即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制。 12.1 动态内存与智能指针为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。 12.1.1 shared_ptr类 make_shared函数 最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。 类似顺序容器的emplace成员（参见9.3.1节，第308页），make_shared用其参数来构造给定类型的对象。 如果我们不传递任何参数，对象就会进行值初始化（参见3.3.1节，第88页）。 shared_ptr的拷贝和赋值 当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。 我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数（reference count）。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数（参见6.2.1节，第188页）以及作为函数的返回值（参见6.3.2节，第201页）时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域（参见6.1.1节，第184页））时，计数器就会递减。 一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。 shared_ptr自动销毁所管理的对象，shared_ptr还会自动释放相关联的内存 由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。share_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某些元素。在这种情况下，你应该确保用erase删除那些不再需要的shared_ptr元素。 如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。 使用了动态生存期的资源的类 程序使用动态内存出于以下三种原因之一： 程序不知道自己需要使用多少对象 程序不知道所需对象的准确类型 程序需要在多个对象间共享数据 容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因而使用动态内存的例子。在本节中，我们将定义一个类，它使用动态内存是为了让多个对象能共享相同的底层数据。 某些类分配的资源具有与原对象相独立的生存期。例如，假定我们希望定义一个名为Blob的类，保存一组元素。与容器不同，我们希望Blob对象的不同拷贝之间共享相同的元素。即，当我们拷贝一个Blob时，原Blob对象及其拷贝应该引用相同的底层元素。 使用动态内存的一个常见原因是允许多个对象共享相同的状态。 12.1.2 直接管理内存使用new动态分配和初始化对象 默认情况下，动态分配的对象是默认初始化的（参见2.2.1节，第40页），这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。也可以对动态分配的对象进行值初始化（参见3.3.1节，第88页），只需在类型名之后跟一对空括号即可 对于定义了自己的构造函数（参见7.1.4节，第235页）的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的（参见7.1.4节，第236页）。 如果我们提供了一个括号包围的初始化器，就可以使用auto（参见2.5.2节，第61页）从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto 动态分配的const对象 内存耗尽 默认情况下，如果new不能分配所要求的内存空间，它会抛出一个类型为bad_alloc（参见5.6节，第173页）的异常。我们可以改变使用new的方式来阻止它抛出异常 这种形式的new为定位new（placement new），其原因我们将在19.1.2节（第729页）中解释。定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。 释放动态内存 指针值和delete 我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针（参见2.3.2节，第48页）。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的 动态对象的生存期直到被释放时为止 返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存 小心：动态内存的管理非常容易出错 使用new和delete管理动态内存存在三个常见问题： 忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。 使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。 同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。相对于查找和修正这些错误来说，制造出这些错误要简单得多。 delete之后重置指针值，这只是提供了有限的保护 12.1.3 shared_ptr和new结合使用如果我们不初始化一个智能指针，它就会被初始化为一个空指针。如表12.3所示，我们还可以用new返回的指针来初始化智能指针 接受指针参数的智能指针构造函数是explicit的（参见7.5.4节，第265页）。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式（参见3.2.1节，第76页）来初始化一个智能指针 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。 我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代delete。 不要混合使用普通指针和智能指针 shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）之间。这也是为什么我们推荐使用make_shared而不是new的原因。这样，我们就能在分配对象的同时就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的shared_ptr上。 也不要使用get初始化另一个智能指针或为智能指针赋值 智能指针类型定义了一个名为get的函数（参见表12.1），它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针。 将另一个智能指针也绑定到get返回的指针上是错误的。 get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。 12.1.4 智能指针和异常一个简单的确保资源被释放的方法是使用智能指针。如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放 智能指针和哑类 包括所有标准库类在内的很多C++类都定义了析构函数（参见12.1.1节，第402页），负责清理对象使用的资源。但是，不是所有的类都是这样良好定义的。特别是那些为C和C++两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。 如果connection有一个析构函数，就可以在f结束时由析构函数自动关闭连接。但是，connection没有析构函数。这个问题与我们上一个程序中使用shared_ptr避免内存泄漏几乎是等价的。使用shared_ptr来保证connection被正确关闭，已被证明是一种有效的方法。 使用我们自己的释放操作 默认情况下，shared_ptr假定它们指向的是动态内存。因此，当一个shared_ptr被销毁时，它默认地对它管理的指针进行delete操作。为了用shared_ptr来管理一个connection，我们必须首先定义一个函数来代替delete。这个删除器（deleter）函数必须能够完成对shared_ptr中保存的指针进行释放的操作。在本例中，我们的删除器必须接受单个类型为connection＊的参数 当我们创建一个shared_ptr时，可以传递一个（可选的）指向删除器函数的参数（参见6.7节，第221页） 注意：智能指针陷阱 智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范： 不使用相同的内置指针值初始化（或reset）多个智能指针。 不delete get（）返回的指针。 不使用get（）初始化或reset另一个智能指针。 如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。 如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（参见12.1.4节，第415页和12.1.5节，第419页）。 12.1.5 unique_ptr一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。 由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作 虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique 传递unique_ptr参数和返回unique_ptr 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr 还可以返回一个局部对象的拷贝 对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”，我们将在13.6.2节（第473页）中介绍它。 向unique_ptr传递删除器 unique_ptr管理删除器的方式与shared_ptr不同，其原因我们将在16.1.6节（第599页）中介绍。 重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造（或reset）该类型的对象。与重载关联容器的比较操作（参见11.2.2节，第378页）类似，我们必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或reset一个这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器） 12.1.6 weak_ptrweak_ptr（见表12.5）是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。 当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它。 由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象的shared_ptr。与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就会一直存在。 12.2 动态数组C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力，原因我们将在12.2.2节（第427页）中解释。 使用容器的类可以使用默认版本的拷贝、赋值和析构操作（参见7.1.5节，第239页）。分配动态数组的类则必须定义自己版本的操作，在拷贝、复制以及销毁对象时管理所关联的内存。 12.2.1 new和数组为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针 分配一个数组会得到一个元素类型的指针 由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end（参见3.5.3节，第106页）。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理（所谓的）动态数组中的元素。 要记住我们所说的动态数组并不是数组类型，这是很重要的。 初始化动态分配对象的数组 默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化（参见3.3.1节，第88页），方法是在大小之后跟一对空括号。 在新标准中，我们还可以提供一个元素初始化器的花括号列表。如果初始化器数目小于元素数目，剩余元素将进行值初始化。如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。在本例中，new会抛出一个类型为bad_array_new_length的异常。类似bad_alloc，此类型定义在头文件new中。 动态分配一个空数组是合法的 当n等于0时，调用new[n]是合法的。 new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样（参见3.5.3节，第106页），我们可以像使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。 释放动态数组 为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对 数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。 如果我们在delete一个指向数组的指针时忽略了方括号（或者在delete一个指向单一对象的指针时使用了方括号），其行为是未定义的。 智能指针和动态数组 标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号 指向数组的unique_ptr提供的操作与我们在12.1.5节（第417页）中使用的那些操作有一些不同 与unique_ptr不同，shared_ptr不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器。 shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素。 12.2.2 allocator类new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。 当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。 allocator类 标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。 类似vector，allocator是一个模板（参见3.3节，第86页）。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置 allocator分配未构造的内存 在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。 为了使用allocate返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。 当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数（参见12.1.1节，第402页） 我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。 拷贝和填充未初始化内存的算法 标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。表12.8描述了这些函数，它们都定义在头文件memory中。 类似copy，uninitialized_copy返回（递增后的）目的位置迭代器。 因此，一次uninitialized_copy调用会返回一个指针，指向最后一个构造的元素之后的位置。","link":"/2024/09/22/C-C-Primer-Chapter-12/"},{"title":"[C++]C++Primer Chapter 3","text":"字符串、向量和数组 3.1 命名空间的using声明3.2 标准库类型string3.2.1 定义和初始化string对象 直接初始化和拷贝初始化 3.2.2 string对象上的操作 读写string对象 从流读：在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。 getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。 getline也会返回它的流参数。因此既然输入运算符能作为判断的条件（参见1.4.3节，第13页），我们也能用getline的结果作为条件。 string：：size_type类型 它是一个无符号类型的值（参见2.1.1节，第30页）而且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string：：size_type类型的。 比较string对象 1.如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。 2.如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。 3.2.3 处理string对象中的字符 3.3 标准库类型vector3.3.1 定义和初始化vector对象 3.3.2 向vector对象中添加元素 范围for语句体内不应改变其所遍历序列的大小。 3.3.3 其他vector操作 3.4 迭代器介绍3.4.1 使用迭代器begin和end运算符 begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator 为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend 已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效 3.4.2 迭代器运算 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可正可负，所以difference_type是带符号类型的。 3.5 数组数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。 如果不清楚元素的确切个数，使用vector 3.5.1 定义和初始化内置数组数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式（参见2.4.4节，第58页） 字符数组的特殊性 我们可以用字符串字面值（参见2.1.3节，第36页）对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去 不允许拷贝和赋值 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值 理解复杂的数组声明 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 3.5.2 访问数组元素数组的元素也能使用范围for语句或下标运算符来访问。 在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。 3.5.3 指针和数组使用数组的时候编译器一般会把它转换成指针。 在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针 当使用数组作为一个auto（参见2.5.2节，第61页）变量的初始值时，推断得到的类型是指针而非数组 当使用decltype关键字（参见2.5.3节，第62页）时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组 标准库函数begin和end C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员（参见3.4.1节，第95页）功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数 两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。 3.5.4 C风格字符串C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\\0’）。一般利用指针来操作这些字符串。 3.5.5 与旧代码的接口如果执行完c_str（）函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 使用数组初始化vector对象 允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了： 3.6 多维数组要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。","link":"/2024/09/22/C-C-Primer-Chapter-3/"},{"title":"[C++]C++Primer Chapter 14","text":"","link":"/2024/09/22/C-C-Primer-Chapter-14/"},{"title":"[C++]C++Primer Chapter 13","text":"拷贝控制 一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。 13.1 拷贝、赋值与销毁13.1.1 拷贝构造函数如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。 拷贝构造函数的第一个参数必须是一个引用类型，原因我们稍后解释。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是explicit的（参见7.5.4节，第265页）。 合成拷贝构造函数 即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。 13.1.6节（第450页）中所见，对某些类来说，合成拷贝构造函数（synthesized copy constructor）用来阻止我们拷贝该类类型的对象。 虽然我们不能直接拷贝一个数组（参见3.5.1节，第102页），但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。 拷贝初始化 当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配（参见6.4节，第209页）来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化（copy initialization）时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换（参见7.5.4节，第263页）。 拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员（参见7.5.5节，第266页） 当我们初始化标准库容器或是调用其insert或push成员（参见9.3.1节，第306页）时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化（参见9.3.1节，第308页）。 参数和返回值 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化（参见6.2.1节，第188页）。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果（参见6.3.2节，第201页）。 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。 拷贝初始化的限制 如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换（参见7.5.4节，第265页），那么使用拷贝初始化还是直接初始化就不是无关紧要的了 编译器可以绕过拷贝构造函数 在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。 但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的（例如，不能是private的）。 13.1.2 拷贝赋值运算符如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。 重载赋值运算符 重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。 某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数（参见7.1.2节，第231页）。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。 为了与内置类型的赋值（参见4.4节，第129页）保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。 标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。 赋值运算符通常应该返回一个指向其左侧运算对象的引用。 合成拷贝赋值运算符 对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。 13.1.3 析构函数析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。 析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数 由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。 析构函数完成什么工作 如同构造函数有一个初始化部分和一个函数体（参见7.5.1节，第257页），析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。 什么时候会调用析构函数 无论何时一个对象被销毁，就会自动调用其析构函数： 变量在离开其作用域时被销毁。 当一个对象被销毁时，其成员被销毁。 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁（参见12.1.2节，第409页）。 对于临时对象，当创建它的完整表达式结束时被销毁。 合成析构函数 类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁（参见13.1.6节，第450页）。如果不是这种情况，合成析构函数的函数体就为空。 认识到析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。 13.1.4 三/五法则有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符，我们将在13.6节（第470页）中介绍这些内容。 需要析构函数的类也需要拷贝和赋值操作 需要拷贝操作的类也需要赋值操作，反之亦然 无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。 13.1.5 使用=default我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本（参见7.1.4节，第237页） 当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default，就像对拷贝赋值运算符所做的那样。 13.1.6 阻止拷贝 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。 对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。 定义删除的函数 在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的 与=default不同，=delete必须出现在函数第一次声明的时候 与=default的另一个不同之处是，我们可以对任何函数指定=delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。 析构函数不能是删除的成员 值得注意的是，我们不能删除析构函数。 对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象 合成的拷贝控制成员可能是删除的 对某些类来说，编译器将这些合成的成员定义为删除的函数： 如果类的某个成员的析构函数是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为删除的。 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。 如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器（参见2.6.1节，第65页），或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。 本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。 private拷贝控制 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝 声明但不定义一个成员函数是合法的（参见6.1.2节，第186页），对此只有一个例外，我们将在15.2.1节（第528页）中介绍。试图访问一个未定义的成员将导致一个链接时错误。通过声明（但不定义）private的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。 13.2 拷贝控制和资源管理首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。 类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。 行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。 在我们使用过的标准库类中，标准库容器和string类的行为像一个值。而不出意外的，shared_ptr类提供类似指针的行为，就像我们的StrBlob类（参见12.1.1节，第405页）一样，IO类型和unique_ptr不允许拷贝或赋值，因此它们的行为既不像值也不像指针。 13.2.1 行为像值的类为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。 类值拷贝赋值运算符 赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是，非常重要的一点是，这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保证正确。而且，如果可能，我们编写的赋值运算符还应该是异常安全的——当异常发生时能将左侧运算对象置于一个有意义的状态（参见5.6.2节，第175页）。 通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证在异常发生时代码也是安全的。 关键概念：赋值运算符 当你编写赋值运算符时，有两点需要记住： 如果将一个对象赋予它自身，赋值运算符必须能正确工作。 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。 当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。 13.2.2 定义行为像指针的类对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。 析构函数不能单方面地释放关联的string。只有当最后一个指向string的HasPtr销毁时，它才可以释放string。 令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。 但是，有时我们希望直接管理资源。在这种情况下，使用引用计数（reference count）（参见12.1.1节，第402页）就很有用了。 引用计数 引用计数的工作方式如下： 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。 计数器不能直接作为HasPtr对象的成员。 解决此问题的一种方法是将计数器保存在动态内存中。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。 定义一个使用引用计数的类 类指针的拷贝成员“篡改”引用计数 析构函数不能无条件地delete ps——可能还有其他对象指向这块内存。析构函数应该递减引用计数，指出共享string的对象少了一个。如果计数器变为0，则析构函数释放ps和use指向的内存 13.3 交换操作管理资源的类一般会定义自己的 swap 函数。 对于会重排元素顺序的算法来说，如果类定义了自己的swap函数，则调用该函数，否则使用标准库定义的swap，该函数会进行一次拷贝两次赋值。 编写我们自己的swap函数 与拷贝控制成员不同，swap并不是必要的。但是，对于分配了资源的类，定义swap可能是一种很重要的优化手段。 一个典型的实现方法，由于swap的存在就是为了优化代码，我们将其声明为inline函数（参见6.5.2节，第213页）。 需要注意的是，每个swap调用应该都是未加限定的。即，每个调用都应该是swap，而不是std：：swap。如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本，原因我们将在16.3节（第616页）中进行解释。 在赋值运算符中使用swap 使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。 定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换（copy and swap）的技术。 13.4 拷贝控制示例通常来说分配资源的类更需要拷贝控制，但资源管理并不是一个类需要定义自己的拷贝控制成员的唯一原因。一些类也需要拷贝控制成员的帮助来进行簿记工作或其他操作。 两个类命名为Message和Folder，分别表示电子邮件（或者其他类型的）消息和消息目录。每个Message对象可以出现在多个Folder中。但是，任意给定的Message的内容只有一个副本。这样，如果一条Message的内容被改变，则我们从它所在的任何Folder来浏览此Message时，都会看到改变后的内容。为了记录Message位于哪些Folder中，每个Message都会保存一个它所在Folder的指针的set，同样的，每个Folder都保存一个它包含的Message的指针的set。 Message类会提供save和remove操作，来向一个给定Folder添加一条Message或是从中删除一条Message。为了创建一个新的Message，我们会指明消息内容，但不会指出Folder。为了将一条Message放到一个特定Folder中，我们必须调用save。 当我们拷贝一个Message时，副本和原对象将是不同的Message对象，但两个Message都出现在相同的Folder中。因此，拷贝Message的操作包括消息内容和Folder指针set的拷贝。而且，我们必须在每个包含此消息的Folder中都添加一个指向新创建的Message的指针。 当我们销毁一个Message时，它将不复存在。因此，我们必须从包含此消息的所有Folder中删除指向此Message的指针。 当我们将一个Message对象赋予另一个Message对象时，左侧Message的内容会被右侧Message的内容所替代。我们还必须更新Folder集合，从原来包含左侧Message的Folder中将它删除，并将它添加到包含右侧Message的Folder中。 观察这些操作，我们可以看到，析构函数和拷贝赋值运算符都必须从包含一条Message的所有Folder中删除它。类似的，拷贝构造函数和拷贝赋值运算符都要将一个Message添加到给定的一组Folder中。我们将定义两个private的工具函数来完成这些工作。 拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这种情况下，公共的工作应该放在private的工具函数中完成。 Folder类也需要类似的拷贝控制成员，来添加或删除它保存的Message。 13.5 动态内存管理类某些类需要在运行时分配可变大小的内存空间。这种类通常可以（并且如果它们确实可以的话，一般应该）使用标准库容器来保存它们的数据。 但是，这一策略并不是对每个类都适用；某些类需要自己进行内存分配。这些类一般来说必须定义自己的拷贝控制成员来管理所分配的内存。 StrVec类的设计 使用一个allocator来获得原始内存（参见12.2.2节，第427页）。由于allocator分配的内存是未构造的，我们将在需要添加新元素时用allocator的construct成员在原始内存中创建对象。类似的，当我们需要删除一个元素时，我们将使用destroy成员来销毁元素。 每个StrVec有三个指针成员指向其元素所使用的内存： elements，指向分配的内存中的首元素 first_free，指向最后一个实际元素之后的位置 cap，指向分配的内存末尾之后的位置 StrVec还有一个名为alloc的静态成员，其类型为allocator&lt;string&gt;。 还有4个工具函数： alloc_n_copy会分配内存，并拷贝一个给定范围中的元素。 free会销毁构造的元素并释放内存。 chk_n_alloc保证StrVec至少有容纳一个新元素的空间。如果没有空间添加新元素，chk_n_alloc会调用reallocate来分配更多内存。 reallocate在内存用完时为StrVec分配新内存。 StrVec类定义 1234567891011121314151617181920212223242526272829class StrVec{public: StrVec() : // alloc成员默认初始化 elements(nullptr), first_free(nullptr), cap(nullptr) { } StrVec(const StrVec &amp;); // 拷贝构造 StrVec &amp;operator=(const StrVec &amp;); // 拷贝赋值 ~StrVec(); // 析构函数 void push_back(const std::string &amp;); // 拷贝元素并添加到容器末尾 size_t size() const { return first_free - elements; } size_t capacity() const { return cap - elements; } std::string *begin() const { return elements; } std::string *end() const { return first_free; }private: void chk_n_alloc() { if (size() == capacity()) reallocate(); } // 至少保证容器有一个空闲空间 std::pair&lt;std::string *, std::string *&gt; alloc_n_copy // 分配内存并拷贝范围内元素 (const std::string *, const std::string *); void free(); // 销毁元素并释放内存 void reallocate(); // 重新分配内存并拷贝元素 static std::allocator&lt;std::string&gt; alloc; // 内存分配器 std::string *elements; // 数组首元素 std::string *first_free; // 数组最后一个元素之后的位置 std::string *cap; // 数组分配内存之后的位置}; 使用construct 若想使用原始内存，必须调用construct在此原始内存上构造一个对象。 123456void StrVec::push_back(const std::string &amp;ele){ chk_n_alloc(); alloc.construct(first_free++, ele);} push_back首先调用chk_n_alloc确保有足够的原始内存来构造对象，然后用allocator来构造一个对象，construct的第一个参数指向内存的起始地址，其他参数用来决定调用哪个构造函数来构造对象，此例中调用string的拷贝构造函数。 alloc_n_copy成员 123456std::pair&lt;std::string *, std::string *&gt; StrVec::alloc_n_copy (const std::string *begin, const std::string *end){ auto data = alloc.allocate(end - begin); return {data, std::uninitialized_copy(begin, end, data)};} free成员 1234567void StrVec::free(){ if (elements == nullptr) return; for (auto p = elements; p != first_free; ++p) alloc.destroy(p); alloc.deallocate(elements, cap - elements);} 注意，deallocate函数不接受空指针，所以必须要先检查指针是否未空。另外，我们必须首先销毁对象，然后再释放内存。 拷贝控制成员 1234567891011121314151617181920StrVec::StrVec(const StrVec &amp;other){ auto data = alloc_n_copy(other.begin(), other.end()); elements = data.first; first_free = cap = data.second;}StrVec &amp;StrVec::operator=(const StrVec &amp;other) { auto data = alloc_n_copy(other.begin(), other.end()); free(); elements = data.first; first_free = cap = data.second; return *this;}StrVec::~StrVec() { free();} 重载赋值运算符在释放内存之前，先调用alloc_n_copy复制一份数据出来，这样可以处理自赋值问题。 在重新分配内存的过程中移动而不是拷贝元素 在编写reallocate成员函数之前，我们稍微思考一下此函数应该做什么。它应该 为一个新的、更大的string数组分配内存 在内存空间的前一部分构造对象，保存现有元素 销毁原内存空间中的元素，并释放这块内存 string的行为类似值，每个string对构成它的所有字符都会保存自己的一份副本。拷贝一个string必须为这些字符分配内存空间，而销毁一个string必须释放所占用的内存。 拷贝一个string就必须真的拷贝数据，因为通常情况下，在我们拷贝了一个string之后，它就会有两个用户。但是，如果是reallocate拷贝StrVec中的string，则在拷贝之后，每个string只有唯一的用户。一旦将元素从旧空间拷贝到了新空间，我们就会立即销毁原string。因此，拷贝这些string中的数据是多余的。 移动构造函数和std：：move 有一些标准库类，包括string，都定义了所谓的“移动构造函数”。移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。而且我们知道标准库保证“移后源”（moved-from）string仍然保持一个有效的、可析构的状态。 move的标准库函数，它定义在utility头文件中。当reallocate在新内存中构造string时，它必须调用move来表示希望使用string的移动构造函数，原因我们将在13.6.1节（第470页）中解释。如果它漏掉了move调用，将会使用string的拷贝构造函数。其次，我们通常不为move提供一个using声明（参见3.1节，第74页），原因将在18.2.3节（第706页）中解释。当我们使用move时，直接调用std：：move而不是move。 reallocate成员 1234567891011void StrVec::reallocate(){ auto new_size = capacity() ? capacity() * 2 : 1; auto new_elements = alloc.allocate(new_size); for (size_t i = 0; i != size(); ++i) alloc.construct(new_elements + i, std::move(*(elements + i))); free(); cap = new_elements + new_size; first_free = new_elements + size(); elements = new_elements;} 注意这里需要处理默认初始化后第一次调用reallocate的情况，需要判断。 测试 1234567891011121314151617181920212223242526272829303132333435363738394041int main(){ StrVec vec; vec.push_back(&quot;Hello&quot;); vec.push_back(&quot;World&quot;); vec.push_back(&quot;Test&quot;); auto printVec = [](const StrVec &amp;vec) { std::for_each(vec.begin(), vec.end(), [](const std::string &amp;s) { std::cout &lt;&lt; s &lt;&lt; &quot; &quot;; }); std::cout &lt;&lt; std::endl; }; std::cout &lt;&lt; &quot;Original vec: &quot;; printVec(vec); std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; vec.size() &lt;&lt; &quot;, Capacity: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; // 测试拷贝构造函数 StrVec vecCopy(vec); std::cout &lt;&lt; &quot;Copied vec: &quot;; printVec(vecCopy); // 测试拷贝赋值操作符 StrVec vecAssign; vecAssign = vec; std::cout &lt;&lt; &quot;Assigned vec: &quot;; printVec(vecAssign); // 添加更多元素以触发重新分配 vec.push_back(&quot;More&quot;); vec.push_back(&quot;Strings&quot;); std::cout &lt;&lt; &quot;Original vec after adding more elements: &quot;; printVec(vec); std::cout &lt;&lt; &quot;Size: &quot; &lt;&lt; vec.size() &lt;&lt; &quot;, Capacity: &quot; &lt;&lt; vec.capacity() &lt;&lt; std::endl; return 0;} 结果 13.6 对象移动 标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。 在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另一个原因源于IO类或unique_ptr这样的类。这些类都包含不能被共享的资源（如指针或IO缓冲）。因此，这些类型的对象不能拷贝但可以移动。 在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。 13.6.1 右值引用为了支持移动操作，新标准引入了一种新的引用类型——右值引用（rvalue reference）。所谓右值引用就是必须绑定到右值的引用。我们通过&amp;&amp;而不是&amp;来获得右值引用。右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。 一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。 左值持久；右值短暂 左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。 因为右值引用的对象即将被销毁，且没有其他用户，因此我们可以自由的接管该对象管理的资源。 变量是左值 因此，我们不能将一个右值引用绑定到一个右值引用类型的变量上 标准库move函数 虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为move的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。move函数使用了我们将在16.2.6节（第610页）中描述的机制来返回给定对象的右值引用。 move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用move就意味着承诺：除了对rr1赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。 与大多数标准库名字的使用不同，对move（参见13.5节，第469页）我们不提供using声明（参见3.1节，第74页）。我们直接调用std：：move而不是move，其原因将在18.2.3节（第707页）中解释。 13.6.2 移动构造函数和移动赋值运算符类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。 除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。 移动操作、标准库容器和异常 由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。 一种通知标准库的方法是在我们的构造函数中指明noexcept。noexcept是新标准引入的，我们将在18.1.4节（第690页）中讨论更多细节。目前重要的是要知道，noexcept是我们承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定noexcept。在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间 我们必须在类头文件的声明中和定义中（如果定义在类外的话）都指定noexcept。 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。 搞清楚为什么需要noexcept能帮助我们深入理解标准库是如何与我们自定义的类型交互的。 我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实：首先，虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时其自身的行为提供保障。例如，vector保证，如果我们调用push_back时发生异常，vector自身不会发生改变。 现在让我们思考push_back内部发生了什么。类似对应的StrVec操作（参见13.5节，第466页），对一个vector调用push_back可能要求为vector重新分配内存空间。当重新分配vector的内存时，vector将元素从旧空间移动到新内存中，就像我们在reallocate中所做的那样（参见13.5节，第469页）。如我们刚刚看到的那样，移动一个对象通常会改变它的值。如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。在此情况下，vector将不能满足自身保持不变的要求。 另一方面，如果vector使用了拷贝构造函数且发生了异常，它可以很容易地满足要求。在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生了异常，vector可以释放新分配的（但还未成功构造的）内存并返回。vector原有的元素仍然存在。为了避免这种潜在问题，除非vector知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。 如果希望在vector重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数（及移动赋值运算符）标记为noexcept来做到这一点。 移动赋值运算符 移动赋值运算符执行与析构函数和移动构造函数相同的工作。与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为noexcept。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值 我们费心地去检查自赋值情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算对象的一个右值。我们进行检查的原因是此右值可能是move调用的返回结果。与其他任何赋值运算符一样，关键点是我们不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源（可能是相同的资源）。 移后源对象必须可析构 除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。 例如，当我们从一个标准库string或容器对象移动数据时，我们知道移后源对象仍然保持有效。因此，我们可以对它执行诸如empty或size这些操作。但是，我们不知道将会得到什么结果。我们可能期望一个移后源对象是空的，但这并没有保证。 合成的移动操作 与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。 与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。 只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成=default的（参见7.1.4节，第237页）移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。 移动右值，拷贝左值，但如果没有移动构造函数，右值也被拷贝 如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用move来移动它们时也是如此。 值得注意的是，用拷贝构造函数代替移动构造函数几乎肯定是安全的（赋值运算符的情况类似）。 拷贝并交换赋值运算符和移动操作 我们的HasPtr版本定义了一个拷贝并交换赋值运算符（参见13.3节，第459页），它是函数匹配和移动操作间相互关系的一个很好的示例。如果我们为此类添加一个移动构造函数，它实际上也会获得一个移动赋值运算符 现在让我们观察赋值运算符。此运算符有一个非引用参数，这意味着此参数要进行拷贝初始化（参见13.1.1节，第441页）。依赖于实参的类型，拷贝初始化要么使用拷贝构造函数，要么使用移动构造函数——左值被拷贝，右值被移动。 建议：更新三/五法则 所有五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作（参见13.1.4节，第447页）。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。 移动迭代器 StrVec的reallocate成员（参见13.5节，第469页）使用了一个for循环来调用construct从旧内存将元素拷贝到新内存中。作为一种替换方法，如果我们能调用uninitialized_copy来构造新分配的内存，将比循环更为简单。但是，uninitialized_copy恰如其名：它对元素进行拷贝操作。标准库中并没有类似的函数将对象“移动”到未构造的内存中。 新标准库中定义了一种移动迭代器（move iterator）适配器（参见10.4节，第358页）。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。 我们通过调用标准库的make_move_iterator函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。 原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别是，可以将移动迭代器传递给uninitialized_copy 值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。 建议：不要随意使用移动操作 13.6.3 右值引用和成员函数除了构造函数和赋值运算符之外，如果一个成员函数同时提供拷贝和移动版本，它也能从中受益。这种允许移动的成员函数通常使用与拷贝/移动构造函数和赋值运算符相同的参数模式——一个版本接受一个指向const的左值引用，第二个版本接受一个指向非const的右值引用。 例如，定义了push_back的标准库容器提供两个版本：一个版本有一个右值引用参数，而另一个版本有一个const左值引用。假定X是元素类型，那么这些容器就会定义以下两个push_back版本 区分移动和拷贝的重载函数通常有一个版本接受一个const T&amp;，而另一个版本接受一个T&amp;&amp;。 右值和左值引用成员函数 通常，我们在一个对象上调用成员函数，而不管该对象是一个左值还是一个右值。例如 有时，右值的使用方式可能令人惊讶： 在旧标准中，我们没有办法阻止这种使用方式。为了维持向后兼容性，新标准库类仍然允许向右值赋值。但是，我们可能希望在自己的类中阻止这种用法。在此情况下，我们希望强制左侧运算对象（即，this指向的对象）是一个左值。 我们指出this的左值/右值属性的方式与定义const成员函数相同（参见7.1.2节，第231页），即，在参数列表后放置一个引用限定符（reference qualifier） 引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值。类似const限定符，引用限定符只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。 对于&amp;限定的函数，我们只能将它用于左值；对于&amp;&amp;限定的函数，只能用于右值 一个函数可以同时用const和引用限定。在此情况下，引用限定符必须跟随在const限定符之后 重载和引用函数 就像一个成员函数可以根据是否有const来区分其重载版本一样（参见7.3.2节，第247页），引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和const来区分一个成员函数的重载版本。 当我们定义const成员函数时，可以定义两个版本，唯一的差别是一个版本有const限定而另一个没有。引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。","link":"/2024/09/22/C-C-Primer-Chapter-13/"},{"title":"[C++]C++Primer Chapter 6","text":"函数 6.1 函数基础函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。 执行函数的第一步是（隐式地）定义并初始化它的形参。因此，当调用fact函数时，首先创建一个名为val的int变量，然后将它初始化为调用时所用的实参5。 当遇到一条return语句时函数结束执行过程。和函数调用一样，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。 形参和实参 实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序（参见4.1.3节，第123页）。编译器能以任意可行的顺序对实参求值。 6.1.1 局部对象在C++语言中，名字有作用域（参见2.2.4节，第43页），对象有生命周期（lifetime）。理解这两个概念非常重要。 名字的作用域是程序文本的一部分，名字在其中可见。 对象的生命周期是程序执行过程中该对象存在的一段时间。 在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。 自动对象 对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。 局部静态对象 某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。 6.1.2 函数声明函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型（function prototype）。 在头文件中进行函数声明 我们建议变量在头文件（参见2.6.3节，第68页）中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。 定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。 6.1.3 分离式编译分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。 编译和链接多个源文件 假设fact函数的定义位于一个名为fact.cc的文件中，它的声明位于名为Chapter6.h的头文件中。显然与其他所有用到fact函数的文件一样，fact.cc应该包含Chapter6.h头文件。另外，我们在名为factMain.cc的文件中创建main函数，main函数将调用fact函数。要生成可执行文件（executable file），必须告诉编译器我们用到的代码在哪里。 6.2 参数传递每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。 形参初始化的机理与变量初始化一样。 6.2.1 传值参数 在C++语言中，建议使用引用类型的形参替代指针。 6.2.2 传引用参数使用引用避免拷贝 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。 使用引用形参返回额外信息 6.2.3 const形参和实参尽量使用常量引用 把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。就像刚刚看到的，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。 当一个a函数的形参是const，a函数要将这个参数作为实参传递给另外一个b函数，最理想的方法是b函数的参数应该也是const，如果无法满足，正确的做法应该是在a函数内部定义一个局部对象，拷贝一份这个形参，然后将局部对象作为参数传递给b函数。 6.2.4 数组形参数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组（参见3.5.1节，第102页）以及使用数组时（通常）会将其转换成指针（参见3.5.3节，第105页）。 尽管表现形式不同，但上面的三个函数是等价的：每个函数的唯一形参都是const int＊类型的。当编译器处理对print函数的调用时，只检查传入的参数是否是const int＊类型 管理指针形参有三种常用的技术： 使用标记指定数组长度 管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串（参见3.5.4节，第109页）。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符停止 使用标准库规范 管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库技术的启发，关于其细节将在第II部分详细介绍。使用该方法，我们可以按照如下形式输出元素内容 显式传递一个表示数组大小的形参 第三种管理数组实参的方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。使用该方法，可以将print函数重写成如下形式 数组形参和const 当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针（参见2.4.2节，第56页）。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针 数组引用形参 C++语言允许将变量定义成数组的引用（参见3.5.1节，第101页），基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上 因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组 16.1.1节（第578页）将要介绍我们应该如何编写这个函数，使其可以给引用类型的形参传递任意大小的数组 传递多维数组 当将多维数组传递给函数时，真正传递的是指向数组首元素的指针（参见3.6节，第115页）。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略 6.2.5 main：处理命令行选项 第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。 当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0 当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。 6.2.6 含有可变形参的函数为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节（第618页）介绍。 C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。本节将简要介绍省略符形参，不过需要注意的是，这种功能一般只用于与C函数交互的接口程序。 initializer_list形参 如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组（参见3.5节，第101页）。initializer_list类型定义在同名的头文件中，它提供的操作如表6.1所示。 initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。 如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内 省略符形参 省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。 省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。 省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种 6.3 返回类型和return语句6.3.1 无返回值函数6.3.2 有返回值函数 在含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的。很多编译器都无法发现此类错误。运行时的行为是未定义的。 值是如何被返回的 返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。 不要返回局部对象的引用或指针 返回类类型的函数和调用运算符 引用返回左值 列表初始化返回值 C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化（参见3.3.1节，第88页）；否则，返回的值由函数的返回类型决定。 主函数main的返回值 为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量（参见2.3.2节，第49页），我们可以使用这两个变量分别表示成功与失败 递归 如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数（recursive function）。 6.3.3 返回数组指针因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用（参见3.5.1节，第102页）。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名（参见2.5.1节，第60页） 声明一个返回数组指针的函数 使用尾置返回类型 在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。 尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto 使用decltype 如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。 arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd的类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。有一个地方需要注意：decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个＊符号。 6.4 函数重载如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。 定义重载函数 对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。 不允许两个函数除了返回类型外其他所有的要素都相同。 重载和const形参 一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的 当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。 const_cast和重载 const_cast在重载函数的情景中最有用 这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用。因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点 在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&amp;，这显然是安全的。 调用重载的函数 当调用重载函数时有三种可能的结果： 1.编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。 2.找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配（no match）的错误信息。 3.有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用（ambiguous call）。 6.4.1 重载与作用域如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名 6.5 特殊用途语言特性6.5.1 默认实参我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 使用默认实参调用函数 尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。 默认实参声明 在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。 默认实参初始值 局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参 6.5.2 内联函数和constexpr函数内联函数可避免函数调用的开销 将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。 constexpr函数 constexpr函数（constexpr function）是指能用于常量表达式（参见2.4.4节，第58页）的函数。 定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型（参见2.4.4节，第59页），而且函数体中必须有且只有一条return语句 constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名（参见2.5.1节，第60页）以及using声明。 constexpr函数不一定返回常量表达式。 把内联函数和constexpr函数放在头文件内 和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。 6.5.3 调试帮助C++程序员有时会用到一种类似于头文件保护（参见2.6.3节，第67页）的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。 assert预处理宏 assert是一种预处理宏（preprocessor marco）。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件： 首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。 NDEBUG预处理变量 assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。 我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量： 这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。 assert应该仅用于验证那些确实不可能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。 除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定义了NDEBUG，这些代码将被忽略掉： 我们使用变量__func__输出当前调试的函数的名字。编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。 除了C++编译器定义的__func__外，预处理器还定义了另外4个对于程序调试很有用的名字： __FILE__存放文件名的字符串字面值。 __LINE__存放当前行号的整型字面值。 __TIME__存放文件编译时间的字符串字面值。 __DATE__存放文件编译日期的字符串字面值。 6.6 函数匹配确定候选函数和可行函数 函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。 第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数（viable function）。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。 在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。和一般的函数调用类似，实参与形参匹配的含义可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。 寻找最佳匹配（如果有的话） 如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。 调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。 6.6.1 实参类型转换有时间再看。 6.7 函数指针函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。 要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可 使用函数指针 当我们把函数名作为一个值使用时，该函数自动地转换成指针。 我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针 重载函数的指针 编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配 函数指针形参 虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用 直接使用函数指针类型显得冗长而烦琐。类型别名（参见2.5.1节，第60页）和decltype（参见2.5.3节，第62页）能让我们简化使用了函数指针的代码 返回指向函数的指针 虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。 要想声明一个返回函数指针的函数，最简单的办法是使用类型别名 和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针 将auto和decltype用于函数指针类型","link":"/2024/09/22/C-C-Primer-Chapter-6/"},{"title":"[C++]C++Primer Chapter 5","text":"语句 5.1 简单语句5.2 语句作用域5.3 条件语句5.3.1 if语句5.3.2 switch语句switch语句（switch statement）提供了一条便利的途径使得我们能够在若干固定选项中做出选择。 case关键字和它对应的值一起被称为case标签（case label）。case标签必须是整型常量表达式。 即使不准备在default标签下做任何工作，定义一个default标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做。 switch内部的变量定义 switch的执行流程有可能会跨过某些case标签。如果程序跳转到了某个特定的case，则switch结构中该case标签之前的部分会被忽略掉。这种忽略掉一部分代码的行为引出了一个有趣的问题：如果被略过的代码中含有变量的定义该怎么办？ 答案是：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。 如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之外。 5.4 迭代语句5.4.1 while语句 定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程。 5.4.2 for语句 init-statement必须是以下三种形式中的一种：声明语句、表达式语句或者空语句 init-statement负责初始化一个值，这个值将随着循环的进行而改变。condition作为循环控制的条件，只要condition为真，就执行一次statement。如果condition第一次的求值结果就是false，则statement一次也不会执行。expression负责修改init-statement初始化的变量，这个变量正好就是condition检查的对象，修改发生在每次循环迭代之后。 5.4.3 范围for语句 expression表示的必须是一个序列，比如用花括号括起来的初始值列表（参见3.3.1节，第88页）、数组（参见3.5节，第101页）或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员（参见3.4节，第95页）。 在范围for语句中，预存了end（）的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了（参见3.4.1节，第98页）。 5.4.4 do while语句 5.5 跳转语句跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break、continue、goto和return。 5.5.1 break语句5.5.2 continue语句5.5.3 goto语句 其中，label是用于标识一条语句的标示符。带标签语句（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号： 不要在程序中使用goto语句，因为它使得程序既难理解又难修改。 5.2 try语句块和异常处理异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。 在C++语言中，异常处理包括： throw表达式（throw expression），异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise）了异常。 try语句块（try block），异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句（catch clause）结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码（exception handler）。 一套异常类（exception class），用于在throw表达式和相关的catch子句之间传递异常的具体信息。 5.6.1 throw表达式throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。 在这段代码中，如果ISBN不一样就抛出一个异常，该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。 类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。关于标准库异常类型更多的知识将在5.6.3节（第176页）介绍。我们必须初始化runtime_error的对象，方式是给它提供一个string对象或者一个C风格的字符串（参见3.5.4节，第109页），这个字符串中有一些关于异常的辅助信息。 5.6.2 try语句块 try语句块的一开始是关键字try，随后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列。 跟在try块之后的是一个或多个catch子句。catch子句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明（称作异常声明，exception declaration）以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。 每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串（即const char＊）。其中，runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。 在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。 对于那些没有任何try语句块定义的异常，也按照类似的方式处理：毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。 编写异常安全的代码非常困难 异常中断了程序的正常流程。异常发生时，调用者请求的一部分计算可能已经完成了，另一部分则尚未完成。通常情况下，略过部分程序意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。 那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全（exception safe）的代码。然而经验表明，编写异常安全的代码非常困难，这部分知识也（远远）超出了本书的范围。对于一些程序来说，当异常发生时只是简单地终止程序。此时，我们不怎么需要担心异常安全的问题。但是对于那些确实要处理异常并继续执行的程序，就要加倍注意了。我们必须时刻清楚异常何时发生，异常发生后程序应如何确保对象有效、资源无泄漏、程序处于合理状态，等等。 5.6.3 标准异常C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中 exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。 stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。 new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节（第407页）详细介绍。 type_info头文件定义了bad_cast异常类型，这种类型将在19.2节（第731页）详细介绍。 我们只能以默认初始化（参见2.2.1节，第40页）的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。 其他异常类型的行为则恰好相反：应该使用string对象或者C风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。 异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串（参见3.5.4节，第109页）的const char＊。该字符串的目的是提供关于异常的一些文本信息。","link":"/2024/09/22/C-C-Primer-Chapter-5/"},{"title":"[C++]C++Primer Chapter 4","text":"表达式 4.1 基础4.1.1 基本概念左值和右值 在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 4.1.2 优先级与结合律4.1.3 求值顺序优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。对于如下的表达式 我们知道f1和f2一定会在执行乘法之前被调用，因为毕竟相乘的是这两个函数的返回值。但是我们无法知道到底f1在f2之前调用还是f2在f1之前调用。 有4种运算符明确规定了运算对象的求值顺序： 1.逻辑与（&amp;&amp;）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。 2.逻辑或（||）运算符（参见4.3节，第126页）、 3.条件（？：）运算符（参见4.7节，第134页） 4.逗号（，）运算符（参见4.10节，第140页）。 4.2 算术运算符C++11新标准则规定商一律向0取整（即直接切除小数部分）。 4.3 逻辑和关系运算符4.4 赋值运算符赋值运算返回的是其左侧的运算对象 赋值运算满足右结合律 4.5 递增和递减运算符递增和递减运算符有两种形式：前置版本和后置版本。到目前为止，本书使用的都是前置版本，这种形式的运算符首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。后置版本也会将运算对象加1（或减1），但是求值结果是运算对象改变之前那个值的副本 这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。 建议：除非必须，否则不用递增递减运算符的后置版本 运算对象可按任意顺序求值 大多数运算符都没有规定运算对象的求值顺序（参见4.1.3节，第123页），这在一般情况下不会有什么影响。然而，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。 4.6 成员访问运算符4.7 条件运算符 其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。条件运算符的执行过程是：首先求cond的值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值。 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。 4.8 位运算符、位运算符作用于整数类型的运算对象或者bitset类型 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。 如果运算对象是“小整型”，则它的值会被自动提升（参见4.11.1节，第142页）成较大的整数类型。 移位运算符 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 4.9 sizeof运算符sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型（参见3.5.2节，第103页）的常量表达式（参见2.4.4节，第58页）。 sizeof并不实际计算其运算对象的值。因为sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针（参见2.3.2节，第47页）也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。 sizeof运算符的结果部分地依赖于其作用的类型： · 对char或者类型为char的表达式执行sizeof运算，结果得1。 · 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 · 对指针执行sizeof运算得到指针本身所占空间的大小。 · 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。 · 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。 · 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 4.10 逗号运算符逗号运算符（comma operator）含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了运算对象求值的顺序。 对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 4.11 类型转换算术类型之间的隐式转换被设计得尽可能避免损失精度。 何时发生隐式类型转换 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。 在条件中，非布尔值转换成布尔类型 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。 4.11.1 算术转换整型提升 整型提升（integral promotion）负责把小整数类型转换成较大的整数类型。对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都能存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。就如我们所熟知的，布尔值false提升成0、true提升成1。 较大的char类型（wchar_t、char16_t、char32_t）提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。 无符号类型的运算对象 如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。 像往常一样，首先执行整型提升。如果结果的类型匹配，无须进行进一步的转换。 如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned int和int，则int类型的运算对象转换成unsigned int类型。需要注意的是，如果int型的值恰好为负值，其结果将以2.1.2节（第32页）介绍的方法转换，并带来该节描述的所有副作用。 剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。 如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。 如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是long和unsigned int，并且int和long的大小相同，则long类型的运算对象转换成unsigned int类型；如果long类型占用的空间比int更多，则unsigned int类型的运算对象转换成long类型。 4.11.2 其他隐式类型转换数组转换成指针 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针 当数组被用作decltype关键字的参数，或者作为取地址符（&amp;）、sizeof及typeid（第19.2.2节，732页将介绍）等运算符的运算对象时，上述转换不会发生。 4.11.3 显式转换命名的强制类型转换 ype是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。 static_cast 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 用处： 1.当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。 2.static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void＊指针（参见2.3.2节，第50页）中的值 const_cast 用处： const_cast常常用于有函数重载的上下文中，关于函数重载将在6.4节（第208页）进行详细介绍。 reinterpret_cast reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。 4.12 运算符优先级表","link":"/2024/09/22/C-C-Primer-Chapter-4/"},{"title":"[C++]C++Primer Chapter 8","text":"IO库 C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO，即，从string读取数据，向string写入数据。 8.1 IO类 IO类型间的关系 类型ifstream和istringstream都继承自istream。因此，我们可以像使用istream对象一样来使用ifstream和istringstream对象。也就是说，我们是如何使用cin的，就可以同样地使用这些类型的对象。例如，可以对一个ifstream或istringstream对象调用getline，也可以使用&gt;&gt;从一个ifstream或istringstream对象中读取数据。类似的，类型ofstream和ostringstream都继承自ostream。因此，我们是如何使用cout的，就可以同样地使用这些类型的对象。 本节剩下部分所介绍的标准库流特性都可以无差别地应用于普通流、文件流和string流，以及char或宽字符流版本。 8.1.1 IO对象无拷贝或赋值我们不能拷贝或对IO对象赋值。 我们也不能将形参或返回类型设置为流类型（参见6.2.1节，第188页）。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 8.1.2 条件状态 如果我们在标准输入上键入Boo，读操作就会失败。代码中的输入运算符期待读取一个int，但却得到了一个字符B。这样，cin会进入错误状态。类似的，如果我们输入一个文件结束标识，cin也会进入错误状态。 一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用 查询流的状态 将流作为条件使用，只能告诉我们流是否有效，而无法告诉我们具体发生了什么。 IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用 IO库定义了4个iostate类型的constexpr值（参见2.4.4节，第58页），表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符（参见4.8节，第137页）一起使用来一次性检测或设置多个标志位。 badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。 在发生可恢复错误后，failbit被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。 如果到达文件结束位置，eofbit和failbit都会被置位。 goodbit的值为0，表示流未发生错误。如果badbit、failbit和eofbit任一个被置位，则检测流状态的条件会失败。 操作good在所有错误位均未置位的情况下返回true，而bad、fail和eof则在对应错误位被置位时返回true。此外，在badbit被置位时，fail也会返回true。这意味着，使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于！fail（）。而eof和bad操作只能表示特定的错误。 管理条件状态 流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。clear成员是一个重载的成员（参见6.4节，第206页）：它有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数。clear不接受参数的版本清除（复位）所有错误标志位。执行clear（）后，调用good会返回true。我们可以这样使用这些成员： 带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。例如，下面的代码将failbit和badbit复位，但保持eofbit不变： 8.1.3 管理输出缓冲每个输出流都管理一个缓冲区，用来保存程序读写的数据。 导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多： 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。 我们可以使用操纵符如endl（参见1.2节，第6页）来显式刷新缓冲区。 在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。 刷新输出缓冲区 我们已经使用过操纵符endl，它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符：flush和ends。flush刷新缓冲区，但不输出任何额外的字符；ends向缓冲区插入一个空字符，然后刷新缓冲区 unitbuf操纵符 如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制 警告：如果程序崩溃，输出缓冲区不会被刷新 关联输入和输出流 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起。 交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。 tie有两个重载的版本（参见6.4节，第206页）：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即，x.tie（&amp;o）将流x关联到输出流o。 我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream： 每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。 8.2 文件输入输出除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。在表8.3中列出了这些操作，我们可以对fstream、ifstream和ofstream对象调用这些操作，但不能对其他IO类型调用这些操作。 8.2.1 使用文件流对象当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。 创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则open会自动被调用。 用fstream代替iostream&amp; 如果有一个函数接受一个ostream&amp;参数，我们在调用这个函数时，可以传递给它一个ofstream对象，对istream&amp;和ifstream也是类似的。 成员函数open和close 如果调用open失败，failbit会被置位（参见8.1.2节，第280页）。因为调用open可能失败，进行open是否成功的检测通常是一个好习惯。 对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。 自动构造和析构 当一个fstream对象离开其作用域时，与之关联的文件会自动关闭。在下一步循环中，input会再次被创建。 当一个fstream对象被销毁时，close会自动被调用。 8.2.2 文件模式每个流都有一个关联的文件模式（file mode），用来指出如何使用文件。 指定文件模式有如下限制： 只可以对ofstream或fstream对象设定out模式。 只可以对ifstream或fstream对象设定in模式。 只有当out也被设定时才可设定trunc模式。 只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式被打开。 默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作（参见17.5.3节，第676页，将介绍对同一个文件既进行输入又进行输出的方法）。 ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。 每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。 以out模式打开文件会丢弃已有数据 保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式。 每次调用open时都会确定文件模式 对于一个给定流，每当打开文件时，都可以改变其文件模式。 8.3 string流istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream既可从string读数据也可向string写数据。 除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。 8.3.1 使用istringstream当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。 8.3.2 使用ostringstream当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。","link":"/2024/09/22/C-C-Primer-Chapter-8/"},{"title":"[C++]C++Primer Chapter 7","text":"类 类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程（以及设计）技术。 类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。 类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。 7.1 定义抽象数据类型7.1.1 设计Sales_data类由于14.1节（第490页）将要解释的原因，执行加法和IO的函数不作为Sales_data的成员，相反的，我们将其定义成普通函数；执行复合赋值运算的函数是成员函数。 7.1.2 定义改进的Sales_data类引入this this是一个常量指针，指向“这个”对象。 引入const成员函数 把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。 类作用域和成员函数 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。 在类的外部定义成员函数 定义一个返回this对象的函数 内置的赋值运算符把它的左侧运算对象当成左值返回（参见4.4节，第129页），因此为了与它保持一致，combine函数（重载赋值运算符）必须返回引用类型（参见6.3.2节，第202页）。因为此时的左侧运算对象是一个Sales_data的对象，所以返回类型应该是Sales_data&amp;。 7.1.3 定义类相关的非成员函数我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来（参见6.1.2节，第168页）。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。 定义read和print函数 第一点，read和print分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能被拷贝的类型，因此我们只能通过引用来传递它们（参见6.2.2节，第188页）。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。 第二点，print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。 定义add函数 7.1.4 构造函数每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数（constructor）。 不同于其他成员函数，构造函数不能被声明成const的（参见7.1.2节，第231页）。 合成的默认构造函数 类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数（default constructor）。默认构造函数无须任何实参。 如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员： 如果存在类内的初始值（参见2.6.1节，第64页），用它来初始化成员。 否则，默认初始化（参见2.2.1节，第40页）该成员。 某些类不能依赖于合成的默认构造函数 只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。 如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。 如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。 = default的含义 在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数。其中，= default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果= default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。 构造函数初始值列表 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。 7.1.5 拷贝、赋值和析构7.2 访问控制与封装在C++语言中，我们使用访问说明符（access specifiers）加强类的封装性 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。 7.2.1 友元类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。 一般来说，最好在类定义开始或结束前的位置集中声明友元。 关键概念：封装的益处 封装有两个重要的优点： 确保用户代码不会无意间破坏封装对象的状态。 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。 友元的声明 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。 为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。 7.3 类的其他特性7.3.1 类成员再探除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。用来定义类型的成员必须先定义后使用。 令成员作为内联函数 我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，最好只在类外部定义的地方说明inline，这样可以使类更容易理解。 inline成员函数也应该与相应的类定义在同一个头文件中。 重载成员函数 可变数据成员 有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。 一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。 类数据成员的初始值 类内初始值必须使用=的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。 当我们提供一个类内初始值时，必须以符号=或者花括号表示。 7.3.2 返回*this的成员函数从const成员函数返回＊this 一个const成员函数如果以引用的形式返回＊this，那么它的返回类型将是常量引用。 基于const的重载 通过区分成员函数是否是const的，我们可以对其进行重载 建议：对于公共代码使用私有功能函数 7.3.3 类类型每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。 类的声明 我们也能仅仅声明类而暂时不定义它 这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。 一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针 7.3.4 友元再探类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。 类之间的友元关系 友元关系不存在传递性。 令成员函数作为友元 除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类 首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 接下来定义Screen，包括对于clear的友元声明。 最后定义clear，此时它才可以使用Screen的成员。 函数重载和友元 尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明 友元声明和作用域 类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中（参见7.2.1节，第241页）。 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的 友元声明的作用是影响访问权限，它本身并非普通意义上的声明。 7.4 类的作用域作用域和定义在类外部的成员 一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。 函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。 7.4.1 名字查找与类的作用域 编译器处理完类中的全部声明后才会处理成员函数的定义。 用于类成员声明的名字查找 这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。 类型名要特殊处理 一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。 成员定义中的普通块作用域的名字查找 成员函数中使用的名字按照如下方式解析： 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。 类作用域之后，在外围的作用域中查 尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符访问它。 7.5 构造函数再探7.5.1 构造函数初始值列表随着构造函数体一开始执行，初始化就完成了。 建议：使用构造函数初始值 在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。 成员初始化的顺序 构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。 成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。 最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。 默认实参和构造函数 7.5.2 委托构造函数C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。 当这些受委托的构造函数执行完后，接着执行istream&amp;构造函数体的内容。 7.5.3 默认构造函数的作用默认初始化在以下情况下发生： 当我们在块作用域内不使用任何初始值定义一个非静态变量（参见2.2.1节，第39页）或者数组时（参见3.5.1节，第101页）。 当一个类本身含有类类型的成员且使用合成的默认构造函数时（参见7.1.4节，第235页）。 当类类型的成员没有在构造函数初始值列表中显式地初始化时（参见7.1.4节，第237页）。 值初始化在以下情况下发生： 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时（参见3.5.1节，第101页）。 当我们不使用初始值定义一个局部静态变量时（参见6.1.1节，第185页）。 当我们通过书写形如T（ ）的表达式显式地请求值初始化时，其中T是类型名（vector的一个构造函数只接受一个实参用于说明vector大小（参见3.3.1节，第88页），它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。 7.5.4 隐式的类类型转换如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数（converting constructor）。 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。 只允许一步类类型转换 编译器只会自动地执行一步类型转换 抑制构造函数定义的隐式转换 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复 explicit构造函数只能用于直接初始化 发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=）（参见3.2.1节，第76页）。此时，我们只能使用直接初始化而不能使用explicit构造函数 为转换显式地使用构造函数 7.5.5 聚合类聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的： 所有成员都是public的。 没有定义任何构造函数。 没有类内初始值（参见2.6.1节，第64页）。 没有基类，也没有virtual函数 我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员 初始值的顺序必须与声明的顺序一致，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化（参见3.5.1节，第101页）。 7.5.6 字面值常量类数据成员都是字面值类型的聚合类（参见7.5.5节，第266页）是字面值常量类。 如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类： 数据成员都必须是字面值类型。 类必须至少含有一个constexpr构造函数。 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式（参见2.4.4节，第58页）；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。 类必须使用析构函数的默认定义，该成员负责销毁类的对象（参见7.1.5节，第239页）。 constexpr构造函数 尽管构造函数不能是const的（参见7.1.4节，第235页），但是字面值常量类的构造函数可以是constexpr（参见6.5.2节，第213页）函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。 constexpr构造函数可以声明成= default（参见7.1.4节，第237页）的形式（或者是删除函数的形式，我们将在13.1.6节（第449页）介绍相关知识）。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句（参见6.5.2节，第214页））。综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数了 constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型 7.6 类的静态成员声明静态成员 我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。 静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。 使用类的静态成员 使用作用域运算符直接访问静态成员。 定义静态成员 当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。 要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。 静态成员的类内初始化 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr（参见7.5.6节，第267页）。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 静态成员能用于某些场景，而普通成员不能 静态数据成员可以是不完全类型（参见7.3.3节，第249页）。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用 静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参","link":"/2024/09/22/C-C-Primer-Chapter-7/"},{"title":"[C++]C++Primer Chapter 9","text":"顺序容器 一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的，我们将在第11章介绍的有序和无序关联容器，则根据关键字的值来存储元素。 9.1 顺序容器概述表9.1列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中： 向容器添加或从容器中删除元素的代价 非顺序访问容器中元素的代价 1.string和vector 将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时 2.list和forward_list 何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问。与vector、deque和array相比，这两个容器的额外内存开销也很大。 3.deque 与string和vector类似，deque支持快速的随机访问。与string和vector一样，在deque的中间位置添加或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的，与list或forward_list添加删除元素的速度相当。 4.forward_list和array是新C++标准增加的类型。 与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。 forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。 对其他容器而言，size保证是一个快速的常量时间的操作。 新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。 确定使用哪种顺序容器 以下是一些选择容器的基本原则： 除非你有很好的理由选择其他容器，否则应使用vector。 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。 如果程序要求随机访问元素，应使用vector或deque。 如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。 如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。 如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数（我们将在10.2.3节介绍sort（第343页））来重排容器中的元素，从而避免在中间位置添加元素。 如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。 如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那该怎么办？答案取决于在list或forward_list中访问元素与vector或deque中插入/删除元素的相对性能。一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入/删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。 9.2 容器库概览容器类型上的操作形成了一种层次： 某些操作是所有容器类型都提供的（参见表9.2，第295页）。 另外一些操作仅针对顺序容器（参见表9.3，第299页）、关联容器（参见表11.7，第388页）或无序容器（参见表11.8，第395页）。 还有一些操作只适用于一小部分容器。 本节介绍对所有容器都适用的操作。 对容器可以保存的元素类型的限制 但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。 9.2.1 迭代器迭代器范围 这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为 使用左闭合范围蕴含的编程假定 如果begin与end相等，则范围为空 如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素 我们可以对begin递增若干次，使得begin==end 9.2.2 容器类型成员 9.2.3 begin和end成员 当不需要写访问时，应使用cbegin和cend。 9.2.4 容器定义和初始化 将一个容器初始化为另一个容器的拷贝 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换（参见4.11节，第141页）为要初始化的容器的元素类型即可。 列表初始化 与顺序容器大小相关的构造函数 顺序容器（array除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器（参见3.3.1节，第88页) 只有顺序容器的构造函数才接受大小参数，关联容器并不支持。 标准库array具有固定大小 与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小 与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化（参见2.2.1节，第40页），就像一个内置数组（参见3.5.1节，第102页）中的元素那样。如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小。如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余元素都会进行值初始化（参见3.3.1节，第88页）。 值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作（参见3.5.1节，第102页），但array并无此限制 9.2.5 赋值和swap 使用assign（仅顺序容器） 顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。 assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素。 使用swap swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换 除array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个容器的内部数据结构。 除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。 元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。 与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。 与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。 在新标准库中，容器既提供成员函数版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个好习惯。 9.2.6 容器大小操作成员函数size（参见3.2.2节，第78页）返回容器中元素的数目； empty当size为0时返回布尔值true，否则返回false； max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。 forward_list支持max_size和empty，但不支持size 9.2.7 关系运算符每个容器类型都支持相等运算符（==和！=）；除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。 比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算（参见3.2.2节，第79页）类似 容器的关系运算符使用元素的关系运算符完成比较 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。 9.3 顺序容器操作9.3.1 向顺序容器添加元素 使用push_back 除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。 关键概念：容器元素是拷贝 当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数（参见3.2.2节，第79页）一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。 使用push_front list、forward_list和deque容器还支持名为push_front的类似操作。 注意，deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间。 在容器中的特定位置添加元素 insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员，我们将在9.3.4节（第312页）中介绍。 每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，所以insert函数将元素插入到迭代器所指定的位置之前。 插入范围内元素 接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化 接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前 如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。 在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。（在旧版本的标准库中，这些操作返回void。）如果范围为空，不插入任何元素，insert操作会将第一个参数返回。 使用insert的返回值 通过使用insert的返回值，可以在容器中一个特定位置反复插入元素 使用emplace操作 当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。 emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。 9.3.2 访问元素如果容器中没有元素，访问操作的结果是未定义的。 访问成员函数返回的是引用 如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。 下标操作和安全的随机访问 如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常（参见5.6节，第173页） 9.3.3 删除元素 删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它（们）是存在的。 pop_front和pop_back成员函数 这些操作返回void。如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它 从容器内部删除一个元素 两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。 删除多个元素 9.3.4 特殊的forward_list操作forward_list并未定义insert、emplace和erase，而是定义了名为insert_after、emplace_after和erase_after的操作 forward_list也定义了before_begin，它返回一个首前（off-the-beginning）迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。 9.3.5 改变容器大小我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部 resize操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化（参见3.3.1节，第88页）。 9.3.6 容器操作可能使迭代器失效在向容器添加元素后： 如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。 对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。 对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。 当我们删除一个元素后： 对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。 对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。 对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。 建议：管理迭代器 当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。 由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector、string和deque尤为重要。 编写改变容器的循环程序 添加/删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新 不要保存end返回的迭代器 当我们添加/删除vector或string的元素后，或在deque中首元素之外任何位置添加/删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当作容器末尾使用。通常C++标准库的实现中end（）操作都很快，部分就是因为这个原因。 9.4 vector对象是如何增长的当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。 管理容量的成员函数 只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。 如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。 如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。 因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。这样，调用reserve永远也不会减少容器占用的内存空间。 类似的，resize成员函数（参见9.3.5节，第314页）只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。 在新标准库中，我们可以调用shrink_to_fit来要求deque、vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。 capacity和size 虽然不同的实现可以采用不同的分配策略，但所有实现都应遵循一个原则：确保用push_back向vector添加元素的操作有高效率。从技术角度说，就是通过在一个初始为空的vector上调用n次push_back来创建一个n个元素的vector，所花费的时间不能超过n的常数倍。 9.5 额外的string操作后面用到的时候再来查 9.5.1 构造string的其他方法 substr操作 substr操作（参见表9.12）返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substr一个可选的开始位置和计数值 如果开始位置超过了string的大小，则substr函数抛出一个out_of_range异常（参见5.6节，第173页）。如果开始位置加上计数值大于string的大小，则substr会调整计数值，只拷贝到string的末尾。 9.5.2 改变string的其他方法除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到给定值之前的位置 append和replace函数 改变string的多种重载函数 9.5.3 string搜索操作string类提供了6个不同的搜索函数，每个函数都有4个重载版本。表9.14描述了这些搜索成员函数及其参数。每个搜索操作都返回一个string：：size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string：：npos的static成员（参见7.6节，第268页）。标准库将npos定义为一个const string：：size_type类型，并初始化为值-1。由于npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可能大小（参见2.1.2节，第32页）。 9.5.4 compare函数 9.5.5 数值转换新标准引入了多个函数，可以实现数值数据与标准库string之间的转换 要转换为数值的string中第一个非空白符必须是数值中可能出现的字符 string参数中第一个非空白符必须是符号（+ 或 -）或数字。它可以以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函数，string参数也可以以小数点（.）开头，并可以包含e或E来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，string参数可以包含字母字符，对应大于数字9的数。 如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常（参见5.6节，第173页）。如果转换得到的数值无法用任何类型来表示，则抛出一个out_of_range异常。 9.6 容器适配器除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。适配器（adaptor）是标准库中的一个通用概念。容器、迭代器和函数都有适配器。 本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list外），并使其操作起来像一个stack一样。 定义一个适配器 每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。 默认情况下，stack和queue是基于deque实现的，priority_queue是在vector之上实现的。 我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。 对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用forward_list来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力。 stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack。 queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。 priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。 栈适配器 stack类型定义在stack头文件中。表9.18列出了stack所支持的操作。 队列适配器 queue和priority_queue适配器定义在queue头文件中。","link":"/2024/09/22/C-C-Primer-Chapter-9/"},{"title":"[C++] 返回值优化","text":"什么是返回值优化？返回值优化（Return Value Optimization, RVO）是C++编译器的一种优化技术，用于减少不必要的对象拷贝，特别是在函数返回临时对象的场景中。RVO 可以显著提高程序性能，并减少临时对象的生成和析构操作。 在C++中，函数返回值通常会涉及临时对象的创建和销毁。例如，当函数返回一个对象时，通常会创建一个临时对象来存储返回值，然后将其拷贝到接收返回值的变量中。返回值优化（RVO）是编译器的一种优化技术，它避免了这些临时对象的拷贝操作。 RVO的工作机制通常情况下，返回一个对象的过程涉及两步： 创建并初始化一个临时对象（可能是函数内的局部对象）。 将这个临时对象拷贝或移动到调用者提供的目标位置。 RVO通过直接在目标位置构造返回的对象，跳过了临时对象的创建，从而避免了拷贝或移动操作。 例子（无RVO vs. 有RVO）没有RVO时：123456789101112131415class MyClass {public: MyClass() { std::cout &lt;&lt; &quot;Constructor&quot; &lt;&lt; std::endl; } MyClass(const MyClass&amp;) { std::cout &lt;&lt; &quot;Copy Constructor&quot; &lt;&lt; std::endl; } ~MyClass() { std::cout &lt;&lt; &quot;Destructor&quot; &lt;&lt; std::endl; }};MyClass createObject() { MyClass obj; return obj; // 返回局部对象，会调用拷贝构造函数}int main() { MyClass newObj = createObject(); // 接收返回值，会再次拷贝} 在上述代码中，createObject()函数返回一个局部对象 obj，在没有RVO的情况下： 首先构造局部对象 obj。 然后调用拷贝构造函数将 obj拷贝到一个临时对象（用来保存返回值）。 最后将这个临时对象拷贝到 newObj中。 因此，会涉及两次拷贝构造调用，这样的拷贝是性能上的浪费。 有RVO时：12345678MyClass createObject() { MyClass obj; return obj; // RVO优化，直接在返回位置构造}int main() { MyClass newObj = createObject(); // 直接在newObj上构造对象，无需拷贝} 在启用RVO的情况下，编译器会跳过临时对象的创建，直接在 newObj的内存位置上构造 obj，避免了不必要的拷贝操作。 RVO的类型 命名返回值优化（Named Return Value Optimization, NRVO）：NRVO是RVO的一种形式，发生在返回值是命名的局部变量时。例如，函数返回一个命名的局部对象，编译器会直接在调用者的内存空间中构造该对象，而不是先创建一个临时对象。 标准RVO：标准RVO发生在返回一个未命名的临时对象时。例如，函数返回一个临时构造的对象，而不是局部变量。这种优化在C++17后是强制执行的，不再依赖于编译器是否选择进行优化。 C++17 中的强制RVO从C++17开始，标准RVO成为强制行为，编译器必须执行返回值优化，不再需要拷贝或移动临时对象。例如： 123MyClass createObject() { return MyClass(); // C++17中，直接在返回位置构造对象} 在C++17之前，编译器可能会选择不进行优化，但从C++17开始，编译器必须直接在目标位置构造返回的对象，从而完全消除了临时对象和拷贝构造的开销。 总结 RVO（返回值优化）是一种编译器优化技术，可以在函数返回对象时避免不必要的临时对象拷贝。 NRVO（命名返回值优化）是RVO的一种形式，应用于返回命名的局部变量。 C++17中强制执行了RVO，编译器必须优化返回临时对象的场景，进一步提高了程序效率。","link":"/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"},{"title":"[MIT 6.1810]Xv6 Chapter 1","text":"Operating system interfaces 操作系统的工作是： 在多个程序间共享一台电脑 提供一套比硬件更有用的服务 操作系统： 管理并抽象底层硬件 在多个程序间共享硬件 提供一种受控的程序交互方式 操作系统是通过接口来向程序提供服务的。 每个进程（运行中的程序），都有指令、数据、栈。 进程通过系统调用（system call）来使用操作系统提供的服务。 1.1 Processes and memory进程由用户空间的内存（指令、数据、栈）和一些状态组成。xv6是分时操作系统，每个进程都有一个唯一的PID来标识。 fork 系统调用 fork系统调用完全复制调用者的内存给新进程，然后在原进程和新进程中返回，原进程中返回值为新进程的PID，新进程中的返回值为0。 需要注意的是，父子进程之间的内存空间是相互独立的，即每个进程都有一份自己的拷贝。 wait 系统调用 wait系统调用返回当前进程的一个退出的子进程的PID，并且将子进程的退出状态拷贝到指定内存中。如果没有退出的子进程，wait阻塞等待。如果当前进程没有子进程，wait立即返回-1。如果不关心子进程的退出状态，可以传入一个0地址。 exec系统调用 exec系统调用负责用存储在文件系统中的可执行文件加载新的内存镜像，替换调用进程的内存。这个可执行文件必须遵循特定格式，定义了文件的各个部分，例如哪些部分包含指令和数据，以及从哪个指令开始执行。在 xv6 中，使用的是 ELF（可执行与可链接格式），详见第三章。 通常，这个可执行文件是通过编译程序源代码生成的。当 exec 成功调用时，控制权不会返回到原程序，而是从 ELF 头部指定的入口点开始执行新加载的指令。exec 需要两个参数：可执行文件的名称和一个字符串数组，包含传递给新进程的参数。大多数程序通常会忽略掉字符串数组的第一个参数，一般是程序的名字。 为什么 fork 和 exec 是分离的 操作系统利用这种分离机制实现IO重定向。同时，为了避免创建一个子进程然后马上调用 exec 调换掉内存，操作系统通过虚拟内存的一些技巧来优化，例如copy on write。 申请内存 xv6大多数时候隐式申请用户空间的内存，但是进程也可以通过调用 sbrk(n) 来申请更多的内存空间，该函数返回申请内存的起始地址。 1.2 I/O and File descriptors文件描述符是一个整数，代表着一个内核管理的object，进程可以从这个object读，或向这个object写。 一个进程可以通过 打开文件、目录、设别 创建管道； duplicating一个文件描述符 来获得文件描述符。 文件描述符这种抽象使得我们可以不用关注文件的种类，无论是文件、管道、设备，我们都将他们视为字节流来处理。 内部，xv6内核将文件描述符用作每个进程的打开文件表的索引。通常，一个进程从文件描述符0读取输入（标准输入），向文件描述符1输出（标准输出），将错误信息输出到文件描述符2（标准错误）。 read(fd, buf, n) 系统调用 该系统调用从fd指向的object读取至多n个字节，拷贝到buf内，并返回读取的字节数。 每个文件描述符都有一个关联的偏移量，read 会更新这个偏移量，指向下一个未被读取的字节。 当没有更多的字节可读时，read 会返回0。 write(fd, buf, n) 系统调用 该系统调用向fd写n个字节，返回实际写入的字节数。只有当错误发生的时候，实际写入的字节数才不等于n。 close(fd) 系统调用 该系统调用释放一个文件描述符，使之可以为之后的文件使用。 一个新的文件描述符总是当前进程中最小的未使用的文件描述符。 fork 和文件描述符 fork 会将父进程的打开文件表复制给子进程，子进程和父进程的打开文件是一样的。 exec 会替换调用进程的内存，但是会保留打开文件表。 这种行为使得shell可以简单的实现IO重定向。 cat &lt; input.txt 的简单实现 12345678910char *argv[2];argv[0] = &quot;cat&quot;;argv[1] = 0;if (fork() == 0){ // child close(0); open(&quot;input.txt&quot;, O_RDONLY); exec(&quot;/bin/cat&quot;, argv);} 关键点是子进程先关闭了文件描述符0，然后再打开input.txt，这是操作系统会将文件描述符0分配给这个文件。 父进程的文件描述符并不会被改变，因为子进程有一张自己的打开文件表。 需要注意的是，虽然fork会复制打开文件表，但是每个文件描述符关联的偏移在父子进程间是共享的。 open 系统调用 该系统调用打开一个文件，并返回相应的文件描述符。 第二个参数可以是(kerenl/fcntl.h)： O_RDONLY O_WRONLY O_RDWR O_CREATE O_TRUNC dup(fd) 系统调用 该系统调用复制一个文件描述符，返回一个指向相同object的文件描述符。这两个文件描述符共享偏移，类似fork。 Two file descriptors share an offset if they were derived from the same original file descriptor by a sequence of fork and dup calls. Otherwise file descriptors do not share offsets, even if they resulted from open calls for the same file 通过 fork 和 dup 获得的文件描述符和都共享相同的偏移。 1.3 Pipes管道是内核中的一个小缓冲区，通过一对文件描述符暴露给进程。这是进程间通信的一种方式。 pipe 系统调用 该系统调用创建一个新的管道，并将一对文件描述符放到参数指定的整数数组中。 如果没有可读数据，读一个管道可能会： 阻塞直到数据到来 阻塞直到所有对管道写端的文件描述符被关闭 第二种情况会返回0。 管道相较临时文件的优势： 管道会自动清理 管道可以处理任意长度的数据，而临时文件必须要求硬盘有足够的空间 管道允许管道的不同阶段并行执行 1.4 File systemxv6文件系统提供数据文件，包含字节流；提供目录，包含指向数据文件和其他目录文件的引用。 目录以树的形式组织，以/开始的路径以根目录为根，不以/开始的路径以当前进程当前的工作目录为根（可以通过chdir系统调用来改变）。 mkdir 系统调用创建一个新的目录，open 系统调用通过指定 O_CREATE 选项来创建一个新的数据文件， mknode 系统调用创建一个新的设备文件。该系统调用通过两个参数来唯一标识一个内核设备（主、副设备号）。 文件名和文件本身是不同的。同一个文件由一个唯一的inode来标识；同一个文件可以有多个文件名，即链接。 每个链接由一个目录中的目录项组成，这个目录项包含一个文件名以及一个指向文件inode的指针。 每个inode保存着文件的元数据，包括种类，长度，磁盘位置，以及链接数等。 fstat 系统调用 该系统调用从inode中获取文件的元数据，并将数据填入 stat 结构体中。（kernel/stat.h） link 系统调用 该系统调用创建一个链接。读写该链接和读写原文件操作的是同一个文件。 unlink 系统调用 该系统调用删除一个链接。只有当指向同一个inode的所有链接都被删除的时候，才会真正释放inode和文件内容。 一种约定俗称的创建一个临时inode方法: 12fd = open(&quot;/tmp/xyz&quot;, O_CREATE | O_RDWR);unlink(&quot;/tmp/xyz&quot;); 当进程调用close或者退出后，这个inode会被自动清理。","link":"/2024/09/24/MIT-6-1810-Xv6-Chapter-1/"},{"title":"[MIT 6.1810]Xv6 Chapter 2","text":"Operating system organization 一个操作系统必须满足三个需求： 复用 隔离 交互 xv6是用LP64C写的（long和pointer是8B，int是4B）。 2.1 Abstracting physical resources通过抽象硬件资源，可以使操作系统方便的实现复用、隔离、交互。 2.2 User mode，supervisor mode，and system calls隔离需要应用程序和操作系统之间有一条硬边界。 为了实现这种隔离，操作系统必须使进程不能访问操作系统的指令和数据，也不能访问其他进程的指令和数据。 CPU为这种隔离提供了硬件支持。RISC-V有三种指令执行模式：机器模式（machine mode）、内核模式（supervisor mode），用户模式（user mode）。 机器模式（machine mode） 该模式的指令有完整的特权。CPU初始启动的时候在该模式，然后在boot的过程中设置电脑，之后就会切换到内核模式。 内核模式（supervisor mode） 该模式下可以执行特权指令，例如开关中断、访问页表寄存器等。如果一个用户模式下的进程尝试执行特权指令，CPU不会执行，而是切换到内核模式，然后终止该进程。 应用想要执行内核中的函数必须切换到内核中执行，且不能直接执行内核函数，而是通过一种特殊的指令进入内核（RISV-V提供ecall指令），之后内核会去检查应用传进来的参数是否合法（例如内存是否越界，是否有权限执行这种操作等）。之所以用通过统一的指令来进入内核，是防止有的程序跳过参数检查等步骤。 2.3 Kernel organization设计的关键是操作系统的什么部分应该在内核模式下运行。 宏内核 一种方法是将整个操作系统放在内核中，称为宏内核。 宏内核的优点是不用决定哪部分放在内核；操作系统不同部分合作容易。缺点是系统十分复杂，错误通常会导致整个内核崩溃。 微内核 另一种方法是最小化内核的代码，将大部分系统功能实现在用户模式下，称为微内核。 在微内核模式下，操作系统的有些部分可以运行在用户模式的进程中，称为服务器（server）。操作系统提供一种进程间通信的方法，程序间通过互相发送消息来进行通信。 2.4 Code：xv6 organizationxv6 的内核源代码位于 kernel/ 子目录中，源代码被分为多个文件，遵循一定的模块化概念。图 2.2 列出了这些文件。模块之间的接口在 defs.h（即 kernel/defs.h）中定义。 2.5 Process overviewxv6中隔离的最小单元是进程。 内核实现进程的机制包括用户/特权模式标志、地址空间以及线程的时间片分配。 进程给程序提供了一种自己拥有整个地址空间和CPU的假象。 xv6 使用页表（由硬件实现）为每个进程提供独立的地址空间。RISC-V 页表将虚拟地址（RISC-V 指令操作的地址）转换为物理地址（CPU 发送到主内存的地址）。 xv6 为每个进程维护一个独立的页表，定义该进程的地址空间。如图 2.3 所示，地址空间从虚拟地址零开始，包括进程的用户内存。首先是指令，然后是全局变量，再是栈，最后是“堆”区域（用于 malloc），该区域可以根据需要扩展。限制进程地址空间最大大小的因素有很多：RISC-V 的指针宽度为 64 位，硬件在查找页表中的虚拟地址时仅使用低 39 位，而 xv6 只使用这 39 位中的 38 位。因此，最大地址为 (2^{38} - 1 = 0x3fffffffff)，也就是 MAXVA（定义在 kernel/riscv.h:378）。在地址空间的顶部，xv6 放置了一个 4096 字节的 trampoline 页和一个 trapframe 页。xv6 使用这两个页面进行内核的切换；trampoline 页包含切换进出内核的代码，而 trapframe 用于保存进程的用户寄存器，具体内容在第四章中解释。 内核为每个进程维护各自的状态，存放在proc结构体里（kernel/proc.h：85）。 每个进程都有一个控制线程（简称线程），它保存执行该进程所需的状态。在任何给定时刻，线程可能在 CPU 上执行，或者处于挂起状态（未执行但能够在未来恢复执行）。要在进程之间切换 CPU，内核会挂起当前在该 CPU 上运行的线程并保存其状态，然后恢复另一个进程之前挂起的线程的状态。线程的大部分状态（局部变量、函数调用的返回地址）存储在线程的栈上。 每个进程有两个栈：用户栈和内核栈（p-&gt;kstack）。当进程执行用户指令时，仅使用其用户栈，而内核栈为空。当进程进入内核（进行系统调用或中断）时，内核代码在进程的内核栈上执行；在进程处于内核状态时，其用户栈仍然保存着数据，但不再被主动使用。进程的线程在活跃使用用户栈和内核栈之间交替切换。内核栈是独立的（并且受到保护，防止用户代码破坏），以确保即使进程破坏了其用户栈，内核也能正常执行。 进程可以通过执行 RISC-V 的 ecall 指令来发起系统调用。此指令提升硬件特权级，并将程序计数器更改为内核定义的入口点。入口点的代码切换到进程的内核栈，并执行实现系统调用的内核指令。当系统调用完成时，内核切换回用户栈，并通过调用 sret 指令返回用户空间，这将降低硬件特权级，并在系统调用指令后继续执行用户指令。进程的线程可以在内核中“阻塞”，以等待 I/O 操作完成，并在 I/O 完成后从上次中断的地方恢复。 p-&gt;state 指示进程的状态，可能是已分配、准备运行、当前在 CPU 上运行、等待 I/O 或正在退出。 p-&gt;pagetable 保存进程的页表，格式符合 RISC-V 硬件的要求。xv6 使得分页硬件在执行进程的用户空间时使用 p-&gt;pagetable。进程的页表还记录了分配给该进程存储内存的物理页的地址。 总之，进程结合了两个设计理念：地址空间使进程拥有自己的内存的错觉，线程使进程拥有自己的 CPU 的错觉。在 xv6 中，进程由一个地址空间和一个线程组成。在实际的操作系统中，进程可能拥有多个线程，以利用多个 CPU。 2.6 Code：starting xv6，the first process and system call当RISC-V计算机上电后，首先会初始化硬件，然后执行一个存放在ROM中的boot loader。bool loader负责把xv6内核装载进内存中。然后，在机器模式下，CPU从_entry(kernel/entry.S:7)开始执行xv6。开始时页表装置被关闭，虚拟地址直接被映射到对应的物理地址。 loader将内核装在到物理地址0x80000000，之所以装载到这里，是因为0x0-0x80000000包含了IO设备。 _entry 中的指令设置了一个栈供xv6执行代码。xv6在 start.c （kernel/start.c：11）中声明了一个初始栈， stack0 。 _entry 中的指令将sp改为 stack0+4096 （栈顶）。之后 _entry 调用 start （kernel/start.c：15）。 start 执行一些只能在机器模式下执行的配置，然后转入内核模式。为了进入内核模式，RISC-V提供了指令 mret ，这条指令通常用来从内核模式到机器模式的调用返回。 start 并不上述的情况，我们可以通过手动设置使之好像是这种情况。在转入内核模式之前， start 还使时钟芯片产生时钟中断。之后执行 mret 指令，调转到 main 继续执行（kernel/main.c：11）。 main 首先初始化几个设别和子系统，然后通过调用 userinit （kernel/proc.c）来创建第一个用户进程。第一个进程执行一个用RISC-V汇编写的小程序，这个小程序执行了xv6中的第一个系统调用。这个小程序在initcode.S中，它实际执行了 exec(init, argv) 。 它将 exec 系统调用号（SYS_EXEC）load进寄存器a7，然后执行 ecall 指令重新进入内核。 内核在 syscall 中使用a7寄存器中的值去调用指定的系统调用，即 exec 。系统调用表（system call table）（kernel/syscall.c：107）将SYS_EXEC映射到系统调用 sys_exec 。之后 exec 会把内存和寄存器替换为 init （user/init.c：15）的内存镜像。 当内核完成 exec 调用后，会返回用户空间执行 init 函数。该函数首先创建一个新的控制台设备文件，并通过文件描述符 0、1 和 2 打开它。随后，init 在该控制台上启动 shell，至此，系统已经启动。","link":"/2024/09/24/MIT-6-1810-Xv6-Chapter-2/"},{"title":"[MIT 6.1810]Xv6 Chapter 3","text":"Page tables 3.1 Paging hardwareRISC-V的指令操控的是虚拟地址，而物理内存是按照物理地址索引的。页表硬件负责进行虚拟地址和物理地址的转换。 xv6运行在Sv39 RISC-V上，只使用64位虚拟地址的低39位。在这种情况下，页表逻辑上是一个2^27次方的页表项（Page table entrie，PTE）数组，每个PTE包含44位物理页码（Physical page number， PPN）和一些标识位。页表硬件将虚拟地址低39位的高27位作为页表索引，然后将取得的44位PPN作为高44位，虚拟地址的低12位作为页内偏移，获得一个56位的物理地址。 xv6中采取的是三级页表，第一级页表页的物理起始地址由satp寄存器保存，27位的高9位用来索引第一级页表，第一级页表页表项的PPN字段是第二级页表页的起始物理地址，27位的中间9位用来索引第二级页表，其页表项的PPN字段是第三级页表页的起始物理地址，27位的低9位用来索引第三级页表，其页表项的PPN字段是实际访问内存页的物理地址。每级页表页大小为一页，包含512个页表项。 在上述地址转换过程中，如果某个页表项不存在，都会引发一个页面错误异常（page fault exception），由内核负责处理这个异常。 采取这种多级页表的好处是节省了内存空间，用不到的页表页将不会占据空间；缺点是在地址转化的时候需要进行多次访问。以三级页表为例，首先需要访问第一级页表获取第二级页表的物理地址，然后需要访问第二级页表获取第三级页表的物理地址，再访问第三级页表获取实际物理页的物理地址，之后才能访问我们实际需要读取的数据。为了解决这个问题，CPU可以将一些页表项缓存到TLB（Translation Look-aside Buffer）中，这样，如果在TLB中命中，则直接可以拿到实际物理页的物理地址，不需要进行额外的访存操作。 xv6中和页表硬件相关的结构定义在（kernel/riscv.h）中。 每个CPU都有自己的satp寄存器，该寄存器指定了第一级页表的物理地址。 3.2 Kernel address spacexv6为每个进程维护一个页表，并且维护一个单独的页表指明内核地址空间。内核配置内存空间的布局使其可以访问物理内存和各种设备资源，如图3.3所示。内核内存布局用到的常量定义在kernel/memlayout.h里。 QEMU 模拟了一个计算机系统，物理内存（RAM）从物理地址 0x80000000 开始，至少延续到 0x88000000，称为 PHYSTOP。QEMU 还包含了 I/O 设备，比如磁盘接口。这些设备接口通过内存映射控制寄存器暴露给软件，这些寄存器位于物理地址空间的 0x80000000 之下。内核可以通过读取或写入这些特殊的物理地址与设备进行交互；这样的读写操作是与设备硬件直接通信，而不是与 RAM 进行交互。第 4 章将解释 xv6 如何与这些设备进行交互。 内核通过“直接映射”访问 RAM 和内存映射的设备寄存器，即将资源映射到与物理地址相同的虚拟地址。例如，内核本身位于虚拟地址空间和物理内存中的 KERNBASE=0x80000000 。直接映射简化了内核读取或写入物理内存的代码。 直接映射：在直接映射中，虚拟地址与物理地址相等，这意味着内核可以使用相同的地址来访问内存。这种方式使得内核在处理物理内存时更加简便，不需要额外的地址转换。 内存分配示例：例如，在 fork 系统调用中，当为子进程分配用户内存时，分配器返回的是物理内存地址。由于内核采用直接映射，fork 可以直接将这个物理地址作为虚拟地址使用，将父进程的用户内存内容复制到子进程中。这减少了需要进行地址转换的复杂性。 在内核的虚拟地址空间中，有几个地址并不是直接映射的，包括： Trampoline Page 映射位置：Trampoline 页位于虚拟地址空间的顶部，并且用户页面表也具有相同的映射。 作用：Trampoline 页用于实现上下文切换等功能。它的物理页面（存放 Trampoline 代码）在内核的虚拟地址空间中被映射了两次：一次在虚拟空间的顶部，另一次是直接映射的地址。 特点：这种设计展示了页面表的灵活使用，能够在需要时同时使用不同的映射。 Kernel Stack Pages 每个进程的内核栈：每个进程都有自己的内核栈，这些栈映射在高地址，以便在它们下面保留一个未映射的保护页（guard page）。 保护页：保护页的页表项（PTE）是无效的（即 PTE_V 没有设置），因此如果内核栈溢出，它将可能导致异常，从而引发内核恐慌（panic）。没有保护页的情况下，溢出的栈可能会覆盖其他内核内存，导致错误操作。 映射设计：内核通过高内存映射使用这些栈，但也可以通过直接映射的地址访问它们。如果只使用直接映射而不设置保护页，处理保护页将涉及取消映射原本指向物理内存的虚拟地址，这将变得难以使用。 权限设置 Trampoline 页和内核文本的映射：这些页面的权限设置为 PTE_R（可读）和 PTE_X（可执行），内核可以从这些页面读取和执行指令。 其他页面的映射：其他页面的权限设置为 PTE_R（可读）和 PTE_W（可写），允许内核读取和写入这些页面的内存。 保护页的映射：保护页的映射是无效的，以防止访问。 3.3 Code: creating an address spacexv6中大多数操控地址空间和页表的代码在vm.c中。 核心数据结构是 pagetable_t ，这是一个指向第一级页表的指针，它要么指向内核页表，要么指向进程自己的页表。 核心函数有： walk - 找到一个虚拟地址对应的PTE mappages - 为新的映射设立PTE 以kvm为前缀的函数操作内核页表；以uvm为前缀的函数操作进程页表；其它函数两者都可以操作。 在 xv6 操作系统中，copyout 和 copyin 函数用于将数据复制到用户虚拟地址和从用户虚拟地址复制数据，这些地址作为系统调用参数传入。这些函数在 vm.c 文件中实现，因为它们需要显式地转换这些地址以找到对应的物理内存。 内核的页表创建： 在启动序列的早期，main 函数调用 kvminit 来创建内核的页表。此调用发生在 xv6 启用分页之前，因此地址直接指向物理内存。 kvmmake 首先分配一页物理内存，用于存放根页面表。然后，它调用 kvmmap 安装内核所需的地址转换，包括内核的指令和数据、到 PHYSTOP 的物理内存，以及实际上是设备的内存范围。 分配内核栈： proc_mapstacks 为每个进程分配一个内核栈。它调用 kvmmap 将每个栈映射到由 KSTACK 生成的虚拟地址，这样可以为无效的栈保护页留出空间。 页面映射的安装： kvmmap 调用 mappages，将虚拟地址范围映射到相应的物理地址范围。对于范围内的每个虚拟地址，mappages 分别处理，并按页间隔进行映射。 对于每个需要映射的虚拟地址，mappages 调用 walk 找到该地址的页面表项（PTE）。然后，它初始化 PTE，以保存相关的物理页面编号、所需的权限（PTE_W、PTE_X 和/或 PTE_R），并设置 PTE_V 将 PTE 标记为有效。 PTE 查找 walk 函数：walk 函数模拟 RISC-V 的分页硬件，逐级查找虚拟地址的 PTE。它使用每级地址的 9 位虚拟地址索引相关的页面目录页。每一层中，它找到的是下一层页面目录页的 PTE，或者是最终页面的 PTE。 如果一级或二级页面目录页中的 PTE 无效，则所需的目录页尚未分配；如果 alloc 参数被设置，walk 将分配一个新的页面表页，并将其物理地址放入 PTE 中。它返回树中最低层的 PTE 地址。 物理内存与虚拟地址的直接映射 上述代码依赖于物理内存直接映射到内核虚拟地址空间。例如，当 walk 函数向下查找页面表时，它从 PTE 中提取下一层页面表的物理地址，然后将该地址用作虚拟地址以获取下一层的 PTE。所以必须保证是采用直接映射。 安装内核页表 main 调用 kvminithart 安装内核页面表。它将根页面表的物理地址写入 satp 寄存器。此后，CPU 将使用内核页面表进行地址转换。由于内核使用直接映射，下一条指令的虚拟地址将正确映射到对应的物理内存地址。 TLB 在 RISC-V CPU 中，页表项会被缓存到转换后备缓冲区（TLB）中。当 xv6 修改页表时，必须通知 CPU 使对应的 TLB 缓存条目失效。如果不这样做，TLB 可能会在后续使用旧的缓存映射，这可能会导致指向的物理页面被分配给其他进程，从而使一个进程能够访问或篡改另一个进程的内存。 TLB 失效机制 sfence.vma 指令： RISC-V 提供了 sfence.vma 指令，用于刷新当前 CPU 的 TLB。xv6 在 kvminithart 中重新加载 satp 寄存器后执行此指令，同时在切换到用户页面表的 Trampoline 代码中也会调用它（在 kernel/trampoline.S:89 处）。 确保旧表格的完整性： 在更改 satp 之前，也需要发出 sfence.vma 指令，以确保所有未完成的加载和存储操作已完成。这一等待过程确保先前对页表的更新完成，同时保证之前的加载和存储使用旧的页表，而不是新的。 地址空间标识符（ASIDs） 为了避免刷新整个 TLB，RISC-V CPU 可能支持地址空间标识符（ASIDs）。这样，内核可以仅刷新特定地址空间的 TLB 条目，而无需影响其他地址空间。 然而，xv6 并未使用这一特性，因此每次修改页表时仍需完全刷新 TLB。 3.4 Physical memory allocationxv6使用介于内核末尾和PHYSTOP直接的物理内存来进行运行时分配。通过页面链表来维护空闲页面，当分配的时候需要从链表中移除分配的页面，当释放的时候需要将页面添加到链表中。 3.5 Code：Physical memory allocator分配器代码在kalloc.c中。 分配器的数据结构是空闲页面的链表。链表中的元素是 struct run ，这些结构体保存在相应的空闲页面内。链表被一个自旋锁保护。 main 调用 kinit 来初始化这个分配器。 kinit 负责初始化链表，维护每个空闲页面。用到了 freerange 和 kfree。 3.6 Process address space每个进程都有自己的页表，进程切换的时候会更换页表。 内核在用户地址空间的顶部映射了一页包含 trampoline 代码的页面，该页面没有设置用户访问权限（PTE_U）。这样，虽然这页物理内存在所有地址空间中可见，但只有内核能够使用它。 共享页面： 这页物理内存被映射到每个用户进程的地址空间中，但由于没有用户访问权限，用户进程无法访问或修改该页。 内核的用途： 该页面的主要用途是在上下文切换时，内核可以通过 trampoline 代码快速切换到用户模式。这种设计简化了用户与内核之间的切换过程。 安全性： 通过限制用户访问这页内存，内核能够防止潜在的安全问题，确保用户进程无法干扰或篡改关键的内核代码。 3.7 Code：sbrk3.8 Code：exec","link":"/2024/09/25/MIT-6-1810-Xv6-Chapter-3/"}],"tags":[{"name":"MIT 6.S081","slug":"MIT-6-S081","link":"/tags/MIT-6-S081/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"MIT 6.1810","slug":"MIT-6-1810","link":"/tags/MIT-6-1810/"}],"categories":[{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"pages":[{"title":"categories","text":"","link":"/categories/index.html"}]}