{"posts":[{"title":"[MIT 6.S081]Lab1 Xv6 and Unix utilities","text":"1 通过gdb调试参考链接 Homework: running and debugging xv6 (archive.org) MIT 6.S081 xv6调试不完全指北 - KatyuMarisa - 博客园 (cnblogs.com) GDB-cheat-sheet.pdf (gabriellesc.github.io) 2 sleep（easy） 结果如下： 3 pingpong(easy) 本题考查的是管道通信相关内容的理解。 If no data is available, a read on a pipe waits for either data to be written or for all file descriptors referring to the write end to be closed; in the latter case, read will return 1, just as if the end of a data file had been reached. xv6书中指出，read会一直阻塞直到有数据被写入管道或者所有指向管道写端的文件描述符都被关闭。 一种简单的实现是创建两个管道，一个管道的流向为父进程到子进程，另外一个的流向为子进程到父进程。 另外一种实现只需要创建一个管道，但是由于父子进程读写的都是同一个管道，需要通过wait来同步父子进程读写的顺序，防止出现死锁的情况。代码如下，注意55行的 wait((int*)0)，父进程一定要等待子进程退出后，才可以从管道中读取数据，否则可能会出现父进程自写自读的情况，导致子进程阻塞在21行处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]){ int p[2]; pipe(p); int pid = fork(); if (pid &lt; 0) { // fork failed fprintf(2, &quot;fork failure\\n&quot;); exit(1); } char buf = '1'; if (pid == 0) { // child pid = getpid(); // acquire the pid of the child process // read a byte from pipe if (read(p[0], &amp;buf, sizeof(buf)) != 1) { fprintf(2, &quot;child process read failed\\n&quot;); close(p[0]); close(p[1]); exit(1); } close(p[0]); printf(&quot;%d: received ping\\n&quot;, pid); // write a byte to pipe if (write(p[1], &amp;buf, sizeof(buf)) != 1) { fprintf(2, &quot;child process write failed\\n&quot;); close(p[1]); exit(1); } close(p[1]); exit(0); } else { // father pid = getpid(); // acquire the pid of the parent process // write a byte to pipe if (write(p[1], &amp;buf, sizeof(buf)) != 1) { close(p[0]); close(p[1]); fprintf(2, &quot;parent process write failed\\n&quot;); wait((int*)0); exit(1); } close(p[1]); wait((int*)0); // read a byte from pipe if (read(p[0], &amp;buf, sizeof(buf)) != 1) { close(p[0]); fprintf(2, &quot;father process read failed\\n&quot;); exit(1); } close(p[0]); printf(&quot;%d:received pong\\n&quot;, pid); exit(0); }} 结果如下 4 primes (moderate)/(hard) 这道题目考察的是利用 fork 进行多进程编程。 重点是理解下面的图和伪代码。本题用到了一种编程思想（Bell Labs and CSP Threads (swtch.com)），通过未缓冲的命名的通道来同时进行通信和同步。因为管道未缓冲，所以可以通过读写阻塞来进行同步。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]){ int left[2]; int right[2]; int start = 2; int end = 35; pipe(left); int pid = fork(); if (pid &lt; 0) { fprintf(2, &quot;fork failed pid = &lt;%d&gt;\\n&quot;, getpid()); close(left[0]); close(left[1]); exit(1); } if (pid == 0) { // child close(left[1]); } else { // parent close(left[0]); for (int num = start; num &lt;= end; ++num) { if (write(left[1], &amp;num, sizeof(int)) != sizeof(int)) { fprintf(2, &quot;write failed pid = &lt;%d&gt;\\n&quot;, getpid()); close(left[1]); wait((int*)0); exit(1); } } close(left[1]); wait((int*)0); // waits for its child to exit exit(0); } int num, prime, ret_r = 0, ret_w = sizeof(int); // if there is any number in the left pipe // the first number must be a prime while ((ret_r = read(left[0], &amp;prime, sizeof(int))) == sizeof(int)) { printf(&quot;primes %d\\n&quot;, prime); // if there is still any number in the left pipe if ((ret_r = read(left[0], &amp;num, sizeof(int))) == sizeof(int)) { pipe(right); if ((pid = fork()) == 0) { // child // the parent's right is the child's left // note that the sequence of the next 4 lines cannot be changed // first close the read end of the left pipe // cuz it is the parent's left pipe which the child doesn't need close(left[0]); // then change the child's left to its right pipe // cuz the right pipe right now is the parent's right pipe // which is also the child's left pipe left[0] = right[0]; left[1] = right[1]; // close the write end of the left pipe close(left[1]); // continue the loop continue; } else if (pid &lt; 0) { fprintf(2, &quot;fork failed pid = &lt;%d&gt;\\n&quot;, getpid()); close(right[0]); close(right[1]); close(left[0]); exit(1); } else { // parent close(right[0]); do { if (num % prime == 0) continue; else if ((ret_w = write(right[1], &amp;num, sizeof(int))) == sizeof(int)) continue; else { fprintf(2, &quot;write failed pid = &lt;%d&gt;\\n&quot;, getpid()); break; } } while((ret_r = read(left[0], &amp;num, sizeof(int))) == sizeof(int)); close(left[0]); close(right[1]); wait((int*)0); if (ret_r) fprintf(2, &quot;read failed pid = &lt;%d&gt;\\n&quot;, getpid()); ret_r == 0 &amp;&amp; ret_w == sizeof(int) ? exit(0) : exit(1); } } else break; } // only the last process in the pipeline will excute here close(left[0]); if (ret_r) fprintf(2, &quot;read failed pid = &lt;%d&gt;\\n&quot;, getpid()); ret_r == 0 ? exit(0) : exit(1);} 结果如下： 5 find (moderate) 这道题目考察的是对xv6文件系统的理解，比较简单，参考 user/ls.c 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;#include &quot;kernel/fcntl.h&quot;void find(char *dir, char* file){ char buf[512], *p; if (strlen(dir) + 1 + DIRSIZ + 1 &gt; sizeof buf) { fprintf(2, &quot;find: path too long\\n&quot;); return; } int fd; struct dirent de; struct stat st; if ((fd = open(dir, O_RDONLY)) &lt; 0) { fprintf(2, &quot;find: cannot open %s\\n&quot;, dir); return; } if (fstat(fd, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, dir); close(fd); return; } if (st.type != T_DIR) { fprintf(2, &quot;find: %s is not a directory\\n&quot;, dir); fprintf(2, &quot;Usage: find [directory] &lt;filename&gt;\\n&quot;); close(fd); return; } strcpy(buf, dir); p = buf + strlen(dir); *p++ = '/'; while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) { // skip invalid dir entry if (de.inum == 0 || strcmp(de.name, &quot;.&quot;) == 0 || strcmp(de.name, &quot;..&quot;) == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if (strcmp(de.name, file) == 0) printf(&quot;%s\\n&quot;, buf); if (stat(buf, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, buf); continue; } if (st.type == T_DIR) find(buf, file); } close(fd); return;}int main(int argc, char *argv[]){ if (argc != 2 &amp;&amp; argc != 3) { fprintf(2, &quot;Usage: find [directory] &lt;filename&gt;\\n&quot;); exit(1); } if (argc == 2) find(&quot;.&quot;, argv[1]); else find(argv[1], argv[2]); exit(0);} 结果如下： 6 xargs (moderate) 这道题目的难点主要在于对c语言数组的处理。 大致思路如下： 1.首先将xargs的参数拷贝到数组的前段。 2.然后从标准输入读取一行的内容作为额外参数拼接到数组后面，这里我们一行的内容只作为一个参数处理。 3.fork一个子进程出来调用exec执行命令 4.父进程调用wait等待子进程执行完毕，之后跳转到2继续执行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &quot;kernel/param.h&quot;#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]){ char buf[256]; char *cmd[MAXARG + 5]; int args_cnter = 1; if (argc == 1) { // 默认使用echo命令 cmd[1] = &quot;echo&quot;; args_cnter = 2; } for (; args_cnter &lt; argc; ++args_cnter) { // 将参数拷贝到命令数组中 // shallow copy cmd[args_cnter] = argv[args_cnter]; } // b - 每次读取的起始位置 // e - 每次读取完成后的最后有效位的下一位 // r - 每次读取了多少字节 // s - 每行参数的起始 // 每次将数据读取到buf[b, e)中 buf[0, b)为上次未处理完的内容 int b = 0, e = 0, r = 0, s; while ((r = read(0, buf + b, 256 - b)) &gt; 0) { e = b + r; s = 0; for (int i = 0; i &lt; e; ++i) { // 如果遇到了换行符 if (buf[i] == '\\n') { // 将参数拷贝到数组中 // deep copy buf[i] = 0; char *p = (char*) malloc(i - s + 1); if (!p) { fprintf(2, &quot;malloc failed\\n&quot;); exit(1); } memmove(p, buf + s, i - s + 1); cmd[args_cnter++] = p; // 更新s s = i + 1; if (fork() == 0) { // child cmd[args_cnter] = 0; if (exec(cmd[1], cmd + 1) &lt; 0) { fprintf(2, &quot;exec failed&quot;); exit(1); } } else { // parent wait((int*)0); free(cmd[--args_cnter]); } } } // 将未处理完的内容移动到数组首部 memmove(buf, buf + s, e - s); b = e - s; } if (r &lt; 0) { fprintf(2, &quot;read failed\\n&quot;); exit(1); } exit(0);} 结果如下： 7 测试结果 8 uptime（easy） 123456789#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]){ printf(&quot;uptime&lt;%d&gt;\\n&quot;, uptime()); exit(0);} 9 improve find（easy） 这道题目直接参考grep.c，把其中正则表达式匹配的代码拿过来，修改find中判断匹配的条件即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;#include &quot;kernel/fcntl.h&quot;int match(char*, char*);void find(char *dir, char* pattern){ char buf[512], *p; if (strlen(dir) + 1 + DIRSIZ + 1 &gt; sizeof buf) { fprintf(2, &quot;find: path too long\\n&quot;); return; } int fd; struct dirent de; struct stat st; if ((fd = open(dir, O_RDONLY)) &lt; 0) { fprintf(2, &quot;find: cannot open %s\\n&quot;, dir); return; } if (fstat(fd, &amp;st) &lt; 0) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, dir); close(fd); return; } if (st.type != T_DIR) { fprintf(2, &quot;find: %s is not a directory\\n&quot;, dir); fprintf(2, &quot;Usage: find [directory] &lt;pattern&gt;\\n&quot;); close(fd); return; } strcpy(buf, dir); p = buf + strlen(dir); *p++ = '/'; while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) { // skip invalid dir entry if (de.inum == 0 || strcmp(de.name, &quot;.&quot;) == 0 || strcmp(de.name, &quot;..&quot;) == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; // if (strcmp(de.name, file) == 0) // printf(&quot;%s\\n&quot;, buf); if (match(pattern, de.name)) printf(&quot;%s\\n&quot;, buf); if (stat(buf, &amp;st) &lt; 1) { fprintf(2, &quot;find: cannot stat %s\\n&quot;, buf); continue; } if (st.type == T_DIR) find(buf, pattern); } close(fd); return;}int main(int argc, char *argv[]){ if (argc != 2 &amp;&amp; argc != 3) { fprintf(2, &quot;Usage: find [directory] &lt;pattern&gt;\\n&quot;); exit(1); } if (argc == 2) find(&quot;.&quot;, argv[1]); else find(argv[1], argv[2]); exit(0);}// Regexp matcher from Kernighan &amp; Pike,// The Practice of Programming, Chapter 9.int matchhere(char*, char*);int matchstar(int, char*, char*);intmatch(char *re, char *text){ if(re[0] == '^') return matchhere(re+1, text); do{ // must look at empty string if(matchhere(re, text)) return 1; }while(*text++ != '\\0'); return 0;}// matchhere: search for re at beginning of textint matchhere(char *re, char *text){ if(re[0] == '\\0') return 1; if(re[1] == '*') return matchstar(re[0], re+2, text); if(re[0] == '$' &amp;&amp; re[1] == '\\0') return *text == '\\0'; if(*text!='\\0' &amp;&amp; (re[0]=='.' || re[0]==*text)) return matchhere(re+1, text+1); return 0;}// matchstar: search for c*re at beginning of textint matchstar(int c, char *re, char *text){ do{ // a * matches zero or more instances if(matchhere(re, text)) return 1; }while(*text!='\\0' &amp;&amp; (*text++==c || c=='.')); return 0;} 10 improve shell（easy/moderate）","link":"/2024/09/21/MIT-6-S081-Lab1-Xv6-and-Unix-utilities/"},{"title":"[C++]C++Primer Chapter 1","text":"1 开始1.1 每个C++程序都包含一个或多个函数（function），其中一个必须命名为main。操作系统通过调用main来运行C++程序。 函数 &lt; 返回类型 + 函数名 + 形参列表 + 函数体&gt; 内置类型（built-in type），语言自身定义的类型。 1.2 输入输出 c++由标准库来提供IO机制。 标准库定义了4个IO对象 &lt;cin cout cerr clog&gt; 1.4 控制流 当我们使用一个istream对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时（例如读入的值不是一个整数），istream对象的状态会变为无效。处于无效状态的istream对象会使条件变为假。","link":"/2024/09/22/C-C-Primer-Chapter-1/"},{"title":"[C++]C++Primer Chapter 2","text":"2 变量和基本类型2.1 基本内置类型C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数。空类型不对应具体的值，仅用于一些特殊的场合。 2.1.1 算术类型包括整型（integral type，包括字符和布尔类型在内）和浮点型。 2.1.3 字面值常量一个形如42的值被称作字面值常量（literal），这样的值一望而知。每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型。 1.整型和浮点型字面值 整型字面值具体的数据类型由它的值和符号决定。 默认的，浮点型字面值是一个double。 2.字符和字符串字面值 由单引号括起来的一个字符称为char型字面值，双引号括起来的零个或多个字符则构成字符串型字面值。 字符串字面值的类型实际上是由常量字符构成的数组（array） 编译器在每个字符串的结尾处添加一个空字符（′\\0′），因此，字符串字面值的实际长度要比它的内容多1。 3.布尔字面值和指针字面值 true和false是布尔类型的字面值 nullptr是指针字面值 2.2 变量变量提供一个具名的、可供程序操作的存储空间。 2.2.1 变量定义1.列表初始化 当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错 2.默认初始化 默认值到底是什么由变量类型决定，同时定义变量的位置也会对此有影响。 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。 定义于任何函数体之外的变量被初始化为0。 定义在函数体内部的内置类型变量将不被初始化（uninitialized）。 2.2.2 变量声明和定义的关系声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。 如果想声明一个变量而非定义它，就在变量名前添加关键字extern，而且不要显式地初始化变量 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。 静态类型 C++是一种静态类型（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查（type checking）。在C++语言中，编译器负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器将报错并且不会生成可执行文件。程序越复杂，静态类型检查越有助于发现问题。 2.2.3 标识符2.2.4 名字的作用域2.3 复合类型复合类型（compound type）是指基于其他类型定义的类型。 2.3.1 引用 引用即别名 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。 2.3.2 指针指针引用对比 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 void*指针 void＊是一种特殊的指针类型，可用于存放任意对象的地址。 利用void＊指针能做的事儿比较有限：拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void＊指针。不能直接操作void＊指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。 123int i = 42;int pi = &amp;i;int *&amp;r = pi; 从右向左阅读r的定义。离变量名最近的符号（此例中是&amp;r的符号&amp;）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，此例中的符号＊说明r引用的是一个指针。最后，声明的基本数据类型部分指出r引用的是一个int指针。 2.4 const限定符因为const对象一旦创建后其值就不能再改变，所以const对象必须初始化。 默认状态下，const对象仅在文件内有效1const int buffSize = 512; 编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所有用到bufSize的地方，然后用512替换。 为了执行上述替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个用了const对象的文件都必须得能访问到它的初始值才行。要做到这一点，就必须在每一个用到变量的文件中都有对它的定义（参见2.2.2节，第41页）。为了支持这一用法，同时避免对同一变量的重复定义，默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。 某些时候有这样一种const变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义const，而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了 1234// file1.ccextern const int buffSize = fcn();// file1.hextern const int buffSize; 如上述程序所示，file_1.cc定义并初始化了bufSize。因为这条语句包含了初始值，所以它（显然）是一次定义。然而，因为bufSize是一个常量，必须用extern加以限定使其被其他文件使用。file_1.h头文件中的声明也由extern做了限定，其作用是指明bufSize并非本文件所独有，它的定义将在别处出现。 2.4.1 const的引用对常量的引用，简称为常量引用，对常量的引用必须添加const限定符。 初始化和对const的引用在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成（参见2.1.2节，第32页）引用的类型即可。尤其是，允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式 2.4.2 指针和const123456// 指向常量的指针const int i = 42;const int *p = &amp;i;// 常量指针int *const q = &amp;i; 2.4.3 顶层const顶层const（top-level const）表示指针本身是个常量 底层const（low-level const）表示指针所指的对象是一个常量。 2.4.4 constexpr和常量表达式常量表达式（const expression）是指值不会改变并且在编译过程就能得到计算结果的表达式。 显然，字面值属于常量表达式，用常量表达式初始化的const对象也是常量表达式。 constexpr变量 C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化 字面值类型 常量表达式的值需要在编译时就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。 算术类型、引用和指针都属于字面值类型。自定义类Sales_item、IO库、string类型则不属于字面值类型，也就不能被定义成constexpr。 尽管指针和引用都能定义成constexpr，但它们的初始值却受到严格限制。一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化constexpr指针。 指针和constexpr 必须明确一点，在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关 12const int *p = nullptr;constexpr int *q = nullptr; p是底层const，q是顶层const 2.5 处理类型2.5.1 类型别名typedef和using 不要把原始类型替换进去，这种理解是错误的。 2.5.2 auto类型说明符1.使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为auto的类型 2.auto一般会忽略掉顶层const，同时底层const则会保留下来，比如当初始值是一个指向常量的指针时。如果希望推导出顶层const，需要显示声明。 2.5.3 decltype类型指示符它的作用是选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。 decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用在内）。 decltype（（variable））（注意是双层括号）的结果永远是引用，而decltype（variable）结果只有当variable本身就是一个引用时才是引用。","link":"/2024/09/22/C-C-Primer-Chapter-2/"},{"title":"[C++]C++Primer Chapter 11","text":"","link":"/2024/09/22/C-C-Primer-Chapter-11/"},{"title":"[C++]C++Primer Chapter 10","text":"","link":"/2024/09/22/C-C-Primer-Chapter-10/"},{"title":"[C++]C++Primer Chapter 12","text":"","link":"/2024/09/22/C-C-Primer-Chapter-12/"},{"title":"[C++]C++Primer Chapter 3","text":"3 字符串、向量和数组3.1 命名空间的using声明3.2 标准库类型string3.2.1 定义和初始化string对象 直接初始化和拷贝初始化 3.2.2 string对象上的操作 读写string对象 从流读：在执行读取操作时，string对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。 getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个string对象中去（注意不存换行符）。 getline也会返回它的流参数。因此既然输入运算符能作为判断的条件（参见1.4.3节，第13页），我们也能用getline的结果作为条件。 string：：size_type类型 它是一个无符号类型的值（参见2.1.1节，第30页）而且能足够存放下任何string对象的大小。所有用于存放string类的size函数返回值的变量，都应该是string：：size_type类型的。 比较string对象 1.如果两个string对象的长度不同，而且较短string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。 2.如果两个string对象在某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。 3.2.3 处理string对象中的字符 3.3 标准库类型vector3.3.1 定义和初始化vector对象 3.3.2 向vector对象中添加元素 范围for语句体内不应改变其所遍历序列的大小。 3.3.3 其他vector操作 3.4 迭代器介绍3.4.1 使用迭代器begin和end运算符 begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator 为了便于专门得到const_iterator类型的返回值，C++11新标准引入了两个新函数，分别是cbegin和cend 已知的一个限制是不能在范围for循环中向vector对象添加元素。另外一个限制是任何一种可能改变vector对象容量的操作，比如push_back，都会使该vector对象的迭代器失效 3.4.2 迭代器运算 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。string和vector都定义了difference_type，因为这个距离可正可负，所以difference_type是带符号类型的。 3.5 数组数组的大小确定不变，不能随意向数组中增加元素。因为数组的大小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。 如果不清楚元素的确切个数，使用vector 3.5.1 定义和初始化内置数组数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，维度必须是一个常量表达式（参见2.4.4节，第58页） 字符数组的特殊性 我们可以用字符串字面值（参见2.1.3节，第36页）对此类数组初始化。当使用这种方式时，一定要注意字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去 不允许拷贝和赋值 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值 理解复杂的数组声明 要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。 3.5.2 访问数组元素数组的元素也能使用范围for语句或下标运算符来访问。 在使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在cstddef头文件中定义了size_t类型，这个文件是C标准库stddef.h头文件的C++语言版本。 3.5.3 指针和数组使用数组的时候编译器一般会把它转换成指针。 在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针 当使用数组作为一个auto（参见2.5.2节，第61页）变量的初始值时，推断得到的类型是指针而非数组 当使用decltype关键字（参见2.5.3节，第62页）时上述转换不会发生，decltype（ia）返回的类型是由10个整数构成的数组 标准库函数begin和end C++11新标准引入了两个名为begin和end的函数。这两个函数与容器中的两个同名成员（参见3.4.1节，第95页）功能类似，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数 两个指针相减的结果的类型是一种名为ptrdiff_t的标准库类型，和size_t一样，ptrdiff_t也是一种定义在cstddef头文件中的机器相关的类型。因为差值可能为负值，所以ptrdiff_t是一种带符号类型 内置的下标运算符所用的索引值不是无符号类型，这一点与vector和string不一样。 3.5.4 C风格字符串C风格字符串不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束（null terminated）。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符（’\\0’）。一般利用指针来操作这些字符串。 3.5.5 与旧代码的接口如果执行完c_str（）函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 使用数组初始化vector对象 允许使用数组来初始化vector对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了： 3.6 多维数组要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。","link":"/2024/09/22/C-C-Primer-Chapter-3/"},{"title":"[C++]C++Primer Chapter 14","text":"","link":"/2024/09/22/C-C-Primer-Chapter-14/"},{"title":"[C++]C++Primer Chapter 13","text":"","link":"/2024/09/22/C-C-Primer-Chapter-13/"},{"title":"[C++]C++Primer Chapter 6","text":"","link":"/2024/09/22/C-C-Primer-Chapter-6/"},{"title":"[C++]C++Primer Chapter 5","text":"","link":"/2024/09/22/C-C-Primer-Chapter-5/"},{"title":"[C++]C++Primer Chapter 4","text":"4 表达式4.1 基础4.1.1 基本概念左值和右值 在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 4.1.2 优先级与结合律4.1.3 求值顺序优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。对于如下的表达式 我们知道f1和f2一定会在执行乘法之前被调用，因为毕竟相乘的是这两个函数的返回值。但是我们无法知道到底f1在f2之前调用还是f2在f1之前调用。 有4种运算符明确规定了运算对象的求值顺序： 逻辑与（&amp;&amp;）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。 逻辑或（||）运算符（参见4.3节，第126页） 条件（？：）运算符（参见4.7节，第134页） 逗号（，）运算符（参见4.10节，第140页）。 4.2 算术运算符C++11新标准则规定商一律向0取整（即直接切除小数部分）。 4.3 逻辑和关系运算符4.4 赋值运算符赋值运算返回的是其左侧的运算对象 赋值运算满足右结合律 4.5 递增和递减运算符递增和递减运算符有两种形式：前置版本和后置版本。到目前为止，本书使用的都是前置版本，这种形式的运算符首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。后置版本也会将运算对象加1（或减1），但是求值结果是运算对象改变之前那个值的副本 这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。 建议：除非必须，否则不用递增递减运算符的后置版本 运算对象可按任意顺序求值 大多数运算符都没有规定运算对象的求值顺序（参见4.1.3节，第123页），这在一般情况下不会有什么影响。然而，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。 4.6 成员访问运算符4.7 条件运算符 其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。条件运算符的执行过程是：首先求cond的值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值。 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。 4.8 位运算符、位运算符作用于整数类型的运算对象或者bitset类型 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。 如果运算对象是“小整型”，则它的值会被自动提升（参见4.11.1节，第142页）成较大的整数类型。 移位运算符 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 4.9 sizeof运算符sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型（参见3.5.2节，第103页）的常量表达式（参见2.4.4节，第58页）。 sizeof并不实际计算其运算对象的值。因为sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针（参见2.3.2节，第47页）也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。 sizeof运算符的结果部分地依赖于其作用的类型： · 对char或者类型为char的表达式执行sizeof运算，结果得1。 · 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 · 对指针执行sizeof运算得到指针本身所占空间的大小。 · 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。 · 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。 · 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 4.10 逗号运算符逗号运算符（comma operator）含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了运算对象求值的顺序。 对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 4.11 类型转换算术类型之间的隐式转换被设计得尽可能避免损失精度。 何时发生隐式类型转换 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。 在条件中，非布尔值转换成布尔类型 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。 4.11.1 算术转换整型提升 整型提升（integral promotion）负责把小整数类型转换成较大的整数类型。对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都能存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。就如我们所熟知的，布尔值false提升成0、true提升成1。 较大的char类型（wchar_t、char16_t、char32_t）提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。 无符号类型的运算对象 如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。 像往常一样，首先执行整型提升。如果结果的类型匹配，无须进行进一步的转换。 如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned int和int，则int类型的运算对象转换成unsigned int类型。需要注意的是，如果int型的值恰好为负值，其结果将以2.1.2节（第32页）介绍的方法转换，并带来该节描述的所有副作用。 剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。 如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。 如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是long和unsigned int，并且int和long的大小相同，则long类型的运算对象转换成unsigned int类型；如果long类型占用的空间比int更多，则unsigned int类型的运算对象转换成long类型。 4.11.2 其他隐式类型转换数组转换成指针 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针 当数组被用作decltype关键字的参数，或者作为取地址符（&amp;）、sizeof及typeid（第19.2.2节，732页将介绍）等运算符的运算对象时，上述转换不会发生。 4.11.3 显式转换命名的强制类型转换 type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。 static_cast 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 用处： 1.当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。 2.static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void＊指针（参见2.3.2节，第50页）中的值 const_cast 用处： const_cast常常用于有函数重载的上下文中，关于函数重载将在6.4节（第208页）进行详细介绍。 reinterpret_cast reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。 4.12 运算符优先级表 4 表达式4.1 基础4.1.1 基本概念左值和右值 在C++语言中，二者的区别就没那么简单了。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。可以做一个简单的归纳：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 4.1.2 优先级与结合律4.1.3 求值顺序优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。对于如下的表达式 我们知道f1和f2一定会在执行乘法之前被调用，因为毕竟相乘的是这两个函数的返回值。但是我们无法知道到底f1在f2之前调用还是f2在f1之前调用。 有4种运算符明确规定了运算对象的求值顺序： 1.逻辑与（&amp;&amp;）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。 2.逻辑或（||）运算符（参见4.3节，第126页）、 3.条件（？：）运算符（参见4.7节，第134页） 4.逗号（，）运算符（参见4.10节，第140页）。 4.2 算术运算符C++11新标准则规定商一律向0取整（即直接切除小数部分）。 4.3 逻辑和关系运算符4.4 赋值运算符赋值运算返回的是其左侧的运算对象 赋值运算满足右结合律 4.5 递增和递减运算符递增和递减运算符有两种形式：前置版本和后置版本。到目前为止，本书使用的都是前置版本，这种形式的运算符首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。后置版本也会将运算对象加1（或减1），但是求值结果是运算对象改变之前那个值的副本 这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。 建议：除非必须，否则不用递增递减运算符的后置版本 运算对象可按任意顺序求值 大多数运算符都没有规定运算对象的求值顺序（参见4.1.3节，第123页），这在一般情况下不会有什么影响。然而，如果一条子表达式改变了某个运算对象的值，另一条子表达式又要使用该值的话，运算对象的求值顺序就很关键了。因为递增运算符和递减运算符会改变运算对象的值，所以要提防在复合表达式中错用这两个运算符。 4.6 成员访问运算符4.7 条件运算符 其中cond是判断条件的表达式，而expr1和expr2是两个类型相同或可能转换为某个公共类型的表达式。条件运算符的执行过程是：首先求cond的值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值。 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。 4.8 位运算符、位运算符作用于整数类型的运算对象或者bitset类型 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。 如果运算对象是“小整型”，则它的值会被自动提升（参见4.11.1节，第142页）成较大的整数类型。 移位运算符 左移运算符（&lt;&lt;）在右侧插入值为0的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为0的二进制位，如何选择要视具体环境而定。 4.9 sizeof运算符sizeof运算符返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型（参见3.5.2节，第103页）的常量表达式（参见2.4.4节，第58页）。 sizeof并不实际计算其运算对象的值。因为sizeof不会实际求运算对象的值，所以即使p是一个无效（即未初始化）的指针（参见2.3.2节，第47页）也不会有什么影响。在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。sizeof不需要真的解引用指针也能知道它所指对象的类型。 sizeof运算符的结果部分地依赖于其作用的类型： · 对char或者类型为char的表达式执行sizeof运算，结果得1。 · 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 · 对指针执行sizeof运算得到指针本身所占空间的大小。 · 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。 · 对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。 · 对string对象或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。 4.10 逗号运算符逗号运算符（comma operator）含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了运算对象求值的顺序。 对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 4.11 类型转换算术类型之间的隐式转换被设计得尽可能避免损失精度。 何时发生隐式类型转换 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。 在条件中，非布尔值转换成布尔类型 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。 4.11.1 算术转换整型提升 整型提升（integral promotion）负责把小整数类型转换成较大的整数类型。对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都能存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。就如我们所熟知的，布尔值false提升成0、true提升成1。 较大的char类型（wchar_t、char16_t、char32_t）提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。 无符号类型的运算对象 如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。 像往常一样，首先执行整型提升。如果结果的类型匹配，无须进行进一步的转换。 如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。 如果一个运算对象是无符号类型、另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned int和int，则int类型的运算对象转换成unsigned int类型。需要注意的是，如果int型的值恰好为负值，其结果将以2.1.2节（第32页）介绍的方法转换，并带来该节描述的所有副作用。 剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。 如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。 如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是long和unsigned int，并且int和long的大小相同，则long类型的运算对象转换成unsigned int类型；如果long类型占用的空间比int更多，则unsigned int类型的运算对象转换成long类型。 4.11.2 其他隐式类型转换数组转换成指针 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针 当数组被用作decltype关键字的参数，或者作为取地址符（&amp;）、sizeof及typeid（第19.2.2节，732页将介绍）等运算符的运算对象时，上述转换不会发生。 4.11.3 显式转换命名的强制类型转换 ype是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。 static_cast 任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 用处： 1.当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。 2.static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void＊指针（参见2.3.2节，第50页）中的值 const_cast 用处： const_cast常常用于有函数重载的上下文中，关于函数重载将在6.4节（第208页）进行详细介绍。 reinterpret_cast reinterpret_cast通常为运算对象的位模式提供较低层次上的重新解释。 4.12 运算符优先级表","link":"/2024/09/22/C-C-Primer-Chapter-4/"},{"title":"[C++]C++Primer Chapter 8","text":"","link":"/2024/09/22/C-C-Primer-Chapter-8/"},{"title":"[C++]C++Primer Chapter 7","text":"","link":"/2024/09/22/C-C-Primer-Chapter-7/"},{"title":"[C++]C++Primer Chapter 9","text":"","link":"/2024/09/22/C-C-Primer-Chapter-9/"}],"tags":[{"name":"MIT 6.S081","slug":"MIT-6-S081","link":"/tags/MIT-6-S081/"},{"name":"C++","slug":"C","link":"/tags/C/"}],"categories":[],"pages":[]}