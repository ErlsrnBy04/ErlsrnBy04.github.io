<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[MIT 6.1810]Xv6 Chapter 4 - ErlsrnBy04</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ErlsrnBy04"><meta name="msapplication-TileImage" content="/img/Snake.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ErlsrnBy04"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Traps and system calls"><meta property="og:type" content="blog"><meta property="og:title" content="[MIT 6.1810]Xv6 Chapter 4"><meta property="og:url" content="https://erlsrnby04.github.io/2024/09/26/MIT-6-1810-Xv6-Chapter-4/"><meta property="og:site_name" content="ErlsrnBy04"><meta property="og:description" content="Traps and system calls"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://erlsrnby04.github.io/img/og_image.png"><meta property="article:published_time" content="2024-09-26T04:51:28.000Z"><meta property="article:modified_time" content="2024-09-26T18:14:25.858Z"><meta property="article:author" content="ErlsrnBy04"><meta property="article:tag" content="MIT 6.1810"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://erlsrnby04.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://erlsrnby04.github.io/2024/09/26/MIT-6-1810-Xv6-Chapter-4/"},"headline":"[MIT 6.1810]Xv6 Chapter 4","image":["https://erlsrnby04.github.io/img/og_image.png"],"datePublished":"2024-09-26T04:51:28.000Z","dateModified":"2024-09-26T18:14:25.858Z","author":{"@type":"Person","name":"ErlsrnBy04"},"publisher":{"@type":"Organization","name":"ErlsrnBy04","logo":{"@type":"ImageObject","url":"https://erlsrnby04.github.io/img/Snake.svg"}},"description":"Traps and system calls"}</script><link rel="canonical" href="https://erlsrnby04.github.io/2024/09/26/MIT-6-1810-Xv6-Chapter-4/"><link rel="icon" href="/img/Snake.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/Snake.svg" alt="ErlsrnBy04" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub 主页" href="https://github.com/ErlsrnBy04"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-26T04:51:28.000Z" title="2024/9/26 12:51:28">2024-09-26</time></span><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><span class="level-item">an hour read (About 6796 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">[MIT 6.1810]Xv6 Chapter 4</h1><div class="content"><h1 id="Traps-and-system-calls"><a href="#Traps-and-system-calls" class="headerlink" title="Traps and system calls"></a>Traps and system calls</h1><span id="more"></span>

<p>有三种情况会导致CPU暂停普通指令的执行，并强制转移控制权到处理该事件的特殊代码。</p>
<ol>
<li>系统调用：当用户程序执行 <code>ecall</code> 指令请求内核为其执行某项操作时，就会发生系统调用。</li>
<li>异常：当指令（无论是用户指令还是内核指令）执行了非法操作时，例如除以零或使用无效的虚拟地址，就会触发异常。</li>
<li>设备中断：当某个设备发出信号表示它需要处理时，例如磁盘硬件完成了读写请求，就会发生设备中断。</li>
</ol>
<p>xv6中用trap来代表以上三种情况。通常的执行流程如下：</p>
<ol>
<li>trap强制将控制权转移到内核</li>
<li>内核保存寄存器和其他状态</li>
<li>内核执行相应的处理代码</li>
<li>内核恢复寄存器和其他状态，跳转到原来的代码继续执行</li>
</ol>
<p>Xv6 的trap处理分为四个阶段：</p>
<ol>
<li>第一阶段是 RISC-V CPU 执行的硬件操作</li>
<li>第二阶段是一些汇编指令用于准备内核 C 代码</li>
<li>第三阶段是 C 函数决定如何处理陷阱</li>
<li>最后是系统调用或设备驱动程序服务例程。</li>
</ol>
<p>尽管这三种trap类型之间有很多共同点，理论上可以用一条代码路径处理所有trap，但实际上将来自用户空间和来自内核空间的trap分开处理更为方便。处理trap的内核代码（汇编或 C）通常被称为处理程序，最开始的处理程序指令通常用汇编编写，称为向量（vector）。</p>
<h2 id="4-1-RISC-V-trap-machinery"><a href="#4-1-RISC-V-trap-machinery" class="headerlink" title="4.1 RISC-V trap machinery"></a>4.1 RISC-V trap machinery</h2><p>每个RISC-V的CPU都有一套控制寄存器，内核可以读写这些控制寄存器来告诉CPU如何处理trap或者了解发生了什么trap。riscv.h中包含了xv6用到的定义。</p>
<p>一些比较重要的寄存器：</p>
<ul>
<li><strong>stvec</strong>：内核在此寄存器中写入trap处理程序的地址；RISC-V 发生trap时会跳转到 <code>stvec</code> 中的地址去处理trap。</li>
<li><strong>sepc</strong>：发生trap时，RISC-V 将程序计数器（PC）的值保存到此寄存器中（因为 PC 随后会被 <code>stvec</code> 中的值覆盖）。<code>sret</code>（从陷阱返回）指令会将 <code>sepc</code> 的值复制回 PC。内核可以通过写入 <code>sepc</code> 来控制 <code>sret</code> 的返回地址。</li>
<li><strong>scause</strong>：RISC-V 在此寄存器中存储一个数字，描述trap发生的原因。</li>
<li><strong>sscratch</strong>：trap处理程序使用此寄存器帮助避免在保存用户寄存器之前覆盖它们。</li>
<li><strong>sstatus</strong>：<code>sstatus</code> 中的 SIE（supervisor interrupt enable） 位控制设备中断是否启用。如果内核清除 SIE 位，RISC-V 将推迟设备中断，直到内核设置 SIE 位。SPP 位则指示trap是来自用户态还是S态，并且控制 <code>sret</code> 的返回态。</li>
</ul>
<p>以上寄存器只能在S态访问，用户态不能访问。每个CPU都有自己的一套控制寄存器，在某个时间可能有多个CPU在处理trap。</p>
<p>当需要处理一个trap时，<strong>硬件进行如下操作</strong>：</p>
<ol>
<li>如果sstatus中的SIE位没有设置，并且trap的种类是设备中断，则不进行下列操作。</li>
<li>清除sstatus中的SIE位来禁用设备中断。</li>
<li>将pc的值拷贝到sepc中</li>
<li>将当前的模式保存到sstatus中的SPP位中</li>
<li>设置scause寄存器的值来标识trap的原因</li>
<li>切换到S态</li>
<li>将stvec的值拷贝到pc</li>
<li>开始执行pc指向的指令</li>
</ol>
<p>需要注意的是，硬件并不负责将页表切换到内核页表，也不负责切换到内核栈，也不会保存除了pc以外的其他寄存器的值，因此内核的软件必须负责这些。</p>
<h2 id="4-2-Traps-from-user-space"><a href="#4-2-Traps-from-user-space" class="headerlink" title="4.2 Traps from user space"></a>4.2 Traps from user space</h2><p>xv6中处理来自用户态的trap的路径大概如下：</p>
<ol>
<li>uservec（kernel&#x2F;trampoline.S）</li>
<li>usertrap（kernel&#x2F;trap.c）</li>
<li>返回后，usertrapret（kernel&#x2F;trap.c）</li>
<li>userret（kernel&#x2F;trampoline.S）</li>
</ol>
<p>Xv6 的trap处理设计中一个重要的限制是 RISC-V 硬件在触发trap时不会切换页表。这意味着 <code>stvec</code> 中的trap处理程序地址必须在用户页表中有一个有效的映射，因为trap处理代码开始执行时，用户页表仍然生效。此外，Xv6 的trap处理代码还需要切换到内核页表；为了在切换到内核页表后能够继续执行，内核页表也必须为 <code>stvec</code> 指向的处理程序地址提供映射。</p>
<p>Xv6 通过使用trampoline page来满足这些要求。该页包含了 <code>uservec</code>，即 Xv6 的trap处理代码，而 <code>stvec</code> 指向这个代码。该页被映射在每个进程的页表中，地址是 <code>TRAMPOLINE</code>，该页同样也被映射在内核页表中的 <code>TRAMPOLINE</code> 地址上。由于该页在内核地址空间中和用户地址空间中映射在相同的地址，因此trap处理程序在切换到内核页表后可以继续执行。</p>
<p><code>uservec</code> 的代码在 <code>trampoline.S</code> 文件中（kernel&#x2F;trampoline.S:22）。当 <code>uservec</code> 开始执行时，所有32个寄存器都包含了被中断的用户代码的值。这些32个寄存器的值需要保存到内存中，以便稍后内核在返回用户空间之前恢复它们。将这些值存储到内存需要使用一个寄存器来存放内存地址，但此时没有任何通用寄存器可用。RISC-V 提供了 <code>sscratch</code> 寄存器作为帮助。在 <code>uservec</code> 的开头，<code>csrw</code> 指令将 <code>a0</code> 保存到 <code>sscratch</code> 中。这样，<code>uservec</code> 就有了一个寄存器（<code>a0</code>）可以使用。</p>
<p><code>uservec</code> 的下一个任务是保存32个用户寄存器。内核为每个进程分配了一页内存用于保存一个 <code>trapframe</code> 结构体，其中包含保存这32个用户寄存器的空间（见 kernel&#x2F;proc.h:43）。因为此时 <code>satp</code> 仍然指向用户页表，因此 <code>uservec</code> 需要 <code>trapframe</code> 映射到用户地址空间中。Xv6 将每个进程的 <code>trapframe</code> 映射在该进程用户页表中的虚拟地址 <code>TRAPFRAME</code>，这个地址位于 <code>TRAMPOLINE</code> 的下方。每个进程的 <code>p-&gt;trapframe</code> 也指向 <code>trapframe</code>，但使用的是物理地址，以便内核通过内核页表访问它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// memlayout.h</span></span><br><span class="line"><span class="comment">// map the trampoline page to the highest address,</span></span><br><span class="line"><span class="comment">// in both user and kernel space.</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAMPOLINE (MAXVA - PGSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User memory layout.</span></span><br><span class="line"><span class="comment">// Address zero first:</span></span><br><span class="line"><span class="comment">//   text</span></span><br><span class="line"><span class="comment">//   original data and bss</span></span><br><span class="line"><span class="comment">//   fixed-size stack</span></span><br><span class="line"><span class="comment">//   expandable heap</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   TRAPFRAME (p-&gt;trapframe, used by the trampoline)</span></span><br><span class="line"><span class="comment">//   TRAMPOLINE (the same page as in the kernel)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRAPFRAME (TRAMPOLINE - PGSIZE)</span></span><br></pre></td></tr></table></figure>

<p>因此，<code>uservec</code> 将地址 <code>TRAPFRAME</code> 加载到 <code>a0</code> 中，并将所有用户寄存器保存在此处，包括从 <code>sscratch</code> 中读取的<code>a0</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># trampoline.S</span><br><span class="line"># save user a0 in sscratch so</span><br><span class="line"># a0 can be used to get at TRAPFRAME.</span><br><span class="line">csrw sscratch, a0</span><br><span class="line"></span><br><span class="line"># each process has a separate p-&gt;trapframe memory area,</span><br><span class="line"># but it&#x27;s mapped to the same virtual address</span><br><span class="line"># (TRAPFRAME) in every process&#x27;s user page table.</span><br><span class="line">li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line"># save the user registers in TRAPFRAME</span><br><span class="line">sd ra, 40(a0)</span><br><span class="line">sd sp, 48(a0)</span><br><span class="line">sd gp, 56(a0)</span><br><span class="line">sd tp, 64(a0)</span><br><span class="line">sd t0, 72(a0)</span><br><span class="line">sd t1, 80(a0)</span><br><span class="line">sd t2, 88(a0)</span><br><span class="line">sd s0, 96(a0)</span><br><span class="line">sd s1, 104(a0)</span><br><span class="line">sd a1, 120(a0)</span><br><span class="line">sd a2, 128(a0)</span><br><span class="line">sd a3, 136(a0)</span><br><span class="line">sd a4, 144(a0)</span><br><span class="line">sd a5, 152(a0)</span><br><span class="line">sd a6, 160(a0)</span><br><span class="line">sd a7, 168(a0)</span><br><span class="line">sd s2, 176(a0)</span><br><span class="line">sd s3, 184(a0)</span><br><span class="line">sd s4, 192(a0)</span><br><span class="line">sd s5, 200(a0)</span><br><span class="line">sd s6, 208(a0)</span><br><span class="line">sd s7, 216(a0)</span><br><span class="line">sd s8, 224(a0)</span><br><span class="line">sd s9, 232(a0)</span><br><span class="line">sd s10, 240(a0)</span><br><span class="line">sd s11, 248(a0)</span><br><span class="line">sd t3, 256(a0)</span><br><span class="line">sd t4, 264(a0)</span><br><span class="line">sd t5, 272(a0)</span><br><span class="line">sd t6, 280(a0)</span><br><span class="line"></span><br><span class="line"># save the user a0 in p-&gt;trapframe-&gt;a0</span><br><span class="line">csrr t0, sscratch</span><br><span class="line">sd t0, 112(a0)</span><br></pre></td></tr></table></figure>

<p><code>trapframe</code> 还包含当前进程的内核栈地址、当前 CPU 的 hartid、<code>usertrap</code> 函数的地址以及内核页表的地址。<code>uservec</code> 从中读取这些值，将 <code>satp</code> 切换到内核页表，并跳转到 <code>usertrap</code>。注意在切换页表之前以及之后需要执行 <code>sfence.vma</code> 指令，第一次确保所有之前的内存操作使用的都是用户页表，并且操作都已经完成，然后切换到内核页表，再次执行该指令，确保TLB中缓存的之前用户页表的PTE都已经被刷新。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># initialize kernel stack pointer, from p-&gt;trapframe-&gt;kernel_sp</span><br><span class="line">ld sp, 8(a0)</span><br><span class="line"></span><br><span class="line"># make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid</span><br><span class="line">ld tp, 32(a0)</span><br><span class="line"></span><br><span class="line"># load the address of usertrap(), from p-&gt;trapframe-&gt;kernel_trap</span><br><span class="line">ld t0, 16(a0)</span><br><span class="line"></span><br><span class="line"># fetch the kernel page table address, from p-&gt;trapframe-&gt;kernel_satp.</span><br><span class="line">ld t1, 0(a0)</span><br><span class="line"></span><br><span class="line"># wait for any previous memory operations to complete, so that</span><br><span class="line"># they use the user page table.</span><br><span class="line">sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line"># install the kernel page table.</span><br><span class="line">csrw satp, t1</span><br><span class="line"></span><br><span class="line"># flush now-stale user entries from the TLB.</span><br><span class="line">sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line"># jump to usertrap(), which does not return</span><br><span class="line">jr t0</span><br></pre></td></tr></table></figure>

<p><code>usertrap</code> 的任务是确定陷阱的原因，进行处理并返回（见 kernel&#x2F;trap.c:37）。它首先将 <code>stvec</code> 改为指向 <code>kernelvec</code>，以便内核中发生的陷阱由 <code>kernelvec</code> 处理。它保存 <code>sepc</code> 寄存器（硬件保存的用户程序计数器），因为 <code>usertrap</code> 可能会调用 <code>yield</code> 切换到另一个进程的内核线程，而该进程可能会返回用户空间，并修改 <code>sepc</code>。根据scause寄存器的值进行trap原因的判断（由硬件设置）：如果陷阱是系统调用，<code>usertrap</code> 调用 <code>syscall</code> 处理；如果是设备中断，调用 <code>devintr</code>；否则是异常，内核会终止出错的进程。在处理系统调用时，系统调用路径会将保存的用户程序计数器增加4，因为 RISC-V 在系统调用的情况下，会将程序计数器停留在 <code>ecall</code> 指令上，但用户代码需要从后续的指令继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// handle an interrupt, exception, or system call from user space.</span></span><br><span class="line"><span class="comment">// called from trampoline.S</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// SPP在trap发生的时候由硬件设置</span></span><br><span class="line">  <span class="keyword">if</span>((r_sstatus() &amp; SSTATUS_SPP) != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;usertrap: not from user mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send interrupts and exceptions to kerneltrap(),</span></span><br><span class="line">  <span class="comment">// since we&#x27;re now in the kernel.</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// save user program counter.</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// scause的值由硬件设置</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// system call</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sepc points to the ecall instruction,</span></span><br><span class="line">    <span class="comment">// but we want to return to the next instruction.</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// an interrupt will change sepc, scause, and sstatus,</span></span><br><span class="line">    <span class="comment">// so enable only now that we&#x27;re done with those registers.</span></span><br><span class="line">    <span class="comment">// 发生trap的时候，硬件会关闭设备中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    syscall();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 设备中断</span></span><br><span class="line">    <span class="comment">// ok</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): unexpected scause 0x%lx pid=%d\n&quot;</span>, r_scause(), p-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;            sepc=0x%lx stval=0x%lx\n&quot;</span>, r_sepc(), r_stval());</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回用户空间的第一步是调用 <code>usertrapret</code>（见 kernel&#x2F;trap.c:90）。这个函数设置 RISC-V 控制寄存器，为用户空间的未来陷阱做好准备：将 <code>stvec</code> 设置为 <code>uservec</code> 并准备 <code>trapframe</code> 字段，这是 <code>uservec</code> 依赖的内容。<code>usertrapret</code> 将 <code>sepc</code> 设置为先前保存的用户程序计数器。最后，<code>usertrapret</code> 调用位于trampoline page上的 <code>userret</code>，该函数的代码映射在用户和内核页表中，原因是 <code>userret</code> 的汇编代码需要切换页表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// return to user space</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// we&#x27;re about to switch the destination of traps from</span></span><br><span class="line">  <span class="comment">// kerneltrap() to usertrap(), so turn off interrupts until</span></span><br><span class="line">  <span class="comment">// we&#x27;re back in user space, where usertrap() is correct.</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// send syscalls, interrupts, and exceptions to uservec in trampoline.S</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up trapframe values that uservec will need when</span></span><br><span class="line">  <span class="comment">// the process next traps into the kernel.</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set S Previous Privilege mode to User.</span></span><br><span class="line">  <span class="comment">// 设置SPP为0 当使用sret返回的时候 会自动切换到用户态</span></span><br><span class="line">  <span class="comment">// 设置SPIE为1 当使用sret返回的时候 会自动使能设备中断</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// clear SPP to 0 for user mode</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// enable interrupts in user mode</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set S Exception Program Counter to the saved user pc.</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// tell trampoline.S the user page table to switch to.</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jump to userret in trampoline.S at the top of memory, which </span></span><br><span class="line">  <span class="comment">// switches to the user page table, restores user registers,</span></span><br><span class="line">  <span class="comment">// and switches to user mode with sret.</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>usertrapret</code> 调用 <code>userret</code> 时，将进程的用户页表的指针传递给 <code>a0</code>（见 kernel&#x2F;trampoline.S:101）。<code>userret</code> 将 <code>satp</code> 切换到进程的用户页表。回想一下，用户页表映射了trampoline page和 <code>TRAPFRAME</code>，但没有其他内核内容。trampoline page在用户和内核页表中的相同虚拟地址映射允许 <code>userret</code> 在切换 <code>satp</code> 后继续执行。从此时开始，<code>userret</code> 能使用的唯一数据是寄存器的内容和 <code>trapframe</code> 的内容。<code>userret</code> 将 <code>TRAPFRAME</code> 地址加载到 <code>a0</code>，通过 <code>a0</code> 从 <code>trapframe</code> 中恢复保存的用户寄存器，恢复保存的 <code>a0</code>，并执行 <code>sret</code> 返回用户空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">userret:</span><br><span class="line">    # userret(pagetable)</span><br><span class="line">    # called by usertrapret() in trap.c to</span><br><span class="line">    # switch from kernel to user.</span><br><span class="line">    # a0: user page table, for satp.</span><br><span class="line"></span><br><span class="line">    # switch to the user page table.</span><br><span class="line">    sfence.vma zero, zero</span><br><span class="line">    csrw satp, a0</span><br><span class="line">    sfence.vma zero, zero</span><br><span class="line"></span><br><span class="line">    li a0, TRAPFRAME</span><br><span class="line"></span><br><span class="line">    # restore all but a0 from TRAPFRAME</span><br><span class="line">    ld ra, 40(a0)</span><br><span class="line">    ld sp, 48(a0)</span><br><span class="line">    ld gp, 56(a0)</span><br><span class="line">    ld tp, 64(a0)</span><br><span class="line">    ld t0, 72(a0)</span><br><span class="line">    ld t1, 80(a0)</span><br><span class="line">    ld t2, 88(a0)</span><br><span class="line">    ld s0, 96(a0)</span><br><span class="line">    ld s1, 104(a0)</span><br><span class="line">    ld a1, 120(a0)</span><br><span class="line">    ld a2, 128(a0)</span><br><span class="line">    ld a3, 136(a0)</span><br><span class="line">    ld a4, 144(a0)</span><br><span class="line">    ld a5, 152(a0)</span><br><span class="line">    ld a6, 160(a0)</span><br><span class="line">    ld a7, 168(a0)</span><br><span class="line">    ld s2, 176(a0)</span><br><span class="line">    ld s3, 184(a0)</span><br><span class="line">    ld s4, 192(a0)</span><br><span class="line">    ld s5, 200(a0)</span><br><span class="line">    ld s6, 208(a0)</span><br><span class="line">    ld s7, 216(a0)</span><br><span class="line">    ld s8, 224(a0)</span><br><span class="line">    ld s9, 232(a0)</span><br><span class="line">    ld s10, 240(a0)</span><br><span class="line">    ld s11, 248(a0)</span><br><span class="line">    ld t3, 256(a0)</span><br><span class="line">    ld t4, 264(a0)</span><br><span class="line">    ld t5, 272(a0)</span><br><span class="line">    ld t6, 280(a0)</span><br><span class="line"></span><br><span class="line">	# restore user a0</span><br><span class="line">    ld a0, 112(a0)</span><br><span class="line"></span><br><span class="line">    # return to user mode and user pc.</span><br><span class="line">    # usertrapret() set up sstatus and sepc.</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>



<h2 id="4-3-Code：Calling-system-calls"><a href="#4-3-Code：Calling-system-calls" class="headerlink" title="4.3 Code：Calling system calls"></a>4.3 Code：Calling system calls</h2><p>首先将系统调用的参数放进寄存器a0-a6中，然后将系统调用号放进寄存器a7中。 <code>usertrap</code> 会判断当前发生的trap是系统调用，然后调用 <code>syscall</code> 函数去执行。 <code>syscall</code> 函数从trapframe中取得参数和系统调用号，然后用系统调用号作为索引取得系统调用处理程序的地址执行。当系统调用返回的时候，会把返回值存放在 <code>p-&gt;trapframe-&gt;a0</code> 中。</p>
<p>initcode.S系统调用 <code>exec(init, argv)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># exec(init, argv)</span><br><span class="line">.globl start</span><br><span class="line">start:</span><br><span class="line">    la a0, init</span><br><span class="line">    la a1, argv</span><br><span class="line">    li a7, SYS_exec</span><br><span class="line">    ecall·</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">// a7中存放了系统调用号</span></span><br><span class="line">  <span class="comment">// 系统调用之前存放到a7中</span></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// Use num to lookup the system call function for num, call it,</span></span><br><span class="line">    <span class="comment">// and store its return value in p-&gt;trapframe-&gt;a0</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-4-Code：System-call-arguments"><a href="#4-4-Code：System-call-arguments" class="headerlink" title="4.4 Code：System call arguments"></a>4.4 Code：System call arguments</h2><p>系统调用需要获取用户调用系统调用时传递的参数。这个参数最开始被放到用户寄存器中，之后在 <code>usertrap</code> 中被保存到trapframe中。内核通过 <code>argint</code> 、<code>argaddr</code> 、<code>argfd</code> 从trapframe中获取第n个系统调用参数（整数、指针、文件描述符）。它们都通过 <code>argraw</code> 来获取trapframe中的寄存器的值。syscall在usertrap中执行，此时已经切换到S态，寄存器的值都被保存到trapframe中，但是由于已经切换到内核页表，因此无法通过虚拟地址访问trapframe，可以通过p-&gt;trapframe直接获取trapframe的物理地址进行访问。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth 32-bit system call argument.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">argint</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Retrieve an argument as a pointer.</span></span><br><span class="line"><span class="comment">// Doesn&#x27;t check for legality, since</span></span><br><span class="line"><span class="comment">// copyin/copyout will do that.</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">argaddr</span><span class="params">(<span class="type">int</span> n, uint64 *ip)</span></span><br><span class="line">&#123;</span><br><span class="line">  *ip = argraw(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fetch the nth word-sized system call argument as a null-terminated string.</span></span><br><span class="line"><span class="comment">// Copies into buf, at most max.</span></span><br><span class="line"><span class="comment">// Returns string length if OK (including nul), -1 if error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">argstr</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 addr;</span><br><span class="line">  argaddr(n, &amp;addr);</span><br><span class="line">  <span class="keyword">return</span> fetchstr(addr, buf, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些系统调用会传递指针作为参数，这会导致两个问题：</p>
<ol>
<li>用户程序可能是恶意的或者有bug，导致传递进来的地址是无效的。</li>
<li>由于内核页表和用户页表映射不同，用户传递的地址无法直接使用。</li>
</ol>
<p>内核提供了函数来从用户地址中读写数据。</p>
<p> <code>exec</code> 使用 <code>fetchstr</code> 来从用户空间中获取一个字符串参数。 <code>fetchstr</code> 调用 <code>copyinstr</code> 来完成数据拷贝的任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fetch the nul-terminated string at addr from the current process.</span></span><br><span class="line"><span class="comment">// Returns length of string, not including nul, or -1 for error.</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">fetchstr</span><span class="params">(uint64 addr, <span class="type">char</span> *buf, <span class="type">int</span> max)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(copyinstr(p-&gt;pagetable, buf, addr, max) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>copyinstr</code> 至多从用户页表pagetable中的虚拟地址srcva指定的地方拷贝max字节到dst指定的地方。</p>
<p>因为pagetable不是当前的页表，所以 <code>copyinstr</code> 使用 <code>walkaddr</code> 在pagetable中查找虚拟地址srcva，并获得相应的物理地址pa0。之后可以直接进行拷贝操作。类似的，<code>copyout</code> 将数据从内核拷贝到用户空间中。</p>
<h2 id="4-5-Traps-from-kernel-space"><a href="#4-5-Traps-from-kernel-space" class="headerlink" title="4.5 Traps from kernel space"></a>4.5 Traps from kernel space</h2><p>xv6以一种不同的方式处理来自内核的trap。当进入内核后，usertrap会将stvec的值指向kernelvec。因为执行kernelvec的时候，一定已经在S态了，satp已经是内核页表，并且sp也指向内核栈。kernelvec将32个寄存器的值保存到内核栈中。之后会跳转到kerneltrap执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">kernelvec:</span><br><span class="line">    # make room to save registers.</span><br><span class="line">    addi sp, sp, -256</span><br><span class="line"></span><br><span class="line">    # save caller-saved registers.</span><br><span class="line">    sd ra, 0(sp)</span><br><span class="line">    sd sp, 8(sp)</span><br><span class="line">    sd gp, 16(sp)</span><br><span class="line">    sd tp, 24(sp)</span><br><span class="line">    sd t0, 32(sp)</span><br><span class="line">    sd t1, 40(sp)</span><br><span class="line">    sd t2, 48(sp)</span><br><span class="line">    sd a0, 72(sp)</span><br><span class="line">    sd a1, 80(sp)</span><br><span class="line">    sd a2, 88(sp)</span><br><span class="line">    sd a3, 96(sp)</span><br><span class="line">    sd a4, 104(sp)</span><br><span class="line">    sd a5, 112(sp)</span><br><span class="line">    sd a6, 120(sp)</span><br><span class="line">    sd a7, 128(sp)</span><br><span class="line">    sd t3, 216(sp)</span><br><span class="line">    sd t4, 224(sp)</span><br><span class="line">    sd t5, 232(sp)</span><br><span class="line">    sd t6, 240(sp)</span><br><span class="line"></span><br><span class="line">    # call the C trap handler in trap.c</span><br><span class="line">    call kerneltrap</span><br></pre></td></tr></table></figure>

<p>kerneltrap只处理两种类型的trap：设备中断和异常。它调用devintr来处理设备中断。如果不是设备中断，那就一定是异常，内核中的异常通常意味着fatal error，内核调用panic之后停止执行。</p>
<p>如果kerneltrap处理的是时钟中断，并且当前进程的内核线程正在运行，kerneltrap会调用yield将CPU使用权让出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// interrupts and exceptions from kernel code go here via kernelvec,</span></span><br><span class="line"><span class="comment">// on whatever the current kernel stack is.</span></span><br><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">kerneltrap</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> which_dev = <span class="number">0</span>;</span><br><span class="line">  uint64 sepc = r_sepc();</span><br><span class="line">  uint64 sstatus = r_sstatus();</span><br><span class="line">  uint64 scause = r_scause();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>((sstatus &amp; SSTATUS_SPP) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: not from supervisor mode&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(intr_get() != <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap: interrupts enabled&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((which_dev = devintr()) == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// interrupt or trap from an unknown source</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;scause=0x%lx sepc=0x%lx stval=0x%lx\n&quot;</span>, scause, r_sepc(), r_stval());</span><br><span class="line">    panic(<span class="string">&quot;kerneltrap&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span> &amp;&amp; myproc() != <span class="number">0</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the yield() may have caused some traps to occur,</span></span><br><span class="line">  <span class="comment">// so restore trap registers for use by kernelvec.S&#x27;s sepc instruction.</span></span><br><span class="line">  w_sepc(sepc);</span><br><span class="line">  w_sstatus(sstatus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当kerneltrap完成后，它需要返回之前被中断的代码继续执行。因为yield可能会破坏sepc和sstatus中的值，所以kerneltrap需要在开始的时候保存它们。因此，kerneltrap完成后需要先恢复这些控制寄存器的值，然后返回到kernelvec。kernelvec从栈中恢复寄存器的值，然后执行sret指令，将sepc的值拷贝到pc中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># restore registers.</span><br><span class="line">    ld ra, 0(sp)</span><br><span class="line">    ld sp, 8(sp)</span><br><span class="line">    ld gp, 16(sp)</span><br><span class="line">    # not tp (contains hartid), in case we moved CPUs</span><br><span class="line">    ld t0, 32(sp)</span><br><span class="line">    ld t1, 40(sp)</span><br><span class="line">    ld t2, 48(sp)</span><br><span class="line">    ld a0, 72(sp)</span><br><span class="line">    ld a1, 80(sp)</span><br><span class="line">    ld a2, 88(sp)</span><br><span class="line">    ld a3, 96(sp)</span><br><span class="line">    ld a4, 104(sp)</span><br><span class="line">    ld a5, 112(sp)</span><br><span class="line">    ld a6, 120(sp)</span><br><span class="line">    ld a7, 128(sp)</span><br><span class="line">    ld t3, 216(sp)</span><br><span class="line">    ld t4, 224(sp)</span><br><span class="line">    ld t5, 232(sp)</span><br><span class="line">    ld t6, 240(sp)</span><br><span class="line"></span><br><span class="line">    addi sp, sp, 256</span><br><span class="line"></span><br><span class="line">    # return to whatever we were doing in the kernel.</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>

<p>当从用户态进入内核的时候，xv6会设置CPU的stvec指向kernelvec。在内核开始执行和stvec指向kernelvec之间会有一段时间（执行uservec的代码的时候已经处于S态，但是直到usertrap中才修改stvec的值指向kernelvec），RISC-V在处理一个trap的时候关闭设备中断，usertrap直到设置好stvec之后才重新使能设备中断，因此可以确保这段时间不会有设备中断，否则就会导致来自S态的trap错误的被uservec处理。</p>
<h2 id="4-6-Page-fault-exceptions"><a href="#4-6-Page-fault-exceptions" class="headerlink" title="4.6 Page-fault exceptions"></a>4.6 Page-fault exceptions</h2><p>xv6对异常的处理比较简单，如果异常来自用户态，则内核杀死发生异常的进程，如果异常来自S态，则内核panics。真实的操作系统往往有更加复杂的处理方式。</p>
<p><strong>写时复制</strong></p>
<p>许多内核通过页错误来实现写实复制（copy on write， COW）fork。考虑xv6实现的fork，通过uvmcopy分配内存并将父进程的内存拷贝一份。如果可以共享父进程的内存将提高效率，然后，普通的实现将导致父子进程互相干扰。</p>
<p>为了解决这个问题，父子进程可以通过恰当的设置页表权限和页错误来解决这个问题。当：</p>
<ul>
<li>某个虚拟地址在页表中没有映射</li>
<li>页表项的v位置0</li>
<li>页表项的某些权限位禁止操作</li>
</ul>
<p>的时候，CPU会发起一个页错误异常。</p>
<p>xv6中区分三种页错误：</p>
<ol>
<li>读页错误</li>
<li>写页错误</li>
<li>指令页错误</li>
</ol>
<p>通过scause寄存器指明页错误的种类，stval寄存器保存发生错误的虚拟地址。</p>
<p>COWfork的想法是初始的时候父子进程共享相同的物理页，但是父子进程页表中相应的页表项标记为只读（PTE_W置0）。父子进程可以顺利的读共享的页，但是当任何一个进程试图写共享的页的时候，会引发一个页错误。内核此时在复制一份共享的页面，然后修改相应进程的页表中的页表项，然后返回到发生异常的指令重新执行。</p>
<p>COW需要一个记录来帮助决定什么时候可以释放掉一个物理页面，因为每个物理页面可能会被多个进程共享。有了这个记录，在发生写页错误的时候，内核可以根据记录来查看当前共享这个物理页面的进程数，如果只有一个进程，那么就无需进行复制（假设父子进程共享一个页面，然后子进程退出了，父进程此时再写会触发页错误，但是无需复制）。</p>
<p><strong>lazy allocation</strong></p>
<p>通过页错误，我们还可以实现lazy allocation。当一个进程通过sbrk申请更多内存的时候，内核仅仅记录大小的更改，但是不实际申请物理页和创建页表项。但在这些新的虚拟地址上发生页错误的时候，内核再实际去申请物理内存。</p>
<ul>
<li><p>lazy allocation的优势：</p>
<ol>
<li>因为应用总是会申请更多的内存（实际不需要这么多），所以lazy allocation很有必要。</li>
<li>当应用申请很大的内存的时候，一次sbrk的开销是很大的，可以通过lazy allocation平均这些开销。</li>
</ol>
</li>
<li><p>lazy allocation的缺点：</p>
<p>会引发页错误，导致用户态到S态的切换。可以通过每次申请一连串的页来减少页错误的次数；也可以通过特化页错误的代码来降低开销。</p>
</li>
</ul>
<p><strong>请求分页</strong></p>
<p>在xv6中，调用exec的时候会把程序的完整镜像加载到内存中，如果镜像很大，这个开销会非常大。现代操作系统通过请求分页机制来分摊这个开销。通常只是在页表中建立相应的页表项，但并不实际读取硬盘，将页表项的PTE_V字段置0，当程序实际访问该虚拟地址指向的内容的时候，在将物理页读入内存。</p>
<p>运行在计算机上的程序可能需要的内存超出计算机的 RAM。为了解决这个问题，操作系统可以实现磁盘分页。其基本思路是将仅一部分用户页面存储在 RAM 中，而将其余页面存储在磁盘的分页区域中。内核会将对应于存储在分页区域（即不在 RAM 中）的内存的页表项（PTE）标记为无效。如果应用程序尝试使用已经分页到磁盘的页面，就会发生页面错误，此时需要将该页面调入：内核的trap处理程序将分配一页物理 RAM，将页面从磁盘读入 RAM，并修改相关的 PTE 以指向该 RAM。</p>
<p>如果需要调入的页面时没有空闲的物理 RAM，会发生什么呢？在这种情况下，内核必须首先通过将一页物理内存分页出去或驱逐到磁盘的分页区域来释放一页物理页面，并将引用该物理页面的 PTE 标记为无效。驱逐操作开销较大，因此分页性能最佳的情况是尽量少发生页面错误：如果应用程序只使用其内存页面的一个子集，而这些子集的并集可以分配在 RAM 中，这种属性通常被称为良好的局部性。</p>
<p>在许多虚拟内存技术中，内核通常以对应用程序透明的方式实现磁盘分页。尽管硬件提供了大量的 RAM，但计算机通常会有很少或没有空闲的物理内存。例如，云服务提供商通常在一台机器上多路复用多个客户，以高效利用硬件成本；另一个例子是用户在智能手机上运行多个应用程序，而物理内存又非常有限。在这种情况下，分配一个页面可能需要首先驱逐一个现有页面。因此，当空闲物理内存稀缺时，分配成本较高。</p>
<p>懒惰分配和按需分页在空闲内存稀缺且程序仅积极使用其分配内存的一部分时尤其有利。这些技术还可以避免在页面被分配或加载但从未使用或在使用之前被驱逐时浪费的工作。</p>
<p>结合分页和页面错误异常的其他特性包括自动扩展堆栈和内存映射文件（memory-mapped files），即程序通过 <code>mmap</code> 系统调用映射到其地址空间的文件，使得程序可以通过加载和存储指令读取和写入这些文件。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>[MIT 6.1810]Xv6 Chapter 4</p><p><a href="https://erlsrnby04.github.io/2024/09/26/MIT-6-1810-Xv6-Chapter-4/">https://erlsrnby04.github.io/2024/09/26/MIT-6-1810-Xv6-Chapter-4/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>ErlsrnBy04</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-09-26</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-09-27</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/MIT-6-1810/">MIT 6.1810</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/09/25/MIT-6-1810-Xv6-Chapter-3/"><span class="level-item">[MIT 6.1810]Xv6 Chapter 3</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><script src="https://giscus.app/client.js" repo="ErlsrnBy04/comments" data-repo="ErlsrnBy04/comments" data-repo-id="R_kgDOM1SRGQ" data-category-id="DIC_kwDOM1SRGc4Cirkj" data-category="Announcements" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar1.jpg" alt="ErlsrnBy04"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ErlsrnBy04</p><p class="is-size-6 is-block">学生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ErlsrnBy04" target="_blank" rel="me noopener">Follow</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Traps-and-system-calls"><span class="level-left"><span class="level-item">1</span><span class="level-item">Traps and system calls</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#4-1-RISC-V-trap-machinery"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">4.1 RISC-V trap machinery</span></span></a></li><li><a class="level is-mobile" href="#4-2-Traps-from-user-space"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">4.2 Traps from user space</span></span></a></li><li><a class="level is-mobile" href="#4-3-Code：Calling-system-calls"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">4.3 Code：Calling system calls</span></span></a></li><li><a class="level is-mobile" href="#4-4-Code：System-call-arguments"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">4.4 Code：System call arguments</span></span></a></li><li><a class="level is-mobile" href="#4-5-Traps-from-kernel-space"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">4.5 Traps from kernel space</span></span></a></li><li><a class="level is-mobile" href="#4-6-Page-fault-exceptions"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">4.6 Page-fault exceptions</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-26T04:51:28.000Z">2024-09-26</time></p><p class="title"><a href="/2024/09/26/MIT-6-1810-Xv6-Chapter-4/">[MIT 6.1810]Xv6 Chapter 4</a></p><p class="categories"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-25T03:44:09.000Z">2024-09-25</time></p><p class="title"><a href="/2024/09/25/MIT-6-1810-Xv6-Chapter-3/">[MIT 6.1810]Xv6 Chapter 3</a></p><p class="categories"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-24T07:43:10.000Z">2024-09-24</time></p><p class="title"><a href="/2024/09/24/MIT-6-1810-Xv6-Chapter-2/">[MIT 6.1810]Xv6 Chapter 2</a></p><p class="categories"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-24T05:11:40.000Z">2024-09-24</time></p><p class="title"><a href="/2024/09/24/MIT-6-1810-Xv6-Chapter-1/">[MIT 6.1810]Xv6 Chapter 1</a></p><p class="categories"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"><img src="/cover/C++.svg" alt="[C++] 返回值优化"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T05:17:42.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/">[C++] 返回值优化</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">September 2024</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-1810/"><span class="tag">MIT 6.1810</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-S081/"><span class="tag">MIT 6.S081</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/Snake.svg" alt="ErlsrnBy04" height="28"></a><p class="is-size-7"><span>&copy; 2024 ErlsrnBy04</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">且陶陶，乐尽天真</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/ErlsrnBy04"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>