<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[C++]C++Primer Chapter 7 - ErlsrnBy04</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ErlsrnBy04"><meta name="msapplication-TileImage" content="/img/Snake.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ErlsrnBy04"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="类"><meta property="og:type" content="blog"><meta property="og:title" content="[C++]C++Primer Chapter 7"><meta property="og:url" content="https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-7/"><meta property="og:site_name" content="ErlsrnBy04"><meta property="og:description" content="类"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://erlsrnby04.github.io/cover/C++.svg"><meta property="article:published_time" content="2024-09-22T04:01:07.000Z"><meta property="article:modified_time" content="2024-09-22T05:57:53.077Z"><meta property="article:author" content="ErlsrnBy04"><meta property="article:tag" content="C++"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://erlsrnby04.github.io/cover/C++.svg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-7/"},"headline":"[C++]C++Primer Chapter 7","image":[],"datePublished":"2024-09-22T04:01:07.000Z","dateModified":"2024-09-22T05:57:53.077Z","author":{"@type":"Person","name":"ErlsrnBy04"},"publisher":{"@type":"Organization","name":"ErlsrnBy04","logo":{"@type":"ImageObject","url":"https://erlsrnby04.github.io/img/Snake.svg"}},"description":"类"}</script><link rel="canonical" href="https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-7/"><link rel="icon" href="/img/Snake.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/Snake.svg" alt="ErlsrnBy04" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub 主页" href="https://github.com/ErlsrnBy04"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:07.000Z" title="2024/9/22 12:01:07">2024-09-22</time></span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span><span class="level-item">an hour read (About 6890 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">[C++]C++Primer Chapter 7</h1><div class="content"><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><span id="more"></span>

<p>类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程（以及设计）技术。</p>
<p>类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<p>类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。</p>
<h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><h3 id="7-1-1-设计Sales-data类"><a href="#7-1-1-设计Sales-data类" class="headerlink" title="7.1.1 设计Sales_data类"></a>7.1.1 设计Sales_data类</h3><p>由于14.1节（第490页）将要解释的原因，执行加法和IO的函数不作为Sales_data的成员，相反的，我们将其定义成普通函数；执行复合赋值运算的函数是成员函数。</p>
<h3 id="7-1-2-定义改进的Sales-data类"><a href="#7-1-2-定义改进的Sales-data类" class="headerlink" title="7.1.2 定义改进的Sales_data类"></a>7.1.2 定义改进的Sales_data类</h3><p><strong>引入this</strong></p>
<p>this是一个常量指针，指向“这个”对象。</p>
<p><strong>引入const成员函数</strong></p>
<p>把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。</p>
<blockquote>
<p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
</blockquote>
<p><strong>类作用域和成员函数</strong></p>
<p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<p><strong>在类的外部定义成员函数</strong></p>
<p><strong>定义一个返回this对象的函数</strong></p>
<p>内置的赋值运算符把它的左侧运算对象当成<strong>左值</strong>返回（参见4.4节，第129页），因此为了与它保持一致，combine函数（重载赋值运算符）必须返回引用类型（参见6.3.2节，第202页）。因为此时的左侧运算对象是一个Sales_data的对象，所以返回类型应该是Sales_data&amp;。</p>
<h3 id="7-1-3-定义类相关的非成员函数"><a href="#7-1-3-定义类相关的非成员函数" class="headerlink" title="7.1.3 定义类相关的非成员函数"></a>7.1.3 定义类相关的非成员函数</h3><p>我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来（参见6.1.2节，第168页）。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。</p>
<blockquote>
<p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</p>
</blockquote>
<p><strong>定义read和print函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726041043380.png"></p>
<p>第一点，read和print分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能被拷贝的类型，因此我们只能通过引用来传递它们（参见6.2.2节，第188页）。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。</p>
<p>第二点，print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。</p>
<p><strong>定义add函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726041120522.png"></p>
<h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数（constructor）。</p>
<p>不同于其他成员函数，构造函数不能被声明成const的（参见7.1.2节，第231页）。</p>
<p><strong>合成的默认构造函数</strong></p>
<p>类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数（default constructor）。默认构造函数无须任何实参。</p>
<p>如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：</p>
<p>如果存在类内的初始值（参见2.6.1节，第64页），用它来初始化成员。</p>
<p>否则，默认初始化（参见2.2.1节，第40页）该成员。</p>
<p><strong>某些类不能依赖于合成的默认构造函数</strong></p>
<blockquote>
<p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</p>
</blockquote>
<blockquote>
<p>如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。</p>
</blockquote>
<p>如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。</p>
<p><strong>&#x3D; default的含义</strong></p>
<p>在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上&#x3D; default来要求编译器生成构造函数。其中，&#x3D; default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果&#x3D; default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。</p>
<p><strong>构造函数初始值列表</strong></p>
<blockquote>
<p>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p>
</blockquote>
<h3 id="7-1-5-拷贝、赋值和析构"><a href="#7-1-5-拷贝、赋值和析构" class="headerlink" title="7.1.5 拷贝、赋值和析构"></a>7.1.5 拷贝、赋值和析构</h3><h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h2><p>在C++语言中，我们使用访问说明符（access specifiers）加强类的封装性</p>
<p>定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。</p>
<p>定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。</p>
<h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726041734487.png"></p>
<p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。</p>
<blockquote>
<p>一般来说，最好在类定义开始或结束前的位置集中声明友元。</p>
</blockquote>
<p><strong>关键概念：封装的益处</strong></p>
<p>封装有两个重要的优点：</p>
<p>确保用户代码不会无意间破坏封装对象的状态。</p>
<p>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</p>
<p><strong>友元的声明</strong></p>
<p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>
<p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。</p>
<h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><h3 id="7-3-1-类成员再探"><a href="#7-3-1-类成员再探" class="headerlink" title="7.3.1 类成员再探"></a>7.3.1 类成员再探</h3><p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。用来定义类型的成员必须先定义后使用。</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726041953519.png"></p>
<p><strong>令成员作为内联函数</strong></p>
<p>我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，<strong>最好</strong>只在类外部定义的地方说明inline，这样可以使类更容易理解。</p>
<blockquote>
<p>inline成员函数也应该与相应的类定义在同一个头文件中。</p>
</blockquote>
<p><strong>重载成员函数</strong></p>
<p><strong>可变数据成员</strong></p>
<p>有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。</p>
<p>一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。</p>
<p><strong>类数据成员的初始值</strong></p>
<p>类内初始值必须使用&#x3D;的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。</p>
<blockquote>
<p>当我们提供一个类内初始值时，必须以符号&#x3D;或者花括号表示。</p>
</blockquote>
<h3 id="7-3-2-返回-this的成员函数"><a href="#7-3-2-返回-this的成员函数" class="headerlink" title="7.3.2 返回*this的成员函数"></a>7.3.2 返回*this的成员函数</h3><p><strong>从const成员函数返回＊this</strong></p>
<blockquote>
<p>一个const成员函数如果以引用的形式返回＊this，那么它的返回类型将是常量引用。</p>
</blockquote>
<p><strong>基于const的重载</strong></p>
<p>通过区分成员函数是否是const的，我们可以对其进行重载</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726042483856.png"></p>
<p><strong>建议：对于公共代码使用私有功能函数</strong></p>
<h3 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a>7.3.3 类类型</h3><p>每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。</p>
<p><strong>类的声明</strong></p>
<p>我们也能仅仅声明类而暂时不定义它</p>
<p>这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。</p>
<p>一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针</p>
<h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h3><p>类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。</p>
<p><strong>类之间的友元关系</strong></p>
<p>友元关系不存在传递性。</p>
<p><strong>令成员函数作为友元</strong></p>
<p>除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726042842056.png"></p>
<p>首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。</p>
<p>接下来定义Screen，包括对于clear的友元声明。</p>
<p>最后定义clear，此时它才可以使用Screen的成员。</p>
<p><strong>函数重载和友元</strong></p>
<p>尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明</p>
<p><strong>友元声明和作用域</strong></p>
<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中（参见7.2.1节，第241页）。</p>
<p>甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726043654206.png"></p>
<p>友元声明的作用是影响访问权限，它本身并非普通意义上的声明。</p>
<h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><p><strong>作用域和定义在类外部的成员</strong></p>
<p>一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。</p>
<p>函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726044971921.png"></p>
<h3 id="7-4-1-名字查找与类的作用域"><a href="#7-4-1-名字查找与类的作用域" class="headerlink" title="7.4.1 名字查找与类的作用域"></a>7.4.1 名字查找与类的作用域</h3><blockquote>
<p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p>
</blockquote>
<p><strong>用于类成员声明的名字查找</strong></p>
<p>这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。</p>
<p><strong>类型名要特殊处理</strong></p>
<p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726045253509.png"></p>
<blockquote>
<p>类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。</p>
</blockquote>
<p><strong>成员定义中的普通块作用域的名字查找</strong></p>
<p>成员函数中使用的名字按照如下方式解析：</p>
<p>首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。</p>
<p>如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。</p>
<p>如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。</p>
<p><strong>类作用域之后，在外围的作用域中查</strong></p>
<blockquote>
<p>尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符访问它。</p>
</blockquote>
<h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><h3 id="7-5-1-构造函数初始值列表"><a href="#7-5-1-构造函数初始值列表" class="headerlink" title="7.5.1 构造函数初始值列表"></a>7.5.1 构造函数初始值列表</h3><p>随着构造函数体一开始执行，初始化就完成了。</p>
<p><strong>建议：使用构造函数初始值</strong></p>
<p>在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。</p>
<p><strong>成员初始化的顺序</strong></p>
<p>构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。</p>
<p>成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p>
<blockquote>
<p>最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。</p>
</blockquote>
<p><strong>默认实参和构造函数</strong></p>
<h3 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a>7.5.2 委托构造函数</h3><p>C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。</p>
<p>当这些受委托的构造函数执行完后，接着执行istream&amp;构造函数体的内容。</p>
<h3 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3 默认构造函数的作用"></a>7.5.3 默认构造函数的作用</h3><p>默认初始化在以下情况下发生：</p>
<p>当我们在块作用域内不使用任何初始值定义一个非静态变量（参见2.2.1节，第39页）或者数组时（参见3.5.1节，第101页）。</p>
<p>当一个类本身含有类类型的成员且使用合成的默认构造函数时（参见7.1.4节，第235页）。</p>
<p>当类类型的成员没有在构造函数初始值列表中显式地初始化时（参见7.1.4节，第237页）。</p>
<p>值初始化在以下情况下发生：</p>
<p>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时（参见3.5.1节，第101页）。</p>
<p>当我们不使用初始值定义一个局部静态变量时（参见6.1.1节，第185页）。</p>
<p>当我们通过书写形如T（ ）的表达式显式地请求值初始化时，其中T是类型名（vector的一个构造函数只接受一个实参用于说明vector大小（参见3.3.1节，第88页），它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。</p>
<h3 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a>7.5.4 隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数（converting constructor）。</p>
<blockquote>
<p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p>
</blockquote>
<p><strong>只允许一步类类型转换</strong></p>
<p>编译器只会自动地执行一步类型转换</p>
<p><strong>抑制构造函数定义的隐式转换</strong></p>
<p>关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复</p>
<p><strong>explicit构造函数只能用于直接初始化</strong></p>
<p>发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用&#x3D;）（参见3.2.1节，第76页）。此时，我们只能使用直接初始化而不能使用explicit构造函数</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047200089.png"></p>
<p><strong>为转换显式地使用构造函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047246654.png"></p>
<h3 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a>7.5.5 聚合类</h3><p>聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：</p>
<p>所有成员都是public的。</p>
<p>没有定义任何构造函数。</p>
<p>没有类内初始值（参见2.6.1节，第64页）。</p>
<p>没有基类，也没有virtual函数</p>
<p>我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047334451.png"></p>
<p>初始值的顺序必须与声明的顺序一致，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化（参见3.5.1节，第101页）。</p>
<h3 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a>7.5.6 字面值常量类</h3><p>数据成员都是字面值类型的聚合类（参见7.5.5节，第266页）是字面值常量类。</p>
<p>如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：</p>
<p>数据成员都必须是字面值类型。</p>
<p>类必须至少含有一个constexpr构造函数。</p>
<p>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式（参见2.4.4节，第58页）；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。</p>
<p>类必须使用析构函数的默认定义，该成员负责销毁类的对象（参见7.1.5节，第239页）。</p>
<p><strong>constexpr构造函数</strong></p>
<p>尽管构造函数不能是const的（参见7.1.4节，第235页），但是字面值常量类的构造函数可以是constexpr（参见6.5.2节，第213页）函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。</p>
<p>constexpr构造函数可以声明成&#x3D; default（参见7.1.4节，第237页）的形式（或者是删除函数的形式，我们将在13.1.6节（第449页）介绍相关知识）。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句（参见6.5.2节，第214页））。综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数了</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047654646.png"></p>
<p>constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047729145.png"></p>
<h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><p><strong>声明静态成员</strong></p>
<p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。</p>
<p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</p>
<p>静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。</p>
<p><strong>使用类的静态成员</strong></p>
<p>使用作用域运算符直接访问静态成员。</p>
<p><strong>定义静态成员</strong></p>
<p>当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句</p>
<p>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。</p>
<blockquote>
<p>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。</p>
</blockquote>
<p><strong>静态成员的类内初始化</strong></p>
<p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr（参见7.5.6节，第267页）。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。</p>
<blockquote>
<p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p>
</blockquote>
<p><strong>静态成员能用于某些场景，而普通成员不能</strong></p>
<p>静态数据成员可以是不完全类型（参见7.3.3节，第249页）。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726054107164.png"></p>
<p>静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参</p>
<p><img src="/../images/C-C-Primer-Chapter-7/image-20240922130807902.png"></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>[C++]C++Primer Chapter 7</p><p><a href="https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-7/">https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-7/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>ErlsrnBy04</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-09-22</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-09-22</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/09/22/C-C-Primer-Chapter-8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">[C++]C++Primer Chapter 8</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/09/22/C-C-Primer-Chapter-6/"><span class="level-item">[C++]C++Primer Chapter 6</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><script src="https://giscus.app/client.js" repo="ErlsrnBy04/comments" data-repo="ErlsrnBy04/comments" data-repo-id="R_kgDOM1SRGQ" data-category-id="DIC_kwDOM1SRGc4Cirkj" data-category="Announcements" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar1.jpg" alt="ErlsrnBy04"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ErlsrnBy04</p><p class="is-size-6 is-block">学生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ErlsrnBy04" target="_blank" rel="me noopener">Follow</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#类"><span class="level-left"><span class="level-item">1</span><span class="level-item">类</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-1-定义抽象数据类型"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">7.1 定义抽象数据类型</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-1-1-设计Sales-data类"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">7.1.1 设计Sales_data类</span></span></a></li><li><a class="level is-mobile" href="#7-1-2-定义改进的Sales-data类"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">7.1.2 定义改进的Sales_data类</span></span></a></li><li><a class="level is-mobile" href="#7-1-3-定义类相关的非成员函数"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">7.1.3 定义类相关的非成员函数</span></span></a></li><li><a class="level is-mobile" href="#7-1-4-构造函数"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">7.1.4 构造函数</span></span></a></li><li><a class="level is-mobile" href="#7-1-5-拷贝、赋值和析构"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">7.1.5 拷贝、赋值和析构</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-2-访问控制与封装"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">7.2 访问控制与封装</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-2-1-友元"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">7.2.1 友元</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-3-类的其他特性"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">7.3 类的其他特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-3-1-类成员再探"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">7.3.1 类成员再探</span></span></a></li><li><a class="level is-mobile" href="#7-3-2-返回-this的成员函数"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">7.3.2 返回*this的成员函数</span></span></a></li><li><a class="level is-mobile" href="#7-3-3-类类型"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">7.3.3 类类型</span></span></a></li><li><a class="level is-mobile" href="#7-3-4-友元再探"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">7.3.4 友元再探</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-4-类的作用域"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">7.4 类的作用域</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-4-1-名字查找与类的作用域"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">7.4.1 名字查找与类的作用域</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-5-构造函数再探"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">7.5 构造函数再探</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#7-5-1-构造函数初始值列表"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">7.5.1 构造函数初始值列表</span></span></a></li><li><a class="level is-mobile" href="#7-5-2-委托构造函数"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">7.5.2 委托构造函数</span></span></a></li><li><a class="level is-mobile" href="#7-5-3-默认构造函数的作用"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">7.5.3 默认构造函数的作用</span></span></a></li><li><a class="level is-mobile" href="#7-5-4-隐式的类类型转换"><span class="level-left"><span class="level-item">1.5.4</span><span class="level-item">7.5.4 隐式的类类型转换</span></span></a></li><li><a class="level is-mobile" href="#7-5-5-聚合类"><span class="level-left"><span class="level-item">1.5.5</span><span class="level-item">7.5.5 聚合类</span></span></a></li><li><a class="level is-mobile" href="#7-5-6-字面值常量类"><span class="level-left"><span class="level-item">1.5.6</span><span class="level-item">7.5.6 字面值常量类</span></span></a></li></ul></li><li><a class="level is-mobile" href="#7-6-类的静态成员"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">7.6 类的静态成员</span></span></a></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"><img src="/cover/C++.svg" alt="[C++] 返回值优化"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T05:17:42.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/">[C++] 返回值优化</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-C-Primer-Chapter-14/"><img src="/cover/C++.svg" alt="[C++]C++Primer Chapter 14"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:27.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-14/">[C++]C++Primer Chapter 14</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-C-Primer-Chapter-13/"><img src="/cover/C++.svg" alt="[C++]C++Primer Chapter 13"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:25.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-13/">[C++]C++Primer Chapter 13</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-C-Primer-Chapter-12/"><img src="/cover/C++.svg" alt="[C++]C++Primer Chapter 12"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:22.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-12/">[C++]C++Primer Chapter 12</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-C-Primer-Chapter-11/"><img src="/cover/C++.svg" alt="[C++]C++Primer Chapter 11"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:19.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-11/">[C++]C++Primer Chapter 11</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">September 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-S081/"><span class="tag">MIT 6.S081</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/Snake.svg" alt="ErlsrnBy04" height="28"></a><p class="is-size-7"><span>&copy; 2024 ErlsrnBy04</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">且淘淘，乐尽天真</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/ErlsrnBy04"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>