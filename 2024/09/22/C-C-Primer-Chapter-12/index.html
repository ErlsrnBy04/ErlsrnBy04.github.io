<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>[C++]C++Primer Chapter 12 - ErlsrnBy04</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ErlsrnBy04"><meta name="msapplication-TileImage" content="/img/Snake.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ErlsrnBy04"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="动态内存"><meta property="og:type" content="blog"><meta property="og:title" content="[C++]C++Primer Chapter 12"><meta property="og:url" content="https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-12/"><meta property="og:site_name" content="ErlsrnBy04"><meta property="og:description" content="动态内存"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://erlsrnby04.github.io/cover/C++.svg"><meta property="article:published_time" content="2024-09-22T04:01:22.000Z"><meta property="article:modified_time" content="2024-09-22T05:58:13.980Z"><meta property="article:author" content="ErlsrnBy04"><meta property="article:tag" content="C++"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://erlsrnby04.github.io/cover/C++.svg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-12/"},"headline":"[C++]C++Primer Chapter 12","image":[],"datePublished":"2024-09-22T04:01:22.000Z","dateModified":"2024-09-22T05:58:13.980Z","author":{"@type":"Person","name":"ErlsrnBy04"},"publisher":{"@type":"Organization","name":"ErlsrnBy04","logo":{"@type":"ImageObject","url":"https://erlsrnby04.github.io/img/Snake.svg"}},"description":"动态内存"}</script><link rel="canonical" href="https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-12/"><link rel="icon" href="/img/Snake.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/Snake.svg" alt="ErlsrnBy04" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub 主页" href="https://github.com/ErlsrnBy04"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:22.000Z" title="2024/9/22 12:01:22">2024-09-22</time></span><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></span><span class="level-item">43 minutes read (About 6506 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">[C++]C++Primer Chapter 12</h1><div class="content"><h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><span id="more"></span>

<p>静态内存用来保存局部static对象（参见6.6.1节，第185页）、类static数据成员（参见7.6节，第268页）以及定义在任何函数之外的变量。</p>
<p>栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。</p>
<p>对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间（free store）或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象——即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制。</p>
<h2 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h2><p>为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。</p>
<h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><p><img src="/../images/C-C-Primer-Chapter-12/1726455699143.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726455732235.png"></p>
<p><strong>make_shared函数</strong></p>
<p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p>
<p>类似顺序容器的emplace成员（参见9.3.1节，第308页），make_shared用其参数来构造给定类型的对象。</p>
<p>如果我们不传递任何参数，对象就会进行值初始化（参见3.3.1节，第88页）。</p>
<p><strong>shared_ptr的拷贝和赋值</strong></p>
<p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。</p>
<p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数（reference count）。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数（参见6.2.1节，第188页）以及作为函数的返回值（参见6.3.2节，第201页）时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域（参见6.1.1节，第184页））时，计数器就会递减。</p>
<p>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</p>
<p><strong>shared_ptr自动销毁所管理的对象，shared_ptr还会自动释放相关联的内存</strong></p>
<p>由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。share_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某些元素。在这种情况下，你应该确保用erase删除那些不再需要的shared_ptr元素。</p>
<blockquote>
<p>如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</p>
</blockquote>
<p><strong>使用了动态生存期的资源的类</strong></p>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<p>容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因而使用动态内存的例子。在本节中，我们将定义一个类，它使用动态内存是为了让多个对象能共享相同的底层数据。</p>
<p>某些类分配的资源具有与原对象相独立的生存期。例如，假定我们希望定义一个名为Blob的类，保存一组元素。与容器不同，我们希望Blob对象的不同拷贝之间共享相同的元素。即，当我们拷贝一个Blob时，原Blob对象及其拷贝应该引用相同的底层元素。</p>
<blockquote>
<p>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p>
</blockquote>
<h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3><p><strong>使用new动态分配和初始化对象</strong></p>
<p>默认情况下，动态分配的对象是默认初始化的（参见2.2.1节，第40页），这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。也可以对动态分配的对象进行值初始化（参见3.3.1节，第88页），只需在类型名之后跟一对空括号即可</p>
<p>对于定义了自己的构造函数（参见7.1.4节，第235页）的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的（参见7.1.4节，第236页）。</p>
<p>如果我们提供了一个括号包围的初始化器，就可以使用auto（参见2.5.2节，第61页）从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726457710921.png"></p>
<p><strong>动态分配的const对象</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726457753794.png"></p>
<p><strong>内存耗尽</strong></p>
<p>默认情况下，如果new不能分配所要求的内存空间，它会<strong>抛出一个类型为bad_alloc（参见5.6节，第173页）的异常。</strong>我们可以改变使用new的方式来阻止它抛出异常</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726457804949.png"></p>
<p>这种形式的new为定位new（placement new），其原因我们将在19.1.2节（第729页）中解释。定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。</p>
<p><strong>释放动态内存</strong></p>
<p><strong>指针值和delete</strong></p>
<p>我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针（参见2.3.2节，第48页）。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726457904246.png"></p>
<p><strong>动态对象的生存期直到被释放时为止</strong></p>
<p>返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存</p>
<p><strong>小心：动态内存的管理非常容易出错</strong></p>
<p>使用new和delete管理动态内存存在三个常见问题：</p>
<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。</li>
<li>同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。相对于查找和修正这些错误来说，制造出这些错误要简单得多。</li>
</ul>
<p><strong>delete之后重置指针值，这只是提供了有限的保护</strong></p>
<h3 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h3><p>如果我们不初始化一个智能指针，它就会被初始化为一个空指针。如表12.3所示，我们还可以用new返回的指针来初始化智能指针</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726459676176.png"></p>
<p>接受指针参数的智能指针构造函数是explicit的（参见7.5.4节，第265页）。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式（参见3.2.1节，第76页）来初始化一个智能指针</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726464938912.png"></p>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。</p>
<p>我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代delete。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726465035838.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726465039905.png"></p>
<p><strong>不要混合使用普通指针和智能指针</strong></p>
<p>shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）之间。这也是为什么我们推荐使用make_shared而不是new的原因。这样，我们就能在分配对象的同时就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的shared_ptr上。</p>
<p><strong>也不要使用get初始化另一个智能指针或为智能指针赋值</strong></p>
<p>智能指针类型定义了一个名为get的函数（参见表12.1），它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针。</p>
<p>将另一个智能指针也绑定到get返回的指针上是错误的。</p>
<blockquote>
<p><strong>get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。</strong></p>
</blockquote>
<h3 id="12-1-4-智能指针和异常"><a href="#12-1-4-智能指针和异常" class="headerlink" title="12.1.4 智能指针和异常"></a>12.1.4 智能指针和异常</h3><p>一个简单的确保资源被释放的方法是使用智能指针。如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放</p>
<p><strong>智能指针和哑类</strong></p>
<p>包括所有标准库类在内的很多C++类都定义了析构函数（参见12.1.1节，第402页），负责清理对象使用的资源。但是，不是所有的类都是这样良好定义的。特别是那些为C和C++两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726466771589.png"></p>
<p>如果connection有一个析构函数，就可以在f结束时由析构函数自动关闭连接。但是，connection没有析构函数。这个问题与我们上一个程序中使用shared_ptr避免内存泄漏几乎是等价的。使用shared_ptr来保证connection被正确关闭，已被证明是一种有效的方法。</p>
<p><strong>使用我们自己的释放操作</strong></p>
<p>默认情况下，shared_ptr假定它们指向的是动态内存。因此，当一个shared_ptr被销毁时，它默认地对它管理的指针进行delete操作。为了用shared_ptr来管理一个connection，我们必须首先定义一个函数来代替delete。这个删除器（deleter）函数必须能够完成对shared_ptr中保存的指针进行释放的操作。在本例中，我们的删除器必须接受单个类型为connection＊的参数</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726466818477.png"></p>
<p>当我们创建一个shared_ptr时，可以传递一个（可选的）指向删除器函数的参数（参见6.7节，第221页）</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726466848414.png"></p>
<p><strong>注意：智能指针陷阱</strong></p>
<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：</p>
<ul>
<li>不使用相同的内置指针值初始化（或reset）多个智能指针。</li>
<li>不delete get（）返回的指针。</li>
<li>不使用get（）初始化或reset另一个智能指针。</li>
<li>如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（参见12.1.4节，第415页和12.1.5节，第419页）。</li>
</ul>
<h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><p>一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467400523.png"></p>
<p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作</p>
<p>虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467583660.png"></p>
<p><strong>传递unique_ptr参数和返回unique_ptr</strong></p>
<p>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467663330.png"></p>
<p>还可以返回一个局部对象的拷贝</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467672422.png"></p>
<p>对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”，我们将在13.6.2节（第473页）中介绍它。</p>
<p><strong>向unique_ptr传递删除器</strong></p>
<p>unique_ptr管理删除器的方式与shared_ptr不同，其原因我们将在16.1.6节（第599页）中介绍。</p>
<p>重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造（或reset）该类型的对象。与重载关联容器的比较操作（参见11.2.2节，第378页）类似，我们必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或reset一个这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467975308.png"></p>
<h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><p>weak_ptr（见表12.5）是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726468083703.png"></p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它。</p>
<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象的shared_ptr。与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就会一直存在。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726468125244.png"></p>
<h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><p>C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力，原因我们将在12.2.2节（第427页）中解释。</p>
<p>使用容器的类可以使用默认版本的拷贝、赋值和析构操作（参见7.1.5节，第239页）。分配动态数组的类则必须定义自己版本的操作，在拷贝、复制以及销毁对象时管理所关联的内存。</p>
<h3 id="12-2-1-new和数组"><a href="#12-2-1-new和数组" class="headerlink" title="12.2.1 new和数组"></a>12.2.1 new和数组</h3><p>为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针</p>
<p><strong>分配一个数组会得到一个元素类型的指针</strong></p>
<p>由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end（参见3.5.3节，第106页）。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理（所谓的）动态数组中的元素。</p>
<blockquote>
<p>要记住我们所说的动态数组并不是数组类型，这是很重要的。</p>
</blockquote>
<p><strong>初始化动态分配对象的数组</strong></p>
<p>默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化（参见3.3.1节，第88页），方法是在大小之后跟一对空括号。</p>
<p>在新标准中，我们还可以提供一个元素初始化器的花括号列表。如果初始化器数目小于元素数目，剩余元素将进行值初始化。如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。在本例中，new会抛出一个类型为bad_array_new_length的异常。类似bad_alloc，此类型定义在头文件new中。</p>
<p><strong>动态分配一个空数组是合法的</strong></p>
<p>当n等于0时，调用new[n]是合法的。</p>
<p>new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样（参见3.5.3节，第106页），我们可以像使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。</p>
<p><strong>释放动态数组</strong></p>
<p>为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469237720.png"></p>
<p>数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。</p>
<p>如果我们在delete一个指向数组的指针时忽略了方括号（或者在delete一个指向单一对象的指针时使用了方括号），其行为是未定义的。</p>
<p><strong>智能指针和动态数组</strong></p>
<p>标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469303812.png"></p>
<p>指向数组的unique_ptr提供的操作与我们在12.1.5节（第417页）中使用的那些操作有一些不同</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469328221.png"></p>
<p>与unique_ptr不同，shared_ptr不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469386578.png"></p>
<p>shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469425165.png"></p>
<h3 id="12-2-2-allocator类"><a href="#12-2-2-allocator类" class="headerlink" title="12.2.2 allocator类"></a>12.2.2 allocator类</h3><p>new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。</p>
<p>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。</p>
<p><strong>allocator类</strong></p>
<p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726475054676.png"></p>
<p>类似vector，allocator是一个模板（参见3.3节，第86页）。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726475061308.png"></p>
<p><strong>allocator分配未构造的内存</strong></p>
<p>在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。</p>
<blockquote>
<p>为了使用allocate返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。</p>
</blockquote>
<p>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数（参见12.1.1节，第402页）</p>
<p>我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。</p>
<p><strong>拷贝和填充未初始化内存的算法</strong></p>
<p>标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。表12.8描述了这些函数，它们都定义在头文件memory中。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726475234959.png"></p>
<p>类似copy，uninitialized_copy返回（递增后的）目的位置迭代器。</p>
<p>因此，一次uninitialized_copy调用会返回一个指针，指向最后一个构造的元素之后的位置。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>[C++]C++Primer Chapter 12</p><p><a href="https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-12/">https://erlsrnby04.github.io/2024/09/22/C-C-Primer-Chapter-12/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>ErlsrnBy04</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-09-22</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-09-22</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/C/">C++</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2024/09/22/C-C-Primer-Chapter-13/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">[C++]C++Primer Chapter 13</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2024/09/22/C-C-Primer-Chapter-11/"><span class="level-item">[C++]C++Primer Chapter 11</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><script src="https://giscus.app/client.js" repo="ErlsrnBy04/comments" data-repo="ErlsrnBy04/comments" data-repo-id="R_kgDOM1SRGQ" data-category-id="DIC_kwDOM1SRGc4Cirkj" data-category="Announcements" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar1.jpg" alt="ErlsrnBy04"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ErlsrnBy04</p><p class="is-size-6 is-block">学生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">18</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">3</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ErlsrnBy04" target="_blank" rel="me noopener">Follow</a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#动态内存"><span class="level-left"><span class="level-item">1</span><span class="level-item">动态内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#12-1-动态内存与智能指针"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">12.1 动态内存与智能指针</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#12-1-1-shared-ptr类"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">12.1.1 shared_ptr类</span></span></a></li><li><a class="level is-mobile" href="#12-1-2-直接管理内存"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">12.1.2 直接管理内存</span></span></a></li><li><a class="level is-mobile" href="#12-1-3-shared-ptr和new结合使用"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">12.1.3 shared_ptr和new结合使用</span></span></a></li><li><a class="level is-mobile" href="#12-1-4-智能指针和异常"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">12.1.4 智能指针和异常</span></span></a></li><li><a class="level is-mobile" href="#12-1-5-unique-ptr"><span class="level-left"><span class="level-item">1.1.5</span><span class="level-item">12.1.5 unique_ptr</span></span></a></li><li><a class="level is-mobile" href="#12-1-6-weak-ptr"><span class="level-left"><span class="level-item">1.1.6</span><span class="level-item">12.1.6 weak_ptr</span></span></a></li></ul></li><li><a class="level is-mobile" href="#12-2-动态数组"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">12.2 动态数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#12-2-1-new和数组"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">12.2.1 new和数组</span></span></a></li><li><a class="level is-mobile" href="#12-2-2-allocator类"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">12.2.2 allocator类</span></span></a></li></ul></li></ul></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-24T07:43:10.000Z">2024-09-24</time></p><p class="title"><a href="/2024/09/24/MIT-6-1810-Xv6-Chapter-2/">[MIT 6.1810]Xv6 Chapter 2</a></p><p class="categories"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-24T05:11:40.000Z">2024-09-24</time></p><p class="title"><a href="/2024/09/24/MIT-6-1810-Xv6-Chapter-1/">[MIT 6.1810]Xv6 Chapter 1</a></p><p class="categories"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/"><img src="/cover/C++.svg" alt="[C++] 返回值优化"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T05:17:42.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/">[C++] 返回值优化</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-C-Primer-Chapter-14/"><img src="/cover/C++.svg" alt="[C++]C++Primer Chapter 14"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:27.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-14/">[C++]C++Primer Chapter 14</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2024/09/22/C-C-Primer-Chapter-13/"><img src="/cover/C++.svg" alt="[C++]C++Primer Chapter 13"></a></figure><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:25.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-13/">[C++]C++Primer Chapter 13</a></p><p class="categories"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">September 2024</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-1810/"><span class="tag">MIT 6.1810</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-S081/"><span class="tag">MIT 6.S081</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/Snake.svg" alt="ErlsrnBy04" height="28"></a><p class="is-size-7"><span>&copy; 2024 ErlsrnBy04</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">且陶陶，乐尽天真</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/ErlsrnBy04"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>