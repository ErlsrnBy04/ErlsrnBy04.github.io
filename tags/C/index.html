<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: C++ - ErlsrnBy04</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ErlsrnBy04"><meta name="msapplication-TileImage" content="/img/Snake.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ErlsrnBy04"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="ErlsrnBy04"><meta property="og:url" content="https://erlsrnby04.github.io/"><meta property="og:site_name" content="ErlsrnBy04"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://erlsrnby04.github.io/img/og_image.png"><meta property="article:author" content="ErlsrnBy04"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://erlsrnby04.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ErlsrnBy04.github.io"},"headline":"ErlsrnBy04","image":["https://erlsrnby04.github.io/img/og_image.png"],"author":{"@type":"Person","name":"ErlsrnBy04"},"publisher":{"@type":"Organization","name":"ErlsrnBy04","logo":{"@type":"ImageObject","url":"https://erlsrnby04.github.io/img/Snake.svg"}},"description":""}</script><link rel="icon" href="/img/Snake.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/Snake.svg" alt="ErlsrnBy04" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="GitHub 主页" href="https://github.com/ErlsrnBy04"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">C++</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T05:17:42.000Z" title="2024/9/22 13:17:42">2024-09-22</time></span><span class="level-item">7 minutes read (About 1024 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/">[C++] 返回值优化</a></p><div class="content"><h3 id="什么是返回值优化？"><a href="#什么是返回值优化？" class="headerlink" title="什么是返回值优化？"></a>什么是返回值优化？</h3><p><strong>返回值优化</strong>（Return Value Optimization, RVO）是C++编译器的一种优化技术，用于减少不必要的对象拷贝，特别是在函数返回临时对象的场景中。RVO 可以显著提高程序性能，并减少临时对象的生成和析构操作。</p>
<p>在C++中，函数返回值通常会涉及临时对象的创建和销毁。例如，当函数返回一个对象时，通常会创建一个临时对象来存储返回值，然后将其拷贝到接收返回值的变量中。返回值优化（RVO）是编译器的一种优化技术，它避免了这些临时对象的拷贝操作。</p>
<h3 id="RVO的工作机制"><a href="#RVO的工作机制" class="headerlink" title="RVO的工作机制"></a>RVO的工作机制</h3><p>通常情况下，返回一个对象的过程涉及两步：</p>
<ol>
<li>创建并初始化一个临时对象（可能是函数内的局部对象）。</li>
<li>将这个临时对象拷贝或移动到调用者提供的目标位置。</li>
</ol>
<p><strong>RVO</strong>通过直接在目标位置构造返回的对象，跳过了临时对象的创建，从而避免了拷贝或移动操作。</p>
<h3 id="例子（无RVO-vs-有RVO）"><a href="#例子（无RVO-vs-有RVO）" class="headerlink" title="例子（无RVO vs. 有RVO）"></a>例子（无RVO vs. 有RVO）</h3><h4 id="没有RVO时："><a href="#没有RVO时：" class="headerlink" title="没有RVO时："></a>没有RVO时：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) &#123; std::cout &lt;&lt; <span class="string">&quot;Copy Constructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Destructor&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;  <span class="comment">// 返回局部对象，会调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass newObj = <span class="built_in">createObject</span>();  <span class="comment">// 接收返回值，会再次拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>createObject()</code>函数返回一个局部对象 <code>obj</code>，在没有RVO的情况下：</p>
<ol>
<li>首先构造局部对象 <code>obj</code>。</li>
<li>然后调用拷贝构造函数将 <code>obj</code>拷贝到一个临时对象（用来保存返回值）。</li>
<li>最后将这个临时对象拷贝到 <code>newObj</code>中。</li>
</ol>
<p>因此，会涉及两次拷贝构造调用，这样的拷贝是性能上的浪费。</p>
<h4 id="有RVO时："><a href="#有RVO时：" class="headerlink" title="有RVO时："></a>有RVO时：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;  <span class="comment">// RVO优化，直接在返回位置构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass newObj = <span class="built_in">createObject</span>();  <span class="comment">// 直接在newObj上构造对象，无需拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在启用RVO的情况下，编译器会跳过临时对象的创建，直接在 <code>newObj</code>的内存位置上构造 <code>obj</code>，避免了不必要的拷贝操作。</p>
<h3 id="RVO的类型"><a href="#RVO的类型" class="headerlink" title="RVO的类型"></a>RVO的类型</h3><ol>
<li><strong>命名返回值优化（Named Return Value Optimization, NRVO）</strong>：NRVO是RVO的一种形式，发生在返回值是命名的局部变量时。例如，函数返回一个命名的局部对象，编译器会直接在调用者的内存空间中构造该对象，而不是先创建一个临时对象。</li>
<li><strong>标准RVO</strong>：标准RVO发生在返回一个未命名的临时对象时。例如，函数返回一个临时构造的对象，而不是局部变量。这种优化在C++17后是强制执行的，不再依赖于编译器是否选择进行优化。</li>
</ol>
<h3 id="C-17-中的强制RVO"><a href="#C-17-中的强制RVO" class="headerlink" title="C++17 中的强制RVO"></a>C++17 中的强制RVO</h3><p>从C++17开始，标准RVO成为强制行为，编译器必须执行返回值优化，不再需要拷贝或移动临时对象。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">createObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>();  <span class="comment">// C++17中，直接在返回位置构造对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C++17之前，编译器可能会选择不进行优化，但从C++17开始，编译器必须直接在目标位置构造返回的对象，从而完全消除了临时对象和拷贝构造的开销。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>RVO</strong>（返回值优化）是一种编译器优化技术，可以在函数返回对象时避免不必要的临时对象拷贝。</li>
<li><strong>NRVO</strong>（命名返回值优化）是RVO的一种形式，应用于返回命名的局部变量。</li>
<li><strong>C++17</strong>中强制执行了RVO，编译器必须优化返回临时对象的场景，进一步提高了程序效率。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:25.000Z" title="2024/9/22 12:01:25">2024-09-22</time></span><span class="level-item">33 minutes read (About 4878 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-13/">[C++]C++Primer Chapter 13</a></p><div class="content"><h1 id="13-拷贝控制"><a href="#13-拷贝控制" class="headerlink" title="13 拷贝控制"></a>13 拷贝控制</h1><p>一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。</p>
<h2 id="13-1-拷贝、赋值与销毁"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁</h2><h3 id="13-1-1-拷贝构造函数"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数</h3><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<p>拷贝构造函数的<strong>第一个参数必须是一个引用类型</strong>，原因我们稍后解释。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数<strong>几乎总是一个const的引用</strong>。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数<strong>通常不应该是explicit的</strong>（参见7.5.4节，第265页）。</p>
<p><strong>合成拷贝构造函数</strong></p>
<p>即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</p>
<p>13.1.6节（第450页）中所见，对某些类来说，合成拷贝构造函数（synthesized copy constructor）用来阻止我们拷贝该类类型的对象。</p>
<p>虽然我们不能直接拷贝一个数组（参见3.5.1节，第102页），但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。</p>
<p><strong>拷贝初始化</strong></p>
<p>当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配（参见6.4节，第209页）来选择与我们提供的参数最匹配的构造函数。当我们使用拷贝初始化（copy initialization）时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换（参见7.5.4节，第263页）。</p>
<p>拷贝初始化不仅在我们用&#x3D;定义变量时会发生，在下列情况下也会发生</p>
<ul>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员（参见7.5.5节，第266页）</li>
</ul>
<p>当我们初始化标准库容器或是调用其insert或push成员（参见9.3.1节，第306页）时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化（参见9.3.1节，第308页）。</p>
<p><strong>参数和返回值</strong></p>
<p>在函数调用过程中，具有非引用类型的参数要进行拷贝初始化（参见6.2.1节，第188页）。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果（参见6.3.2节，第201页）。</p>
<p>拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。</p>
<p><strong>拷贝初始化的限制</strong></p>
<p>如果我们使用的初始化值要求通过一个explicit的构造函数来进行类型转换（参见7.5.4节，第265页），那么使用拷贝初始化还是直接初始化就不是无关紧要的了</p>
<p><img src="/../images/C-C-Primer-Chapter-13/image-20240921002325205.png"></p>
<p><strong>编译器可以绕过拷贝构造函数</strong></p>
<p>在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝&#x2F;移动构造函数，直接创建对象。</p>
<p>但是，即使编译器略过了拷贝&#x2F;移动构造函数，但在这个程序点上，拷贝&#x2F;移动构造函数必须是存在且可访问的（例如，不能是private的）。</p>
<h3 id="13-1-2-拷贝赋值运算符"><a href="#13-1-2-拷贝赋值运算符" class="headerlink" title="13.1.2 拷贝赋值运算符"></a>13.1.2 拷贝赋值运算符</h3><p>如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。</p>
<p><strong>重载赋值运算符</strong></p>
<p>重载运算符本质上是函数，其名字由operator关键字后接表示要定义的运算符的符号组成。</p>
<p>某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this参数（参见7.1.2节，第231页）。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p>
<p>为了与内置类型的赋值（参见4.4节，第129页）保持一致，赋值运算符通常<strong>返回一个指向其左侧运算对象的引用。</strong></p>
<p><strong>标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</strong></p>
<blockquote>
<p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
</blockquote>
<p><strong>合成拷贝赋值运算符</strong></p>
<p>对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。</p>
<h3 id="13-1-3-析构函数"><a href="#13-1-3-析构函数" class="headerlink" title="13.1.3 析构函数"></a>13.1.3 析构函数</h3><p>析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。</p>
<p>析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数</p>
<p>由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。</p>
<p><strong>析构函数完成什么工作</strong></p>
<p>如同构造函数有一个初始化部分和一个函数体（参见7.5.1节，第257页），析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。<strong>在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。</strong></p>
<p><strong>什么时候会调用析构函数</strong></p>
<p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li>
<li>对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁（参见12.1.2节，第409页）。</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ul>
<p><strong>合成析构函数</strong></p>
<p>类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁（参见13.1.6节，第450页）。如果不是这种情况，合成析构函数的函数体就为空。</p>
<p>认识到<strong>析构函数体自身并不直接销毁成员是非常重要的。</strong>成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。</p>
<h3 id="13-1-4-三-五法则"><a href="#13-1-4-三-五法则" class="headerlink" title="13.1.4 三&#x2F;五法则"></a>13.1.4 三&#x2F;五法则</h3><p>有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符，我们将在13.6节（第470页）中介绍这些内容。</p>
<p><strong>需要析构函数的类也需要拷贝和赋值操作</strong></p>
<p><strong>需要拷贝操作的类也需要赋值操作，反之亦然</strong></p>
<p>无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。</p>
<h3 id="13-1-5-使用-default"><a href="#13-1-5-使用-default" class="headerlink" title="13.1.5 使用&#x3D;default"></a>13.1.5 使用&#x3D;default</h3><p>我们可以通过将拷贝控制成员定义为&#x3D;default来显式地要求编译器生成合成的版本（参见7.1.4节，第237页）</p>
<p><img src="/../images/C-C-Primer-Chapter-13/image-20240921004332914.png"></p>
<p>当我们在类内用&#x3D;default修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用&#x3D;default，就像对拷贝赋值运算符所做的那样。</p>
<h3 id="13-1-6-阻止拷贝"><a href="#13-1-6-阻止拷贝" class="headerlink" title="13.1.6 阻止拷贝"></a>13.1.6 阻止拷贝</h3><blockquote>
<p>大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。</p>
</blockquote>
<p>对某些类来说，这些操作没有合理的意义。在此情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream类阻止了拷贝，以避免多个对象写入或读取相同的IO缓冲。</p>
<p><strong>定义删除的函数</strong></p>
<p>在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上&#x3D;delete来指出我们希望将它定义为删除的</p>
<p><img src="/../images/C-C-Primer-Chapter-13/image-20240921004625361.png"></p>
<p><strong>与&#x3D;default不同，&#x3D;delete必须出现在函数第一次声明的时候</strong></p>
<p>与&#x3D;default的另一个不同之处是，我们可以对任何函数指定&#x3D;delete（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用&#x3D;default）。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。</p>
<p><strong>析构函数不能是删除的成员</strong></p>
<p>值得注意的是，我们不能删除析构函数。</p>
<p>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象</p>
<p><strong>合成的拷贝控制成员可能是删除的</strong></p>
<p>对某些类来说，编译器将这些合成的成员定义为删除的函数：</p>
<ul>
<li>如果类的某个成员的<strong>析构函数</strong>是删除的或不可访问的（例如，是private的），则类的合成析构函数被定义为删除的。</li>
<li>如果类的某个成员的<strong>拷贝构造函数</strong>是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。</li>
<li>如果类的某个成员的<strong>析构函数</strong>是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。</li>
<li>如果类的某个成员的<strong>拷贝赋值运算符</strong>是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。</li>
<li>如果类的某个成员的<strong>析构函数</strong>是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器（参见2.6.1节，第65页），或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。</li>
</ul>
<p><strong>本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</strong></p>
<p><strong>private拷贝控制</strong></p>
<p>在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝</p>
<p>声明但不定义一个成员函数是合法的（参见6.1.2节，第186页），对此只有一个例外，我们将在15.2.1节（第528页）中介绍。试图访问一个未定义的成员将导致一个链接时错误。通过声明（但不定义）private的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。</p>
<h2 id="13-2-拷贝控制和资源管理"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理</h2><p>首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。</p>
<p>类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。</p>
<p>行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。</p>
<p>在我们使用过的标准库类中，标准库容器和string类的行为像一个值。而不出意外的，shared_ptr类提供类似指针的行为，就像我们的StrBlob类（参见12.1.1节，第405页）一样，IO类型和unique_ptr不允许拷贝或赋值，因此它们的行为既不像值也不像指针。</p>
<h3 id="13-2-1-行为像值的类"><a href="#13-2-1-行为像值的类" class="headerlink" title="13.2.1 行为像值的类"></a>13.2.1 行为像值的类</h3><p>为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。</p>
<p><strong>类值拷贝赋值运算符</strong></p>
<p>赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。但是，<strong>非常重要的一点是，这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保证正确。</strong>而且，如果可能，我们编写的赋值运算符还应该是异常安全的——当异常发生时能将左侧运算对象置于一个有意义的状态（参见5.6.2节，第175页）。</p>
<p>通过<strong>先拷贝右侧运算对象</strong>，我们可以处理自赋值情况，并能保证在异常发生时代码也是安全的。</p>
<p><strong>关键概念：赋值运算符</strong></p>
<p>当你编写赋值运算符时，有两点需要记住：</p>
<ul>
<li>如果将一个对象赋予它自身，赋值运算符必须能正确工作。</li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作。</li>
</ul>
<p>当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。</p>
<h3 id="13-2-2-定义行为像指针的类"><a href="#13-2-2-定义行为像指针的类" class="headerlink" title="13.2.2 定义行为像指针的类"></a>13.2.2 定义行为像指针的类</h3><p>对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。</p>
<p>析构函数不能单方面地释放关联的string。只有当最后一个指向string的HasPtr销毁时，它才可以释放string。</p>
<p>令一个类展现类似指针的行为的最好方法是使用shared_ptr来管理类中的资源。</p>
<p>但是，有时我们希望直接管理资源。在这种情况下，使用<strong>引用计数（reference count）</strong>（参见12.1.1节，第402页）就很有用了。</p>
<p><strong>引用计数</strong></p>
<p>引用计数的工作方式如下：</p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li>
<li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。</li>
<li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li>
</ul>
<p>计数器不能直接作为HasPtr对象的成员。</p>
<p>解决此问题的一种方法是<strong>将计数器保存在动态内存中</strong>。当创建一个对象时，我们也分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。</p>
<p><strong>定义一个使用引用计数的类</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-13/image-20240921010258313.png"></p>
<p><strong>类指针的拷贝成员“篡改”引用计数</strong></p>
<p>析构函数不能无条件地delete ps——可能还有其他对象指向这块内存。析构函数应该递减引用计数，指出共享string的对象少了一个。如果计数器变为0，则析构函数释放ps和use指向的内存</p>
<p><img src="/../images/C-C-Primer-Chapter-13/image-20240921010338251.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-13/image-20240921010440242.png"></p>
<h2 id="13-3-交换操作"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:22.000Z" title="2024/9/22 12:01:22">2024-09-22</time></span><span class="level-item">43 minutes read (About 6505 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-12/">[C++]C++Primer Chapter 12</a></p><div class="content"><h1 id="12-动态内存"><a href="#12-动态内存" class="headerlink" title="12 动态内存"></a>12 动态内存</h1><p>静态内存用来保存局部static对象（参见6.6.1节，第185页）、类static数据成员（参见7.6节，第268页）以及定义在任何函数之外的变量。</p>
<p>栈内存用来保存定义在函数内的非static对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。</p>
<p>对于栈对象，仅在其定义的程序块运行时才存在；static对象在使用之前分配，在程序结束时销毁。</p>
<p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作自由空间（free store）或堆（heap）。程序用堆来存储动态分配（dynamically allocate）的对象——即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制。</p>
<h2 id="12-1-动态内存与智能指针"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针</h2><p>为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr则“独占”所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在memory头文件中。</p>
<h3 id="12-1-1-shared-ptr类"><a href="#12-1-1-shared-ptr类" class="headerlink" title="12.1.1 shared_ptr类"></a>12.1.1 shared_ptr类</h3><p><img src="/../images/C-C-Primer-Chapter-12/1726455699143.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726455732235.png"></p>
<p><strong>make_shared函数</strong></p>
<p>最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。</p>
<p>类似顺序容器的emplace成员（参见9.3.1节，第308页），make_shared用其参数来构造给定类型的对象。</p>
<p>如果我们不传递任何参数，对象就会进行值初始化（参见3.3.1节，第88页）。</p>
<p><strong>shared_ptr的拷贝和赋值</strong></p>
<p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象。</p>
<p>我们可以认为每个shared_ptr都有一个关联的计数器，通常称其为引用计数（reference count）。无论何时我们拷贝一个shared_ptr，计数器都会递增。例如，当用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给一个函数（参见6.2.1节，第188页）以及作为函数的返回值（参见6.3.2节，第201页）时，它所关联的计数器就会递增。当我们给shared_ptr赋予一个新值或是shared_ptr被销毁（例如一个局部的shared_ptr离开其作用域（参见6.1.1节，第184页））时，计数器就会递减。</p>
<p>一旦一个shared_ptr的计数器变为0，它就会自动释放自己所管理的对象。</p>
<p><strong>shared_ptr自动销毁所管理的对象，shared_ptr还会自动释放相关联的内存</strong></p>
<p>由于在最后一个shared_ptr销毁前内存都不会释放，保证shared_ptr在无用之后不再保留就非常重要了。如果你忘记了销毁程序不再需要的shared_ptr，程序仍会正确执行，但会浪费内存。share_ptr在无用之后仍然保留的一种可能情况是，你将shared_ptr存放在一个容器中，随后重排了容器，从而不再需要某些元素。在这种情况下，你应该确保用erase删除那些不再需要的shared_ptr元素。</p>
<blockquote>
<p>如果你将shared_ptr存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用erase删除不再需要的那些元素。</p>
</blockquote>
<p><strong>使用了动态生存期的资源的类</strong></p>
<p>程序使用动态内存出于以下三种原因之一：</p>
<ul>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ul>
<p>容器类是出于第一种原因而使用动态内存的典型例子，我们将在第15章看到出于第二种原因而使用动态内存的例子。在本节中，我们将定义一个类，它使用动态内存是为了让多个对象能共享相同的底层数据。</p>
<p>某些类分配的资源具有与原对象相独立的生存期。例如，假定我们希望定义一个名为Blob的类，保存一组元素。与容器不同，我们希望Blob对象的不同拷贝之间共享相同的元素。即，当我们拷贝一个Blob时，原Blob对象及其拷贝应该引用相同的底层元素。</p>
<blockquote>
<p>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p>
</blockquote>
<h3 id="12-1-2-直接管理内存"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存</h3><p><strong>使用new动态分配和初始化对象</strong></p>
<p>默认情况下，动态分配的对象是默认初始化的（参见2.2.1节，第40页），这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。也可以对动态分配的对象进行值初始化（参见3.3.1节，第88页），只需在类型名之后跟一对空括号即可</p>
<p>对于定义了自己的构造函数（参见7.1.4节，第235页）的类类型（例如string）来说，要求值初始化是没有意义的；不管采用什么形式，对象都会通过默认构造函数来初始化。但对于内置类型，两种形式的差别就很大了；值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的值则是未定义的。类似的，对于类中那些依赖于编译器合成的默认构造函数的内置类型成员，如果它们未在类内被初始化，那么它们的值也是未定义的（参见7.1.4节，第236页）。</p>
<p>如果我们提供了一个括号包围的初始化器，就可以使用auto（参见2.5.2节，第61页）从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用auto</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726457710921.png"></p>
<p><strong>动态分配的const对象</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726457753794.png"></p>
<p><strong>内存耗尽</strong></p>
<p>默认情况下，如果new不能分配所要求的内存空间，它会<strong>抛出一个类型为bad_alloc（参见5.6节，第173页）的异常。</strong>我们可以改变使用new的方式来阻止它抛出异常</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726457804949.png"></p>
<p>这种形式的new为定位new（placement new），其原因我们将在19.1.2节（第729页）中解释。定位new表达式允许我们向new传递额外的参数。在此例中，我们传递给它一个由标准库定义的名为nothrow的对象。如果将nothrow传递给new，我们的意图是告诉它不能抛出异常。如果这种形式的new不能分配所需内存，它会返回一个空指针。bad_alloc和nothrow都定义在头文件new中。</p>
<p><strong>释放动态内存</strong></p>
<p><strong>指针值和delete</strong></p>
<p>我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针（参见2.3.2节，第48页）。释放一块并非new分配的内存，或者将相同的指针值释放多次，其行为是未定义的</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726457904246.png"></p>
<p><strong>动态对象的生存期直到被释放时为止</strong></p>
<p>返回指向动态内存的指针（而不是智能指针）的函数给其调用者增加了一个额外负担——调用者必须记得释放内存</p>
<p><strong>小心：动态内存的管理非常容易出错</strong></p>
<p>使用new和delete管理动态内存存在三个常见问题：</p>
<ul>
<li>忘记delete内存。忘记释放动态内存会导致人们常说的“内存泄漏”问题，因为这种内存永远不可能被归还给自由空间了。查找内存泄露错误是非常困难的，因为通常应用程序运行很长时间后，真正耗尽内存时，才能检测到这种错误。</li>
<li>使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。</li>
<li>同一块内存释放两次。当有两个指针指向相同的动态分配对象时，可能发生这种错误。如果对其中一个指针进行了delete操作，对象的内存就被归还给自由空间了。如果我们随后又delete第二个指针，自由空间就可能被破坏。相对于查找和修正这些错误来说，制造出这些错误要简单得多。</li>
</ul>
<p><strong>delete之后重置指针值，这只是提供了有限的保护</strong></p>
<h3 id="12-1-3-shared-ptr和new结合使用"><a href="#12-1-3-shared-ptr和new结合使用" class="headerlink" title="12.1.3 shared_ptr和new结合使用"></a>12.1.3 shared_ptr和new结合使用</h3><p>如果我们不初始化一个智能指针，它就会被初始化为一个空指针。如表12.3所示，我们还可以用new返回的指针来初始化智能指针</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726459676176.png"></p>
<p>接受指针参数的智能指针构造函数是explicit的（参见7.5.4节，第265页）。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式（参见3.2.1节，第76页）来初始化一个智能指针</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726464938912.png"></p>
<p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放它所关联的对象。</p>
<p>我们可以将智能指针绑定到一个指向其他类型的资源的指针上，但是为了这样做，必须提供自己的操作来替代delete。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726465035838.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726465039905.png"></p>
<p><strong>不要混合使用普通指针和智能指针</strong></p>
<p>shared_ptr可以协调对象的析构，但这仅限于其自身的拷贝（也是shared_ptr）之间。这也是为什么我们推荐使用make_shared而不是new的原因。这样，我们就能在分配对象的同时就将shared_ptr与之绑定，从而避免了无意中将同一块内存绑定到多个独立创建的shared_ptr上。</p>
<p><strong>也不要使用get初始化另一个智能指针或为智能指针赋值</strong></p>
<p>智能指针类型定义了一个名为get的函数（参见表12.1），它返回一个内置指针，指向智能指针管理的对象。此函数是为了这样一种情况而设计的：我们需要向不能使用智能指针的代码传递一个内置指针。使用get返回的指针的代码不能delete此指针。</p>
<p>将另一个智能指针也绑定到get返回的指针上是错误的。</p>
<blockquote>
<p><strong>get用来将指针的访问权限传递给代码，你只有在确定代码不会delete指针的情况下，才能使用get。特别是，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。</strong></p>
</blockquote>
<h3 id="12-1-4-智能指针和异常"><a href="#12-1-4-智能指针和异常" class="headerlink" title="12.1.4 智能指针和异常"></a>12.1.4 智能指针和异常</h3><p>一个简单的确保资源被释放的方法是使用智能指针。如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放</p>
<p><strong>智能指针和哑类</strong></p>
<p>包括所有标准库类在内的很多C++类都定义了析构函数（参见12.1.1节，第402页），负责清理对象使用的资源。但是，不是所有的类都是这样良好定义的。特别是那些为C和C++两种语言设计的类，通常都要求用户显式地释放所使用的任何资源。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726466771589.png"></p>
<p>如果connection有一个析构函数，就可以在f结束时由析构函数自动关闭连接。但是，connection没有析构函数。这个问题与我们上一个程序中使用shared_ptr避免内存泄漏几乎是等价的。使用shared_ptr来保证connection被正确关闭，已被证明是一种有效的方法。</p>
<p><strong>使用我们自己的释放操作</strong></p>
<p>默认情况下，shared_ptr假定它们指向的是动态内存。因此，当一个shared_ptr被销毁时，它默认地对它管理的指针进行delete操作。为了用shared_ptr来管理一个connection，我们必须首先定义一个函数来代替delete。这个删除器（deleter）函数必须能够完成对shared_ptr中保存的指针进行释放的操作。在本例中，我们的删除器必须接受单个类型为connection＊的参数</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726466818477.png"></p>
<p>当我们创建一个shared_ptr时，可以传递一个（可选的）指向删除器函数的参数（参见6.7节，第221页）</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726466848414.png"></p>
<p><strong>注意：智能指针陷阱</strong></p>
<p>智能指针可以提供对动态分配的内存安全而又方便的管理，但这建立在正确使用的前提下。为了正确使用智能指针，我们必须坚持一些基本规范：</p>
<ul>
<li>不使用相同的内置指针值初始化（或reset）多个智能指针。</li>
<li>不delete get（）返回的指针。</li>
<li>不使用get（）初始化或reset另一个智能指针。</li>
<li>如果你使用get（）返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。</li>
<li>如果你使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器（参见12.1.4节，第415页和12.1.5节，第419页）。</li>
</ul>
<h3 id="12-1-5-unique-ptr"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr</h3><p>一个unique_ptr“拥有”它所指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467400523.png"></p>
<p>由于一个unique_ptr拥有它指向的对象，因此unique_ptr不支持普通的拷贝或赋值操作</p>
<p>虽然我们不能拷贝或赋值unique_ptr，但可以通过调用release或reset将指针的所有权从一个（非const）unique_ptr转移给另一个unique</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467583660.png"></p>
<p><strong>传递unique_ptr参数和返回unique_ptr</strong></p>
<p>不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的unique_ptr。最常见的例子是从函数返回一个unique_ptr</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467663330.png"></p>
<p>还可以返回一个局部对象的拷贝</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467672422.png"></p>
<p>对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”，我们将在13.6.2节（第473页）中介绍它。</p>
<p><strong>向unique_ptr传递删除器</strong></p>
<p>unique_ptr管理删除器的方式与shared_ptr不同，其原因我们将在16.1.6节（第599页）中介绍。</p>
<p>重载一个unique_ptr中的删除器会影响到unique_ptr类型以及如何构造（或reset）该类型的对象。与重载关联容器的比较操作（参见11.2.2节，第378页）类似，我们必须在尖括号中unique_ptr指向类型之后提供删除器类型。在创建或reset一个这种unique_ptr类型的对象时，必须提供一个指定类型的可调用对象（删除器）</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726467975308.png"></p>
<h3 id="12-1-6-weak-ptr"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr</h3><p>weak_ptr（见表12.5）是一种不控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。一旦最后一个指向对象的shared_ptr被销毁，对象就会被释放。即使有weak_ptr指向对象，对象也还是会被释放。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726468083703.png"></p>
<p>当我们创建一个weak_ptr时，要用一个shared_ptr来初始化它。</p>
<p>由于对象可能不存在，我们不能使用weak_ptr直接访问对象，而必须调用lock。此函数检查weak_ptr指向的对象是否仍存在。如果存在，lock返回一个指向共享对象的shared_ptr。与任何其他shared_ptr类似，只要此shared_ptr存在，它所指向的底层对象也就会一直存在。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726468125244.png"></p>
<h2 id="12-2-动态数组"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组</h2><p>C++语言和标准库提供了两种一次分配一个对象数组的方法。C++语言定义了另一种new表达式语法，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力，原因我们将在12.2.2节（第427页）中解释。</p>
<p>使用容器的类可以使用默认版本的拷贝、赋值和析构操作（参见7.1.5节，第239页）。分配动态数组的类则必须定义自己版本的操作，在拷贝、复制以及销毁对象时管理所关联的内存。</p>
<h3 id="12-2-1-new和数组"><a href="#12-2-1-new和数组" class="headerlink" title="12.2.1 new和数组"></a>12.2.1 new和数组</h3><p>为了让new分配一个对象数组，我们要在类型名之后跟一对方括号，在其中指明要分配的对象的数目。在下例中，new分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针</p>
<p><strong>分配一个数组会得到一个元素类型的指针</strong></p>
<p>由于分配的内存并不是一个数组类型，因此不能对动态数组调用begin或end（参见3.5.3节，第106页）。这些函数使用数组维度（回忆一下，维度是数组类型的一部分）来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围for语句来处理（所谓的）动态数组中的元素。</p>
<blockquote>
<p>要记住我们所说的动态数组并不是数组类型，这是很重要的。</p>
</blockquote>
<p><strong>初始化动态分配对象的数组</strong></p>
<p>默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化（参见3.3.1节，第88页），方法是在大小之后跟一对空括号。</p>
<p>在新标准中，我们还可以提供一个元素初始化器的花括号列表。如果初始化器数目小于元素数目，剩余元素将进行值初始化。如果初始化器数目大于元素数目，则new表达式失败，不会分配任何内存。在本例中，new会抛出一个类型为bad_array_new_length的异常。类似bad_alloc，此类型定义在头文件new中。</p>
<p><strong>动态分配一个空数组是合法的</strong></p>
<p>当n等于0时，调用new[n]是合法的。</p>
<p>new返回一个合法的非空指针。此指针保证与new返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样（参见3.5.3节，第106页），我们可以像使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作，就像上面循环代码中那样。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到0。但此指针不能解引用——毕竟它不指向任何元素。</p>
<p><strong>释放动态数组</strong></p>
<p>为了释放动态数组，我们使用一种特殊形式的delete——在指针前加上一个空方括号对</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469237720.png"></p>
<p>数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。</p>
<p>如果我们在delete一个指向数组的指针时忽略了方括号（或者在delete一个指向单一对象的指针时使用了方括号），其行为是未定义的。</p>
<p><strong>智能指针和动态数组</strong></p>
<p>标准库提供了一个可以管理new分配的数组的unique_ptr版本。为了用一个unique_ptr管理动态数组，我们必须在对象类型后面跟一对空方括号</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469303812.png"></p>
<p>指向数组的unique_ptr提供的操作与我们在12.1.5节（第417页）中使用的那些操作有一些不同</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469328221.png"></p>
<p>与unique_ptr不同，shared_ptr不直接支持管理动态数组。如果希望使用shared_ptr管理一个动态数组，必须提供自己定义的删除器。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469386578.png"></p>
<p>shared_ptr未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须用get获取一个内置指针，然后用它来访问数组元素。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726469425165.png"></p>
<h3 id="12-2-2-allocator类"><a href="#12-2-2-allocator类" class="headerlink" title="12.2.2 allocator类"></a>12.2.2 allocator类</h3><p>new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。</p>
<p>当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象创建操作（同时付出一定开销）。</p>
<p><strong>allocator类</strong></p>
<p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726475054676.png"></p>
<p>类似vector，allocator是一个模板（参见3.3节，第86页）。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726475061308.png"></p>
<p><strong>allocator分配未构造的内存</strong></p>
<p>在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。</p>
<blockquote>
<p>为了使用allocate返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。</p>
</blockquote>
<p>当我们用完对象后，必须对每个构造的元素调用destroy来销毁它们。函数destroy接受一个指针，对指向的对象执行析构函数（参见12.1.1节，第402页）</p>
<p>我们传递给deallocate的指针不能为空，它必须指向由allocate分配的内存。而且，传递给deallocate的大小参数必须与调用allocated分配内存时提供的大小参数具有一样的值。</p>
<p><strong>拷贝和填充未初始化内存的算法</strong></p>
<p>标准库还为allocator类定义了两个伴随算法，可以在未初始化内存中创建对象。表12.8描述了这些函数，它们都定义在头文件memory中。</p>
<p><img src="/../images/C-C-Primer-Chapter-12/1726475234959.png"></p>
<p>类似copy，uninitialized_copy返回（递增后的）目的位置迭代器。</p>
<p>因此，一次uninitialized_copy调用会返回一个指针，指向最后一个构造的元素之后的位置。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:19.000Z" title="2024/9/22 12:01:19">2024-09-22</time></span><span class="level-item">31 minutes read (About 4654 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-11/">[C++]C++Primer Chapter 11</a></p><div class="content"><h1 id="11-关联容器"><a href="#11-关联容器" class="headerlink" title="11 关联容器"></a>11 关联容器</h1><p>关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。</p>
<p>标准库提供8个关联容器，如表11.1所示。这8个容器间的不同体现在三个维度上：每个容器（1）或者是一个set，或者是一个map；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。允许重复关键字的容器的名字中都包含单词multi；不保持关键字按顺序存储的容器的名字都以单词unordered开头。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726389168983.png"></p>
<h2 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器</h2><p>map是关键字-值对的集合。</p>
<p>map类型通常被称为关联数组（associative array）。关联数组与“正常”数组类似，不同之处在于其下标不必是整数。</p>
<p>set就是关键字的简单集合。当只是想知道一个值是否存在时，set是最有用的。</p>
<p><strong>使用map</strong></p>
<p>为了定义一个map，我们必须指定关键字和值的类型。</p>
<p>当从map中提取一个元素时，会得到一个pair类型的对象，我们将在11.2.3节（第379页）介绍它。简单来说，pair是一个模板类型，保存两个名为first和second的（公有）数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。</p>
<p><strong>使用set</strong></p>
<p>find调用返回一个迭代器。如果给定关键字在set中，迭代器指向该关键字。否则，find返回尾后迭代器。</p>
<h2 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述</h2><p>关联容器不支持顺序容器的位置相关的操作，例如push_front或push_back。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p>
<p>关联容器的迭代器都是双向的。</p>
<h3 id="11-2-1-定义关联容器"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a>11.2.1 定义关联容器</h3><p><strong>初始化multimap或multiset</strong></p>
<h3 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求</h3><p>对于有序容器——map、multimap、set以及multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。</p>
<p><strong>有序容器的关键字类型</strong></p>
<p>可以提供自己定义的操作来代替关键字上的&lt;运算符。所提供的操作必须在关键字类型上定义一个严格弱序（strict weak ordering）。可以将严格弱序看作“小于等于”，虽然实际定义的操作可能是一个复杂的函数。无论我们怎样定义比较函数，它必须具备如下基本性质：</p>
<ul>
<li>两个关键字不能同时“小于等于”对方；如果k1“小于等于”k2，那么k2绝不能“小于等于”k1。</li>
<li>如果k1“小于等于”k2，且k2“小于等于”k3，那么k1必须“小于等于”k3。</li>
<li>如果存在两个关键字，任何一个都不“小于等于”另一个，那么我们称这两个关键字是“等价”的。如果k1“等价于”k2，且k2“等价于”k3，那么k1必须“等价于”k3。</li>
</ul>
<p>如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作map的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。</p>
<blockquote>
<p>在实际编程中，重要的是，如果一个类型定义了“行为正常”的&lt;运算符，则它可以用作关键字类型。</p>
</blockquote>
<p><strong>使用关键字类型的比较函数</strong></p>
<p>用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。如前所述，用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出。</p>
<p>在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。</p>
<p>为了使用自己定义的操作，在定义multiset时我们必须提供两个类型：关键字类型Sales_data，以及比较操作类型——应该是一种函数指针类型（参见6.7节，第221页），可以指向compareIsbn。当定义此容器类型的对象时，需要提供想要使用的操作的指针。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726390059889.png"></p>
<h3 id="11-2-3-pair类型"><a href="#11-2-3-pair类型" class="headerlink" title="11.2.3 pair类型"></a>11.2.3 pair类型</h3><p>定义在头文件utility中。</p>
<p>一个pair保存两个数据成员。类似容器，pair是一个用来生成特定类型的模板。当创建一个pair时，我们必须提供两个类型名，pair的数据成员将具有对应的类型。两个类型不要求一样</p>
<p>pair的默认构造函数对数据成员进行值初始化（参见3.3.1节，第88页）。</p>
<p>与其他标准库类型不同，pair的数据成员是public的（参见7.2节，第240页）。两个成员分别命名为first和second。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726390434783.png"></p>
<h2 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作</h2><p>除了表9.2（第295页）中列出的类型，关联容器还定义了表11.3中列出的类型。这些类型表示容器关键字和值的类型。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726390657794.png"></p>
<h3 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器</h3><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的value_type的值的引用。对map而言，value_type是一个pair类型，其first成员保存const的关键字，second成员保存值</p>
<p><strong>set的迭代器是const的</strong></p>
<p>虽然set类型同时定义了iterator和const_iterator类型，但两种类型都只允许只读访问set中的元素。与不能改变一个map元素的关键字一样，一个set中的关键字也是const的。可以用一个set迭代器来读取元素的值，但不能修改</p>
<p><strong>遍历关联容器</strong></p>
<blockquote>
<p>当使用一个迭代器遍历一个map、multimap、set或multiset时，迭代器按关键字升序遍历元素。</p>
</blockquote>
<p><strong>关联容器和算法</strong></p>
<p>我们通常不对关联容器使用泛型算法（参见第10章）。关键字是const这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而set类型中的元素是const的，map中的元素是pair，其第一个成员是const的。</p>
<p>关联容器可用于只读取元素的算法。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行（快速）查找，因此对其使用泛型搜索算法几乎总是个坏主意。</p>
<p>关联容器定义了一个名为find的成员，它通过一个给定的关键字直接获取元素。我们可以用泛型find算法来查找一个元素，但此算法会进行顺序搜索。使用关联容器定义的专用的find成员会比调用泛型find快得多。</p>
<h3 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素</h3><p>关联容器的insert成员（见表11.4，第384页）向容器中添加一个元素或一个元素范围。由于map和set（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响</p>
<p>insert有两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数（参见11.2.1节，第376页）——对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中。</p>
<p><strong>向map添加元素</strong></p>
<p>对一个map进行insert操作时，必须记住元素类型是pair。通常，对于想要插入的数据，并没有一个现成的pair对象。可以在insert的参数列表中创建一个pair</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726390972049.png"></p>
<p><strong>检测insert的返回值</strong></p>
<p><strong>向multiset或multimap添加元素</strong></p>
<h3 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素</h3><p>关联容器定义了三个版本的erase，如表11.5所示。与顺序容器一样，我们可以通过传递给erase一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。这两个版本的erase与对应的顺序容器的操作非常相似：指定的元素被删除，函数返回void。</p>
<p>关联容器提供一个额外的erase操作，它接受一个key_type参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726391205794.png"></p>
<h3 id="11-3-4-map的下标操作"><a href="#11-3-4-map的下标操作" class="headerlink" title="11.3.4 map的下标操作"></a>11.3.4 map的下标操作</h3><p>map和unordered_map容器提供了下标运算符和一个对应的at函数（参见9.3.2节，第311页），如表11.6所示。set类型不支持下标，因为set中没有与关键字相关联的“值”。</p>
<p>我们不能对一个multimap或一个unordered_multimap进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。</p>
<p>如果关键字并不在map中，会为它创建一个元素并插入到map中，关联值将进行值初始化（参见3.3.1节，第88页）。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726391287199.png"></p>
<p>将会执行如下操作：</p>
<ul>
<li>在word_count中搜索关键字为Anna的元素，未找到。</li>
<li>将一个新的关键字-值对插入到word_count中。关键字是一个const string，保存Anna。值进行值初始化，在本例中意味着值为0。</li>
<li>提取出新插入的元素，并将值1赋予它。</li>
</ul>
<p>由于下标运算符可能插入一个新元素，我们只可以对非const的map使用下标操作。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726391330440.png"></p>
<h3 id="11-3-5-访问元素"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素</h3><p><img src="/../images/C-C-Primer-Chapter-11/1726391522187.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726391528397.png"></p>
<p><strong>对map使用find代替下标操作</strong></p>
<p>我们只是想知道一个给定关键字是否在map中，而不想改变map。这样就不能使用下标运算符来检查一个元素是否存在，因为如果关键字不存在的话，下标运算符会插入一个新元素。在这种情况下，应该使用find</p>
<p><strong>在multimap或multiset中查找元素</strong></p>
<p>如果一个multimap或multiset中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。</p>
<p>例如，给定一个从作者到著作题目的映射，我们可能想打印一个特定作者的所有著作。</p>
<p>可以用三种不同方法来解决这个问题。最直观的方法是使用find和count：</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726391774290.png"></p>
<p><strong>一种不同的，面向迭代器的解决方法</strong></p>
<p>我们还可以用lower_bound和upper_bound来解决此问题。这两个操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器将指向第一个具有给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置。如果元素不在multimap中，则lower_bound和upper_bound会返回相等的迭代器——指向一个不影响排序的关键字插入位置。因此，用相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围（参见9.2.1节，第296页），表示所有具有该关键字的元素的范围。</p>
<p>这两个操作返回的迭代器可能是容器的尾后迭代器。如果我们查找的元素具有容器中最大的关键字，则此关键字的upper_bound返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则lower_bound返回的也是尾后迭代器。</p>
<blockquote>
<p>lower_bound返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则lower_bound会返回关键字的第一个安全插入点——不影响容器中元素顺序的插入位置。</p>
</blockquote>
<p><img src="/../images/C-C-Primer-Chapter-11/1726392086527.png"></p>
<p><strong>equal_range函数</strong></p>
<p>解决此问题的最后一种方法是三种方法中最直接的：不必再调用upper_bound和lower_bound，直接调用equal_range即可。此函数接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726396333694.png"></p>
<h3 id="11-3-6-一个单词转换的map"><a href="#11-3-6-一个单词转换的map" class="headerlink" title="11.3.6 一个单词转换的map"></a>11.3.6 一个单词转换的map</h3><p>给定一个string，将它转换为另一个string。程序的输入是两个文件。第一个文件保存的是一些规则，用来转换第二个文件中的文本。每条规则由两部分组成：一个可能出现在输入文件中的单词和一个用来替换它的短语。表达的含义是，每当第一个单词出现在输入中时，我们就将它替换为对应的短语。第二个输入文件包含要转换的文本。</p>
<h2 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器</h2><p>新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数（hash function）和关键字类型的&#x3D;&#x3D;运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。</p>
<p><strong>使用无序容器</strong></p>
<p>通常可以用一个无序容器替换对应的有序容器，反之亦然。</p>
<p><strong>管理桶</strong></p>
<p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
<p>对于相同的参数，哈希函数必须总是产生相同的结果。</p>
<p>当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。</p>
<p>无序容器提供了一组管理桶的函数，如表11.8所示。这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组。</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726400739462.png"></p>
<p><strong>无序容器对关键字类型的要求</strong></p>
<p>无序容器使用关键字类型的&#x3D;&#x3D;运算符来比较元素，它们还使用一个hash<key_type>类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了hash模板。还为一些标准库类型，包括string和我们将要在第12章介绍的智能指针类型定义了hash。因此，我们可以直接定义关键字是内置类型（包括指针类型）、string还是智能指针类型的无序容器。</p>
<p>不能直接定义关键字类型为自定义类类型的无序容器。与容器不同，不能直接使用哈希模板，而必须提供我们自己的hash模板版本。我们将在16.5节（第626页）中介绍如何做到这一点。</p>
<p>我们不使用默认的hash，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作（参见11.2.2节，第378页）。为了能将Sale_data用作关键字，我们需要提供函数来替代&#x3D;&#x3D;运算符和哈希值计算函数。我们从定义这些重载函数开始</p>
<p><img src="/../images/C-C-Primer-Chapter-11/1726401255757.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-11/image-20240922131357012.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:17.000Z" title="2024/9/22 12:01:17">2024-09-22</time></span><span class="level-item">an hour read (About 9643 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-10/">[C++]C++Primer Chapter 10</a></p><div class="content"><h1 id="10-泛型算法"><a href="#10-泛型算法" class="headerlink" title="10 泛型算法"></a>10 泛型算法</h1><h2 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h2><p>大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。</p>
<p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围（参见9.2.1节，第296页）来进行操作。</p>
<p><strong>迭代器令算法不依赖于容器，但算法依赖于元素类型的操作</strong></p>
<p><strong>关键概念：算法永远不会执行容器的操作</strong></p>
<p>算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。</p>
<h2 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法</h2><h3 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法</h3><p>一些算法只会读取其输入范围内的元素，而从不改变元素。</p>
<p>find就是这样一种算法，我们在10.1节练习（第337页）中使用的count函数也是如此。另一个只读算法是accumulate，它定义在头文件numeric中。accumulate函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。accumulate的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。</p>
<p><strong>算法和元素类型</strong></p>
<p>对于只读取而不改变元素的算法，通常最好使用cbegin（）和cend（）（参见9.2.3节，第298页）。但是，如果你计划使用算法返回的迭代器来改变元素的值，就需要使用begin（）和end（）的结果作为参数。</p>
<p><strong>操作两个序列的算法</strong></p>
<p>另一个只读算法是equal，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回true，否则返回false。此算法接受三个迭代器：前两个（与以往一样）表示第一个序列中的元素范围，第三个表示第二个序列的首元素。equal基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。</p>
<blockquote>
<p>那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</p>
</blockquote>
<h3 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法</h3><p>算法fill接受一对迭代器表示一个范围，还接受一个值作为第三个参数。fill将给定的这个值赋予输入序列中的每个元素。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726201288551.png"></p>
<p><strong>算法不检查写操作</strong></p>
<p>函数fill_n接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用fill_n将一个新值赋予vector中的元素。函数fill_n假定写入指定个元素是安全的。</p>
<p><strong>介绍back_inserter</strong></p>
<p>一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器（insert iterator）。插入迭代器是一种向容器中添加元素的迭代器。通常情况，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</p>
<p>我们现在将使用back_inserter，它是定义在头文件iterator中的一个函数。</p>
<p>back_inserter接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用push_back将一个具有给定值的元素添加到容器中</p>
<p><strong>拷贝算法</strong></p>
<p>拷贝（copy）算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。</p>
<p>copy返回的是其目的位置迭代器（递增后）的值。即，ret恰好指向拷贝到a2的尾元素之后的位置。</p>
<p>多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建一个新序列保存这些结果。</p>
<p>replace算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值</p>
<p>此调用将序列中所有的0都替换为42。如果我们希望保留原序列不变，可以调用replace_copy。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726228439564.png"></p>
<p>此调用后，ilst并未改变，ivec包含ilst的一份拷贝，不过原来在ilst中值为0的元素在ivec中都变为42。</p>
<h3 id="10-2-3-重排容器元素的算法"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a>10.2.3 重排容器元素的算法</h3><p>某些算法会重排容器中元素的顺序，一个明显的例子是sort。调用sort会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;运算符来实现排序的。</p>
<p><strong>消除重复单词</strong></p>
<p>为了消除重复单词，首先将vector排序，使得重复的单词都相邻出现。一旦vector排序完毕，我们就可以使用另一个称为unique的标准库算法来重排vector，使得不重复的元素出现在vector的开始部分。由于算法不能执行容器的操作，我们将使用vector的erase成员来完成真正的删除操作</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726228562655.png"></p>
<p><strong>使用unique</strong></p>
<p>unique算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。</p>
<p>unique返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。</p>
<p><strong>使用容器操作删除元素</strong></p>
<h2 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作</h2><h3 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数</h3><p>为了按长度重排vector，我们将使用sort的第二个版本，此版本是重载过的，它接受第三个参数，此参数是一个谓词（predicate）。</p>
<p><strong>谓词</strong></p>
<p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate，意味着它们只接受单一参数）和二元谓词（binary predicate，意味着它们有两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。</p>
<p>接受一个二元谓词参数的sort版本用这个谓词代替&lt;来比较元素。我们提供给sort的谓词必须满足将在11.2.2节（第378页）中所介绍的条件。</p>
<p><strong>排序算法</strong></p>
<p>为了保持相同长度的单词按字典序排列，可以使用stable_sort算法。这种稳定排序算法维持相等元素的原有顺序。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726229177622.png"></p>
<p>标准库定义了名为partition的算法，它接受一个谓词，对容器内容进行划分，使得谓词为true的值会排在容器的前半部分，而使谓词为false的值会排在后半部分。算法返回一个迭代器，指向最后一个使谓词为true的元素之后的位置。</p>
<h3 id="10-3-2-lambda表达式"><a href="#10-3-2-lambda表达式" class="headerlink" title="10.3.2 lambda表达式"></a>10.3.2 lambda表达式</h3><p>我们可以使用标准库find_if算法来查找第一个具有特定大小的元素。类似find（参见10.1节，第336页），find_if算法接受一对迭代器，表示一个范围。但与find不同的是，find_if的第三个参数是一个谓词。find_if算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非0值的元素，如果不存在这样的元素，则返回尾迭代器。</p>
<p>find_if接受一元谓词——我们传递给find_if的任何函数都必须严格接受一个参数，以便能用来自输入序列的一个元素调用它。没有任何办法能传递给它第二个参数来表示长度。为了解决此问题，需要使用另外一些语言特性。</p>
<p><strong>介绍lambda</strong></p>
<p>我们可以向一个算法传递任何类别的<strong>可调用对象（callable object）。</strong>对于一个对象或一个表达式，如果可以对其使用调用运算符（参见1.5.2节，第21页），则称它为可调用的。即，如果e是一个可调用的表达式，则我们可以编写代码e（args），其中args是一个逗号分隔的一个或多个参数的列表。</p>
<p>我们使用过的仅有的两种可调用对象是函数和函数指针（参见6.7节，第221页）。还有其他两种可调用对象：重载了函数调用运算符的类，我们将在14.8节（第506页）介绍，以及lambda表达式（lambda expression）。</p>
<p>一个lambda表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个lambda具有一个返回类型、一个参数列表和一个函数体。但与函数不同，lambda可能定义在函数内部。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726229740080.png"></p>
<p>capture list（捕获列表）是一个lambda所在函数中定义的局部变量的列表（通常为空）；return type、parameter list和function body与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，lambda必须使用尾置返回（参见6.3.3节，第206页）来指定返回类型。我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p>
<blockquote>
<p>如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void。</p>
</blockquote>
<p><strong>向lambda传递参数</strong></p>
<p>lambda不能有默认参数（参见6.5.1节，第211页）。</p>
<p><strong>使用捕获列表</strong></p>
<p>虽然一个lambda可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引lambda在其内部包含访问局部变量所需的信息。</p>
<blockquote>
<p>一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p>
</blockquote>
<p><strong>for_each算法</strong></p>
<p>此算法接受一个可调用对象，并对输入序列中每个元素调用此对象</p>
<p>一个lambda可以直接使用定义在当前函数之外的名字。</p>
<blockquote>
<p>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字。</p>
</blockquote>
<h3 id="10-3-3-lambda捕获和返回"><a href="#10-3-3-lambda捕获和返回" class="headerlink" title="10.3.3 lambda捕获和返回"></a>10.3.3 lambda捕获和返回</h3><p>当定义一个lambda时，编译器生成一个与lambda对应的新的（未命名的）类类型。</p>
<p>可以这样理解，当向一个函数传递一个lambda时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象。</p>
<p>默认情况下，从lambda生成的类都包含一个对应该lambda所捕获的变量的数据成员。类似任何普通类的数据成员，lambda的数据成员也在lambda对象创建时被初始化。</p>
<p><strong>值捕获</strong></p>
<p>与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在lambda创建时拷贝，而不是调用时拷贝</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726231363510.png"></p>
<p>由于被捕获变量的值是在lambda创建时拷贝，因此随后对其修改不会影响到lambda内对应的值。</p>
<p><strong>引用捕获</strong></p>
<p>引用捕获与返回引用（参见6.3.2节，第201页）有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就<strong>必须确保被引用的对象在lambda执行的时候是存在的。</strong>lambda捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果lambda可能在函数结束后执行，捕获的引用指向的局部变量已经消失。</p>
<p>我们也可以从一个函数返回lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个lambda，则与函数不能返回一个局部变量的引用类似，此lambda也不能包含引用捕获。</p>
<p><strong>建议：尽量保持lambda的变量捕获简单化</strong></p>
<p>一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。</p>
<p><strong>隐式捕获</strong></p>
<p>可以让编译器根据lambda体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&amp;或&#x3D;。&amp;告诉编译器采用捕获引用方式，&#x3D;则表示采用值捕获方式。</p>
<p>如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726231669244.png"></p>
<p>当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&amp;或&#x3D;。此符号指定了默认捕获方式为引用或值。</p>
<p>当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726231713032.png"></p>
<p><strong>可变lambda</strong></p>
<p>默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字mutable。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726231941506.png"></p>
<p>一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个const类型还是一个非const类型</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726231959765.png"></p>
<p><strong>指定lambda返回类型</strong></p>
<p>函数transform接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。</p>
<p>当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型（参见6.3.3节，第206页）</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726232047309.png"></p>
<h3 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定</h3><p>如果lambda的捕获列表为空，通常可以用函数来代替它。</p>
<p>但是，对于捕获局部变量的lambda，用函数来替换它就不是那么容易了。</p>
<p><strong>标准库bind函数</strong></p>
<p>我们可以解决向check_size传递一个长度参数的问题，方法是使用一个新的名为bind的标准库函数，它定义在头文件functional中。可以将bind函数看作一个通用的函数适配器（参见9.6节，第329页），它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726233370917.png"></p>
<p>newCallable本身是一个可调用对象，arg_list是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传递给它arg_list中的参数。</p>
<p>arg_list中的参数可能包含形如_n的名字，其中n是一个整数。这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，依此类推。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726233503447.png"></p>
<p>此bind调用只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，表示check6的此参数对应check_size的第一个参数。此参数是一个const string&amp;。因此，调用check6必须传递给它一个string类型的参数，check6会将此参数传递给check_size。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726233561900.png"></p>
<p><strong>使用placeholders名字</strong></p>
<p>名字_n都定义在一个名为placeholders的命名空间中，而这个命名空间本身定义在std命名空间（参见3.1节，第74页）中。为了使用这些名字，两个命名空间都要写上。</p>
<p><strong>bind的参数</strong></p>
<p>我们可以用bind修正参数的值。更一般的，可以用bind绑定给定可调用对象中的参数或重新安排其顺序。</p>
<p>例如，假定f是一个可调用对象，它有5个参数，则下面对bind的调用</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726233710338.png"></p>
<p>生成一个新的可调用对象，它有两个参数，分别用占位符_2和_1表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给f。f的第一个、第二个和第四个参数分别被绑定到给定的值a、b和c上。传递给g的参数按位置绑定到占位符。即，第一个参数绑定到_1，第二个参数绑定到_2。因此，当我们调用g时，其第一个参数将被传递给f作为最后一个参数，第二个参数将被传递给f作为第三个参数。</p>
<p><strong>用bind重排参数顺序</strong></p>
<p><strong>绑定引用参数</strong></p>
<p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。</p>
<p>如果我们希望传递给bind一个对象而又不拷贝它，就<strong>必须使用标准库ref函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726233958032.png"></p>
<p>函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个cref函数，生成一个保存const引用的类。与bind一样，函数ref和cref也定义在头文件functional中。</p>
<h2 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器</h2><p>除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。</p>
<ul>
<li>插入迭代器（insert iterator）：这些迭代器被绑定到一个容器上，可用来向容器插入元素。</li>
<li>流迭代器（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</li>
<li>反向迭代器（reverse iterator）：这些迭代器向后而不是向前移动。除了forward_list之外的标准库容器都有反向迭代器。</li>
<li>移动迭代器（move iterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它们。我们将在13.6.2节（第480页）介绍移动迭代器。</li>
</ul>
<h3 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器</h3><p>插入器是一种迭代器适配器（参见9.6节，第329页），它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个插入迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726234353465.png"></p>
<p>插入器有三种类型，差异在于元素插入的位置：</p>
<ul>
<li>back_inserter（参见10.2.2节，第341页）创建一个使用push_back的迭代器</li>
<li>front_inserter创建一个使用push_front的迭代器。</li>
<li>inserter创建一个使用insert的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</li>
</ul>
<blockquote>
<p>只有在容器支持push_front的情况下，我们才可以使用front_inserter。类似的，只有在容器支持push_back的情况下，我们才能使用back_inserter。</p>
</blockquote>
<p>当调用inserter（c，iter）时，我们得到一个迭代器，接下来使用它时，会将元素插入到iter原来所指向的元素之前的位置。即，如果it是由inserter生成的迭代器，则下面这样的赋值语句</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726234467621.png"></p>
<p>其效果与下面代码一样</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726234477582.png"></p>
<p>front_inserter生成的迭代器的行为与inserter生成的迭代器完全不一样。当我们使用front_inserter时，元素总是插入到容器第一个元素之前。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726234621651.png"></p>
<h3 id="10-4-2-iostream迭代器"><a href="#10-4-2-iostream迭代器" class="headerlink" title="10.4.2 iostream迭代器"></a>10.4.2 iostream迭代器</h3><p>istream_iterator（参见表10.3）读取输入流，ostream_iterator（参见表10.4节，第361页）向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
<p><strong>istream_iterator操作</strong></p>
<p>当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。</p>
<p>一个istream_iterator使用&gt;&gt;来读取流。因此，istream_iterator要读取的类型必须定义了输入运算符。当创建一个istream_iterator时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726234818281.png"></p>
<p>下面是一个用istream_iterator从标准输入读取数据，存入一个vector的例子：</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726234827719.png"></p>
<p>此循环从cin读取int值，保存在vec中。在每个循环步中，循环体代码检查in_iter是否等于eof。eof被定义为空的istream_iterator，从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到IO错误，迭代器的值就与尾后迭代器相等。</p>
<p>我们可以将程序重写为如下形式，这体现了istream_iterator更有用的地方。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726234885880.png"></p>
<p>这个构造函数从cin中读取数据，直至遇到文件尾或者遇到一个不是int的数据为止。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726234931737.png"></p>
<p><strong>使用算法操作流迭代器</strong></p>
<p>由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某些迭代器操作，因此我们至少可以用某些算法来操作流迭代器。我们在10.5.1节（第365页）会看到如何分辨哪些算法可以用于流迭代器。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726300333345.png"></p>
<p><strong>istream_iterator允许使用懒惰求值</strong></p>
<p>当我们将一个istream_iterator绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个istream_iterator，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。</p>
<p><strong>ostream_iterator操作</strong></p>
<p>我们可以对任何具有输出运算符（&lt;&lt;运算符）的类型定义ostream_iterator。当创建一个ostream_iterator时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个C风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。必须将ostream_iterator绑定到一个指定的流，不允许空的或表示尾后位置的ostream_iterator。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726300458868.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726300619260.png"></p>
<p>out_iter++实际不对迭代器做任何操作，但还是推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。</p>
<p>可以通过调用copy来打印vec中的元素，这比编写循环更为简单</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726300802026.png"></p>
<p><strong>使用流迭代器处理类类型</strong></p>
<h3 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器</h3><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一个迭代器（–it）会移动到下一个元素。</p>
<p>除了forward_list之外，其他容器都支持反向迭代器。</p>
<p>我们可以通过调用rbegin、rend、crbegin和crend成员函数来获得反向迭代器。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726302994585.png"></p>
<p>虽然颠倒递增和递减运算符的含义可能看起来令人混淆，但这样做使我们可以用算法透明地向前或向后处理容器。例如，可以通过向sort传递一对反向迭代器来将vector整理为递减序：</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726303038287.png"></p>
<p><strong>反向迭代器需要递减运算符</strong></p>
<p>流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个forward_list或一个流迭代器创建反向迭代器。</p>
<p><strong>反向迭代器和其他迭代器间的关系</strong></p>
<p>我们使用的是反向迭代器，会反向处理string。因此，上述输出语句从crbegin开始反向打印line中内容。而我们希望按正常顺序打印从rcomma开始到line末尾间的字符。但是，我们不能直接使用rcomma。因为它是一个反向迭代器，意味着它会反向朝着string的开始位置移动。需要做的是，将rcomma转换回一个普通迭代器，能在line中正向移动。我们通过调用reverse_iterator的base成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器：</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726303307514.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726303318130.png" alt="1726303318130"></p>
<h2 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构</h2><p>任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如find，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如sort，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别（iterator category），如表10.5所示。每个算法都会对它的每个迭代器参数指明须提供哪类迭代器。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726303617577.png"></p>
<p>第二种算法分类的方式（如我们在本章开始所做的）是按照是否读、写或是重排序列中的元素来分类。附录A按这种分类方法列出了所有算法。</p>
<h3 id="10-5-1-5类迭代器"><a href="#10-5-1-5类迭代器" class="headerlink" title="10.5.1 5类迭代器"></a>10.5.1 5类迭代器</h3><p><strong>迭代器类别</strong></p>
<p>1.输入迭代器（input iterator）：可以读取序列中的元素。</p>
<p>一个输入迭代器必须支持:</p>
<ul>
<li>用于比较两个迭代器的相等和不相等运算符（&#x3D;&#x3D;、！&#x3D;）</li>
<li>用于推进迭代器的前置和后置递增运算（++）</li>
<li>用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧</li>
<li>箭头运算符（-&gt;），等价于（*it）.member，即，解引用迭代器，并提取对象的成员</li>
</ul>
<p>输入迭代器只用于顺序访问。对于一个输入迭代器，*it++保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法find和accumulate要求输入迭代器；而istream_iterator是一种输入迭代器。</p>
<p>2.输出迭代器（output iterator）：可以看作输入迭代器功能上的补集——只写而不读元素。</p>
<p>输出迭代器必须支持</p>
<ul>
<li>用于推进迭代器的前置和后置递增运算（++）</li>
<li>解引用运算符（*），只出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）</li>
</ul>
<p>我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，copy函数的第三个参数就是输出迭代器。ostream_iterator类型也是输出迭代器。</p>
<p>3.前向迭代器（forward iterator）：可以读写元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法replace要求前向迭代器，forward_list上的迭代器是前向迭代器。</p>
<p>4.双向迭代器（bidirectional iterator）：可以正向&#x2F;反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（–）。算法reverse要求双向迭代器，除了forward_list之外，其他标准库都提供符合双向迭代器要求的迭代器。</p>
<p>5.随机访问迭代器（random-access iterator）：提供在常量时间内访问序列中任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持表3.7（第99页）中的操作：</p>
<ul>
<li>用于比较两个迭代器相对位置的关系运算符（&lt;、&lt;&#x3D;、&gt;和&gt;&#x3D;）</li>
<li>迭代器和一个整数值的加减运算（+、+&#x3D;、-和-&#x3D;），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置</li>
<li>用于两个迭代器上的减法运算符（-），得到两个迭代器的距离</li>
<li>下标运算符（iter[n]），与＊（iter[n]）等价</li>
</ul>
<p>算法sort要求随机访问迭代器。array、deque、string和vector的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</p>
<h3 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式</h3><p>大多数算法具有如下4种形式之一：</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726307764902.png"></p>
<p><strong>接受单个目标迭代器的算法</strong></p>
<p>dest参数是一个表示算法可以写入的目的位置的迭代器。算法假定（assume）：按其需要写入数据，不管写入多少个元素都是安全的。</p>
<p><strong>接受第二个输入序列的算法</strong></p>
<p>接受单独的beg2或是接受beg2和end2的算法用这些迭代器表示第二个输入范围。这些算法通常使用第二个范围中的元素与第一个输入范围结合来进行一些运算。</p>
<h3 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范</h3><p>算法还遵循一套命名和重载规范。这些规范处理诸如：如何提供一个操作代替默认的&lt;或&#x3D;&#x3D;运算符以及算法是将输出数据写入输入序列还是一个分离的目的位置等问题。</p>
<p><strong>一些算法使用重载形式传递一个谓词</strong></p>
<p>接受谓词参数来代替&lt;或&#x3D;&#x3D;运算符的算法，以及那些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替&lt;或&#x3D;&#x3D;：</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726307944623.png"></p>
<p><strong>_if版本的算法</strong></p>
<p>接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词（参见10.3.1节，第344页）代替元素值。接受谓词参数的算法都有附加的_if前缀：</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726307986000.png"></p>
<p><strong>区分拷贝元素的版本和不拷贝的版本</strong></p>
<p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个_copy（参见10.2.2节，第341页）：</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726308018039.png"></p>
<p>一些算法同时提供_copy和_if版本。这些版本接受一个目的位置迭代器和一个谓词：</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726308043920.png"></p>
<h2 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法</h2><p>与其他容器不同，链表类型list和forward_list定义了几个成员函数形式的算法，如表10.6所示。特别是，它们定义了独有的sort、merge、remove、reverse和unique。通用版本的sort要求随机访问迭代器，因此不能用于list和forward_list，因为这两个类型分别提供双向迭代器和前向迭代器。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726308113330.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726308167608.png"></p>
<p><strong>splice成员</strong></p>
<p>此算法是链表数据结构所特有的，因此不需要通用版本。</p>
<p><img src="/../images/C-C-Primer-Chapter-10/1726308197673.png"></p>
<p><strong>链表特有的操作会改变容器</strong></p>
<p>链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，remove的链表版本会删除指定的元素。unique的链表版本会删除第二个和后继的重复元素。</p>
<p>类似的，merge和splice会销毁其参数。例如，通用版本的merge将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的merge函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用merge的链表对象中。在merge之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:14.000Z" title="2024/9/22 12:01:14">2024-09-22</time></span><span class="level-item">an hour read (About 7288 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-9/">[C++]C++Primer Chapter 9</a></p><div class="content"><h1 id="9-顺序容器"><a href="#9-顺序容器" class="headerlink" title="9 顺序容器"></a>9 顺序容器</h1><p>一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。与之相对的，我们将在第11章介绍的有序和无序关联容器，则根据关键字的值来存储元素。</p>
<h2 id="9-1-顺序容器概述"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述</h2><p>表9.1列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li>向容器添加或从容器中删除元素的代价</li>
<li>非顺序访问容器中元素的代价</li>
</ul>
<p><img src="/../images/C-C-Primer-Chapter-9/1726125028655.png"></p>
<p>1.string和vector</p>
<p>将元素保存在连续的内存空间中。由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时</p>
<p>2.list和forward_list</p>
<p>何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问。与vector、deque和array相比，这两个容器的额外内存开销也很大。</p>
<p>3.deque</p>
<p>与string和vector类似，deque支持快速的随机访问。与string和vector一样，在deque的中间位置添加或删除元素的代价（可能）很高。但是，在deque的两端添加或删除元素都是很快的，与list或forward_list添加删除元素的速度相当。</p>
<p>4.forward_list和array是新C++标准增加的类型。</p>
<p>与内置数组相比，array是一种更安全、更容易使用的数组类型。与内置数组类似，array对象的大小是固定的。因此，array不支持添加和删除元素以及改变容器大小的操作。</p>
<p>forward_list的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，forward_list没有size操作，因为保存或计算其大小就会比手写链表多出额外的开销。</p>
<p>对其他容器而言，size保证是一个快速的常量时间的操作。</p>
<blockquote>
<p>新标准库容器的性能几乎肯定与最精心优化过的同类数据结构一样好（通常会更好）。现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。</p>
</blockquote>
<p><strong>确定使用哪种顺序容器</strong></p>
<p>以下是一些选择容器的基本原则：</p>
<ul>
<li>除非你有很好的理由选择其他容器，否则应使用vector。</li>
<li>如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。</li>
<li>如果程序要求随机访问元素，应使用vector或deque。</li>
<li>如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。</li>
<li>如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则<ul>
<li>首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数（我们将在10.2.3节介绍sort（第343页））来重排容器中的元素，从而避免在中间位置添加元素。</li>
<li>如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。</li>
<li>如果程序既需要随机访问元素，又需要在容器中间位置插入元素，那该怎么办？答案取决于在list或forward_list中访问元素与vector或deque中插入&#x2F;删除元素的相对性能。一般来说，应用中占主导地位的操作（执行的访问操作更多还是插入&#x2F;删除更多）决定了容器类型的选择。在此情况下，对两种容器分别测试应用的性能可能就是必要的了。</li>
</ul>
</li>
</ul>
<h2 id="9-2-容器库概览"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览</h2><p>容器类型上的操作形成了一种层次：</p>
<ul>
<li>某些操作是所有容器类型都提供的（参见表9.2，第295页）。</li>
<li>另外一些操作仅针对顺序容器（参见表9.3，第299页）、关联容器（参见表11.7，第388页）或无序容器（参见表11.8，第395页）。</li>
<li>还有一些操作只适用于一小部分容器。</li>
</ul>
<p>本节介绍对所有容器都适用的操作。</p>
<p><strong>对容器可以保存的元素类型的限制</strong></p>
<p>但某些容器操作对元素类型有其自己的特殊要求。我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726125619215.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726125625747.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726125631614.png"></p>
<h3 id="9-2-1-迭代器"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器</h3><p><strong>迭代器范围</strong></p>
<p>这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为</p>
<p><img src="/../images/C-C-Primer-Chapter-9/image-20240922131109226.png"></p>
<p><strong>使用左闭合范围蕴含的编程假定</strong></p>
<ul>
<li>如果begin与end相等，则范围为空</li>
<li>如果begin与end不等，则范围至少包含一个元素，且begin指向该范围中的第一个元素</li>
<li>我们可以对begin递增若干次，使得begin&#x3D;&#x3D;end</li>
</ul>
<h3 id="9-2-2-容器类型成员"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726126013015.png"></p>
<h3 id="9-2-3-begin和end成员"><a href="#9-2-3-begin和end成员" class="headerlink" title="9.2.3 begin和end成员"></a>9.2.3 begin和end成员</h3><blockquote>
<p>当不需要写访问时，应使用cbegin和cend。</p>
</blockquote>
<h3 id="9-2-4-容器定义和初始化"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726126194086.png"></p>
<p><strong>将一个容器初始化为另一个容器的拷贝</strong></p>
<p>为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换（参见4.11节，第141页）为要初始化的容器的元素类型即可。</p>
<p><strong>列表初始化</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726126304682.png"></p>
<p><strong>与顺序容器大小相关的构造函数</strong></p>
<p>顺序容器（array除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器（参见3.3.1节，第88页)</p>
<blockquote>
<p>只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p>
</blockquote>
<p><strong>标准库array具有固定大小</strong></p>
<p>与内置数组一样，标准库array的大小也是类型的一部分。当定义一个array时，除了指定元素类型，还要指定容器大小</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726126472765.png"></p>
<p>与其他容器不同，一个默认构造的array是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化（参见2.2.1节，第40页），就像一个内置数组（参见3.5.1节，第102页）中的元素那样。如果我们对array进行列表初始化，初始值的数目必须等于或小于array的大小。如果初始值数目小于array的大小，则它们被用来初始化array中靠前的元素，所有剩余元素都会进行值初始化（参见3.3.1节，第88页）。</p>
<p>值得注意的是，虽然我们不能对内置数组类型进行拷贝或对象赋值操作（参见3.5.1节，第102页），但array并无此限制</p>
<h3 id="9-2-5-赋值和swap"><a href="#9-2-5-赋值和swap" class="headerlink" title="9.2.5 赋值和swap"></a>9.2.5 赋值和swap</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726126984472.png"></p>
<p><strong>使用assign（仅顺序容器）</strong></p>
<p>顺序容器（array除外）还定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素。</p>
<p>assign的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素。</p>
<p><strong>使用swap</strong></p>
<p>swap操作交换两个相同类型容器的内容。调用swap之后，两个容器中的元素将会交换</p>
<p>除array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个容器的内部数据结构。</p>
<p>除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。</p>
<p>元素不会被移动的事实意味着，<strong>除string外</strong>，指向容器的迭代器、引用和指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在swap之前指向svec1[3]的string，那么在swap之后它指向svec2[3]的元素。</p>
<p><strong>与其他容器不同</strong>，对一个string调用swap会导致迭代器、引用和指针失效。</p>
<p><strong>与其他容器不同</strong>，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。因此，对于array，在swap操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个array中对应元素的值进行了交换。</p>
<blockquote>
<p>在新标准库中，容器既提供成员函数版本的swap，也提供非成员版本的swap。而早期标准库版本只提供成员函数版本的swap。非成员版本的swap在泛型编程中是非常重要的。统一使用非成员版本的swap是一个好习惯。</p>
</blockquote>
<h3 id="9-2-6-容器大小操作"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作</h3><p>成员函数size（参见3.2.2节，第78页）返回容器中元素的数目；</p>
<p>empty当size为0时返回布尔值true，否则返回false；</p>
<p>max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值。</p>
<p>forward_list支持max_size和empty，但不支持size</p>
<h3 id="9-2-7-关系运算符"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符</h3><p>每个容器类型都支持相等运算符（&#x3D;&#x3D;和！&#x3D;）；除了无序关联容器外的所有容器都支持关系运算符（&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。</p>
<p>比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算（参见3.2.2节，第79页）类似</p>
<p><strong>容器的关系运算符使用元素的关系运算符完成比较</strong></p>
<blockquote>
<p><strong>只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</strong></p>
</blockquote>
<h2 id="9-3-顺序容器操作"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作</h2><h3 id="9-3-1-向顺序容器添加元素"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726129802754.png"></p>
<p><strong>使用push_back</strong></p>
<p>除array和forward_list之外，每个顺序容器（包括string类型）都支持push_back。</p>
<p><strong>关键概念：容器元素是拷贝</strong></p>
<p>当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数（参见3.2.2节，第79页）一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中元素的任何改变都不会影响到原始对象，反之亦然。</p>
<p><strong>使用push_front</strong></p>
<p>list、forward_list和deque容器还支持名为push_front的类似操作。</p>
<p>注意，deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front。deque保证在容器首尾进行插入和删除元素的操作都只花费常数时间。</p>
<p><strong>在容器中的特定位置添加元素</strong></p>
<p>insert成员提供了更一般的添加功能，它允许我们在容器中任意位置插入0个或多个元素。vector、deque、list和string都支持insert成员。forward_list提供了特殊版本的insert成员，我们将在9.3.4节（第312页）中介绍。</p>
<p>每个insert函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置。由于迭代器可能指向容器尾部之后不存在的元素的位置，而且在容器开始位置插入元素是很有用的功能，所以<strong>insert函数将元素插入到迭代器所指定的位置</strong>之前。</p>
<p><strong>插入范围内元素</strong></p>
<p>接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化</p>
<p>接受一对迭代器或一个初始化列表的insert版本将给定范围中的元素插入到指定位置之前</p>
<p>如果我们传递给insert一对迭代器，它们不能指向添加元素的目标容器。</p>
<p>在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。（在旧版本的标准库中，这些操作返回void。）如果范围为空，不插入任何元素，insert操作会将第一个参数返回。</p>
<p><strong>使用insert的返回值</strong></p>
<p>通过使用insert的返回值，可以在容器中一个特定位置反复插入元素</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726151272102.png"></p>
<p><strong>使用emplace操作</strong></p>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接构造元素。</p>
<blockquote>
<p>emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。</p>
</blockquote>
<h3 id="9-3-2-访问元素"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素</h3><p>如果容器中没有元素，访问操作的结果是未定义的。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726151419791.png"></p>
<p><strong>访问成员函数返回的是引用</strong></p>
<p>如果我们使用auto变量来保存这些函数的返回值，并且希望使用此变量来改变元素的值，必须记得将变量定义为引用类型。</p>
<p><strong>下标操作和安全的随机访问</strong></p>
<p>如果我们希望确保下标是合法的，可以使用at成员函数。at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range异常（参见5.6节，第173页）</p>
<h3 id="9-3-3-删除元素"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726151897306.png"></p>
<blockquote>
<p>删除元素的成员函数并不检查其参数。在删除元素之前，程序员必须确保它（们）是存在的。</p>
</blockquote>
<p><strong>pop_front和pop_back成员函数</strong></p>
<p>这些操作返回void。如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它</p>
<p><strong>从容器内部删除一个元素</strong></p>
<p>两种形式的erase都返回指向删除的（最后一个）元素之后位置的迭代器。</p>
<p><strong>删除多个元素</strong></p>
<h3 id="9-3-4-特殊的forward-list操作"><a href="#9-3-4-特殊的forward-list操作" class="headerlink" title="9.3.4 特殊的forward_list操作"></a>9.3.4 特殊的forward_list操作</h3><p>forward_list并未定义insert、emplace和erase，而是定义了名为insert_after、emplace_after和erase_after的操作</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726152308687.png"></p>
<p>forward_list也定义了before_begin，它返回一个首前（off-the-beginning）迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。</p>
<h3 id="9-3-5-改变容器大小"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小</h3><p>我们可以用resize来增大或缩小容器，与往常一样，array不支持resize。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部</p>
<p>resize操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化（参见3.3.1节，第88页）。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726152646667.png"></p>
<h3 id="9-3-6-容器操作可能使迭代器失效"><a href="#9-3-6-容器操作可能使迭代器失效" class="headerlink" title="9.3.6 容器操作可能使迭代器失效"></a>9.3.6 容器操作可能使迭代器失效</h3><p>在向容器添加元素后：</p>
<ul>
<li>如果容器是vector或string，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</li>
<li>对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li>
<li>对于list和forward_list，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。</li>
</ul>
<p>当我们删除一个元素后：</p>
<ul>
<li>对于list和forward_list，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。</li>
<li>对于deque，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除deque的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</li>
<li>对于vector和string，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：当我们删除元素时，尾后迭代器总是会失效。</li>
</ul>
<p><strong>建议：管理迭代器</strong></p>
<p>当你使用迭代器（或指向容器元素的引用或指针）时，最小化要求迭代器必须保持有效的程序片段是一个好的方法。</p>
<p>由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地重新定位迭代器。这个建议对vector、string和deque尤为重要。</p>
<p><strong>编写改变容器的循环程序</strong></p>
<p>添加&#x2F;删除vector、string或deque元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是insert或erase，那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726152845237.png"></p>
<p><strong>不要保存end返回的迭代器</strong></p>
<p>当我们添加&#x2F;删除vector或string的元素后，或在deque中首元素之外任何位置添加&#x2F;删除元素后，原来end返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用end，而不能在循环之前保存end返回的迭代器，一直当作容器末尾使用。通常C++标准库的实现中end（）操作都很快，部分就是因为这个原因。</p>
<h2 id="9-4-vector对象是如何增长的"><a href="#9-4-vector对象是如何增长的" class="headerlink" title="9.4 vector对象是如何增长的"></a>9.4 vector对象是如何增长的</h2><p>当不得不获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。</p>
<p><strong>管理容量的成员函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153094106.png"></p>
<p>只有当需要的内存空间超过当前容量时，reserve调用才会改变vector的容量。</p>
<p>如果需求大小大于当前容量，reserve至少分配与需求一样大的内存空间（可能更大）。</p>
<p>如果需求大小小于或等于当前容量，reserve什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。</p>
<p>因此，在调用reserve之后，capacity将会大于或等于传递给reserve的参数。这样，调用reserve永远也不会减少容器占用的内存空间。</p>
<p>类似的，resize成员函数（参见9.3.5节，第314页）只改变容器中元素的数目，而不是容器的容量。我们同样不能使用resize来减少容器预留的内存空间。</p>
<p>在新标准库中，我们可以调用shrink_to_fit来要求deque、vector或string退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，调用shrink_to_fit也并不保证一定退回内存空间。</p>
<p><strong>capacity和size</strong></p>
<p>虽然不同的实现可以采用不同的分配策略，但所有实现都应遵循一个原则：确保用push_back向vector添加元素的操作有高效率。从技术角度说，就是通过在一个初始为空的vector上调用n次push_back来创建一个n个元素的vector，所花费的时间不能超过n的常数倍。</p>
<h2 id="9-5-额外的string操作"><a href="#9-5-额外的string操作" class="headerlink" title="9.5 额外的string操作"></a>9.5 额外的string操作</h2><p>后面用到的时候再来查</p>
<h3 id="9-5-1-构造string的其他方法"><a href="#9-5-1-构造string的其他方法" class="headerlink" title="9.5.1 构造string的其他方法"></a>9.5.1 构造string的其他方法</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726153366845.png"></p>
<p><strong>substr操作</strong></p>
<p>substr操作（参见表9.12）返回一个string，它是原始string的一部分或全部的拷贝。可以传递给substr一个可选的开始位置和计数值</p>
<p>如果开始位置超过了string的大小，则substr函数抛出一个out_of_range异常（参见5.6节，第173页）。如果开始位置加上计数值大于string的大小，则substr会调整计数值，只拷贝到string的末尾。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153449111.png"></p>
<h3 id="9-5-2-改变string的其他方法"><a href="#9-5-2-改变string的其他方法" class="headerlink" title="9.5.2 改变string的其他方法"></a>9.5.2 改变string的其他方法</h3><p>除了接受迭代器的insert和erase版本外，string还提供了接受下标的版本。下标指出了开始删除的位置，或是insert到给定值之前的位置</p>
<p><strong>append和replace函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153581945.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153593456.png"></p>
<p><strong>改变string的多种重载函数</strong></p>
<h3 id="9-5-3-string搜索操作"><a href="#9-5-3-string搜索操作" class="headerlink" title="9.5.3 string搜索操作"></a>9.5.3 string搜索操作</h3><p>string类提供了6个不同的搜索函数，每个函数都有4个重载版本。表9.14描述了这些搜索成员函数及其参数。每个搜索操作都返回一个string：：size_type值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为string：：npos的static成员（参见7.6节，第268页）。标准库将npos定义为一个const string：：size_type类型，并初始化为值-1。由于npos是一个unsigned类型，此初始值意味着npos等于任何string最大的可能大小（参见2.1.2节，第32页）。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153688759.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153692156.png"></p>
<h3 id="9-5-4-compare函数"><a href="#9-5-4-compare函数" class="headerlink" title="9.5.4 compare函数"></a>9.5.4 compare函数</h3><p><img src="/../images/C-C-Primer-Chapter-9/1726153729745.png"></p>
<h3 id="9-5-5-数值转换"><a href="#9-5-5-数值转换" class="headerlink" title="9.5.5 数值转换"></a>9.5.5 数值转换</h3><p>新标准引入了多个函数，可以实现数值数据与标准库string之间的转换</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153770508.png"></p>
<p>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符</p>
<p>string参数中第一个非空白符必须是符号（+ 或 -）或数字。它可以以0x或0X开头来表示十六进制数。对那些将字符串转换为浮点值的函数，string参数也可以以小数点（.）开头，并可以包含e或E来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，string参数可以包含字母字符，对应大于数字9的数。</p>
<p>如果string不能转换为一个数值，这些函数抛出一个invalid_argument异常（参见5.6节，第173页）。如果转换得到的数值无法用任何类型来表示，则抛出一个out_of_range异常。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153854406.png"></p>
<h2 id="9-6-容器适配器"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器</h2><p>除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue和priority_queue。适配器（adaptor）是标准库中的一个通用概念。容器、迭代器和函数都有适配器。</p>
<p>本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。例如，stack适配器接受一个顺序容器（除array或forward_list外），并使其操作起来像一个stack一样。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726153935087.png"></p>
<p><strong>定义一个适配器</strong></p>
<p>每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。</p>
<p>默认情况下，<strong>stack和queue是基于deque实现的</strong>，<strong>priority_queue是在vector之上实现的</strong>。</p>
<p>我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726154019522.png"></p>
<p>对于一个给定的适配器，可以使用哪些容器是有限制的。所有适配器都要求容器具有添加和删除元素的能力。因此，适配器不能构造在array之上。类似的，我们也不能用forward_list来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力。</p>
<p>stack只要求push_back、pop_back和back操作，因此可以使用除array和forward_list之外的任何容器类型来构造stack。</p>
<p>queue适配器要求back、push_back、front和push_front，因此它可以构造于list或deque之上，但不能基于vector构造。</p>
<p>priority_queue除了front、push_back和pop_back操作之外还要求随机访问能力，因此它可以构造于vector或deque之上，但不能基于list构造。</p>
<p><strong>栈适配器</strong></p>
<p>stack类型定义在stack头文件中。表9.18列出了stack所支持的操作。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726154101439.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726154156115.png"></p>
<p><strong>队列适配器</strong></p>
<p>queue和priority_queue适配器定义在queue头文件中。</p>
<p><img src="/../images/C-C-Primer-Chapter-9/1726154196324.png" alt="1726154196324"></p>
<p><img src="/../images/C-C-Primer-Chapter-9/image-20240922131124573.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:11.000Z" title="2024/9/22 12:01:11">2024-09-22</time></span><span class="level-item">22 minutes read (About 3330 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-8/">[C++]C++Primer Chapter 8</a></p><div class="content"><h1 id="8-IO库"><a href="#8-IO库" class="headerlink" title="8 IO库"></a>8 IO库</h1><p>C++语言不直接处理输入输出，而是通过一族定义在标准库中的类型来处理IO。这些类型支持从设备读取数据、向设备写入数据的IO操作，设备可以是文件、控制台窗口等。还有一些类型允许内存IO，即，从string读取数据，向string写入数据。</p>
<h2 id="8-1-IO类"><a href="#8-1-IO类" class="headerlink" title="8.1 IO类"></a>8.1 IO类</h2><p><img src="/../images/C-C-Primer-Chapter-8/1726120413211.png"></p>
<p><strong>IO类型间的关系</strong></p>
<p>类型ifstream和istringstream都继承自istream。因此，我们可以像使用istream对象一样来使用ifstream和istringstream对象。也就是说，我们是如何使用cin的，就可以同样地使用这些类型的对象。例如，可以对一个ifstream或istringstream对象调用getline，也可以使用&gt;&gt;从一个ifstream或istringstream对象中读取数据。类似的，类型ofstream和ostringstream都继承自ostream。因此，我们是如何使用cout的，就可以同样地使用这些类型的对象。</p>
<blockquote>
<p>本节剩下部分所介绍的标准库流特性都可以无差别地应用于普通流、文件流和string流，以及char或宽字符流版本。</p>
</blockquote>
<h3 id="8-1-1-IO对象无拷贝或赋值"><a href="#8-1-1-IO对象无拷贝或赋值" class="headerlink" title="8.1.1 IO对象无拷贝或赋值"></a>8.1.1 IO对象无拷贝或赋值</h3><p>我们不能拷贝或对IO对象赋值。</p>
<p>我们也不能将形参或返回类型设置为流类型（参见6.2.1节，第188页）。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。</p>
<h3 id="8-1-2-条件状态"><a href="#8-1-2-条件状态" class="headerlink" title="8.1.2 条件状态"></a>8.1.2 条件状态</h3><p><img src="/../images/C-C-Primer-Chapter-8/1726120976621.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726120982490.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726121084201.png"></p>
<p>如果我们在标准输入上键入Boo，读操作就会失败。代码中的输入运算符期待读取一个int，但却得到了一个字符B。这样，cin会进入错误状态。类似的，如果我们输入一个文件结束标识，cin也会进入错误状态。</p>
<p>一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726121103849.png"></p>
<p><strong>查询流的状态</strong></p>
<p>将流作为条件使用，只能告诉我们流是否有效，而无法告诉我们具体发生了什么。</p>
<p>IO库定义了一个与机器无关的iostate类型，它提供了表达流状态的完整功能。这个类型应作为一个位集合来使用</p>
<p>IO库定义了4个iostate类型的constexpr值（参见2.4.4节，第58页），表示特定的位模式。这些值用来表示特定类型的IO条件，可以与位运算符（参见4.8节，第137页）一起使用来一次性检测或设置多个标志位。</p>
<p>badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法再使用了。</p>
<p>在发生可恢复错误后，failbit被置位，如期望读取数值却读出一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。</p>
<p>如果到达文件结束位置，eofbit和failbit都会被置位。</p>
<p>goodbit的值为0，表示流未发生错误。如果badbit、failbit和eofbit任一个被置位，则检测流状态的条件会失败。</p>
<p>操作good在所有错误位均未置位的情况下返回true，而bad、fail和eof则在对应错误位被置位时返回true。此外，在badbit被置位时，fail也会返回true。这意味着，使用good或fail是确定流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于！fail（）。而eof和bad操作只能表示特定的错误。</p>
<p><strong>管理条件状态</strong></p>
<p>流对象的rdstate成员返回一个iostate值，对应流的当前状态。setstate操作将给定条件位置位，表示发生了对应错误。clear成员是一个重载的成员（参见6.4节，第206页）：它有一个不接受参数的版本，而另一个版本接受一个iostate类型的参数。clear不接受参数的版本清除（复位）所有错误标志位。执行clear（）后，调用good会返回true。我们可以这样使用这些成员：</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726121320970.png"></p>
<p>带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，我们首先用rdstate读出当前条件状态，然后用位操作将所需位复位来生成新的状态。例如，下面的代码将failbit和badbit复位，但保持eofbit不变：</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726121388256.png"></p>
<h3 id="8-1-3-管理输出缓冲"><a href="#8-1-3-管理输出缓冲" class="headerlink" title="8.1.3 管理输出缓冲"></a>8.1.3 管理输出缓冲</h3><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。</p>
<p>导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：</p>
<ul>
<li>程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>我们可以使用操纵符如endl（参见1.2节，第6页）来显式刷新缓冲区。</li>
<li>在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。</li>
</ul>
<p><strong>刷新输出缓冲区</strong></p>
<p>我们已经使用过操纵符endl，它完成换行并刷新缓冲区的工作。IO库中还有两个类似的操纵符：flush和ends。flush刷新缓冲区，但不输出任何额外的字符；ends向缓冲区插入一个空字符，然后刷新缓冲区</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726121607348.png"></p>
<p><strong>unitbuf操纵符</strong></p>
<p>如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726121637902.png"></p>
<blockquote>
<p>警告：如果程序崩溃，输出缓冲区不会被刷新</p>
</blockquote>
<p><strong>关联输入和输出流</strong></p>
<p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起。</p>
<blockquote>
<p>交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。</p>
</blockquote>
<p>tie有两个重载的版本（参见6.4节，第206页）：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即，x.tie（&amp;o）将流x关联到输出流o。</p>
<p>我们既可以将一个istream对象关联到另一个ostream，也可以将一个ostream关联到另一个ostream：</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726122679237.png"></p>
<p>每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。</p>
<h2 id="8-2-文件输入输出"><a href="#8-2-文件输入输出" class="headerlink" title="8.2 文件输入输出"></a>8.2 文件输入输出</h2><p>除了继承自iostream类型的行为之外，fstream中定义的类型还增加了一些新的成员来管理与流关联的文件。在表8.3中列出了这些操作，我们可以对fstream、ifstream和ofstream对象调用这些操作，但不能对其他IO类型调用这些操作。</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726122800709.png"></p>
<h3 id="8-2-1-使用文件流对象"><a href="#8-2-1-使用文件流对象" class="headerlink" title="8.2.1 使用文件流对象"></a>8.2.1 使用文件流对象</h3><p>当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。</p>
<p>创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则open会自动被调用。</p>
<p><strong>用fstream代替iostream&amp;</strong></p>
<p>如果有一个函数接受一个ostream&amp;参数，我们在调用这个函数时，可以传递给它一个ofstream对象，对istream&amp;和ifstream也是类似的。</p>
<p><strong>成员函数open和close</strong></p>
<p>如果调用open失败，failbit会被置位（参见8.1.2节，第280页）。因为调用open可能失败，进行open是否成功的检测通常是一个好习惯。</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726123055436.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726123059038.png"></p>
<p>对一个已经打开的文件流调用open会失败，并会导致failbit被置位。随后的试图使用文件流的操作都会失败。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。</p>
<p><strong>自动构造和析构</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726123162740.png"></p>
<p>当一个fstream对象离开其作用域时，与之关联的文件会自动关闭。在下一步循环中，input会再次被创建。</p>
<blockquote>
<p>当一个fstream对象被销毁时，close会自动被调用。</p>
</blockquote>
<h3 id="8-2-2-文件模式"><a href="#8-2-2-文件模式" class="headerlink" title="8.2.2 文件模式"></a>8.2.2 文件模式</h3><p>每个流都有一个关联的文件模式（file mode），用来指出如何使用文件。</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726123208713.png"></p>
<p>指定文件模式有如下限制：</p>
<ul>
<li>只可以对ofstream或fstream对象设定out模式。</li>
<li>只可以对ifstream或fstream对象设定in模式。</li>
<li>只有当out也被设定时才可设定trunc模式。</li>
<li>只要trunc没被设定，就可以设定app模式。在app模式下，即使没有显式指定out模式，文件也总是以输出方式被打开。</li>
<li>默认情况下，即使我们没有指定trunc，以out模式打开的文件也会被截断。为了保留以out模式打开的文件的内容，我们必须同时指定app模式，这样只会将数据追加写到文件末尾；或者同时指定in模式，即打开文件同时进行读写操作（参见17.5.3节，第676页，将介绍对同一个文件既进行输入又进行输出的方法）。</li>
<li>ate和binary模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。</li>
</ul>
<p>每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与ifstream关联的文件默认以in模式打开；与ofstream关联的文件默认以out模式打开；与fstream关联的文件默认以in和out模式打开。</p>
<p><strong>以out模式打开文件会丢弃已有数据</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726123354564.png"></p>
<blockquote>
<p>保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式。</p>
</blockquote>
<p><strong>每次调用open时都会确定文件模式</strong></p>
<p>对于一个给定流，每当打开文件时，都可以改变其文件模式。</p>
<h2 id="8-3-string流"><a href="#8-3-string流" class="headerlink" title="8.3 string流"></a>8.3 string流</h2><p>istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream既可从string读数据也可向string写数据。</p>
<p>除了继承得来的操作，sstream中定义的类型还增加了一些成员来管理与流相关联的string。</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726123827260.png"></p>
<h3 id="8-3-1-使用istringstream"><a href="#8-3-1-使用istringstream" class="headerlink" title="8.3.1 使用istringstream"></a>8.3.1 使用istringstream</h3><p>当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。</p>
<p><img src="/../images/C-C-Primer-Chapter-8/1726124057228.png"></p>
<h3 id="8-3-2-使用ostringstream"><a href="#8-3-2-使用ostringstream" class="headerlink" title="8.3.2 使用ostringstream"></a>8.3.2 使用ostringstream</h3><p>当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。</p>
<p><img src="/../images/C-C-Primer-Chapter-8/image-20240922130926153.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:07.000Z" title="2024/9/22 12:01:07">2024-09-22</time></span><span class="level-item">an hour read (About 6889 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-7/">[C++]C++Primer Chapter 7</a></p><div class="content"><h1 id="7-类"><a href="#7-类" class="headerlink" title="7 类"></a>7 类</h1><p>类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程（以及设计）技术。</p>
<p>类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。</p>
<p>类要想实现数据抽象和封装，需要首先定义一个抽象数据类型（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。</p>
<h2 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a>7.1 定义抽象数据类型</h2><h3 id="7-1-1-设计Sales-data类"><a href="#7-1-1-设计Sales-data类" class="headerlink" title="7.1.1 设计Sales_data类"></a>7.1.1 设计Sales_data类</h3><p>由于14.1节（第490页）将要解释的原因，执行加法和IO的函数不作为Sales_data的成员，相反的，我们将其定义成普通函数；执行复合赋值运算的函数是成员函数。</p>
<h3 id="7-1-2-定义改进的Sales-data类"><a href="#7-1-2-定义改进的Sales-data类" class="headerlink" title="7.1.2 定义改进的Sales_data类"></a>7.1.2 定义改进的Sales_data类</h3><p><strong>引入this</strong></p>
<p>this是一个常量指针，指向“这个”对象。</p>
<p><strong>引入const成员函数</strong></p>
<p>把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数（const member function）。</p>
<blockquote>
<p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
</blockquote>
<p><strong>类作用域和成员函数</strong></p>
<p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
<p><strong>在类的外部定义成员函数</strong></p>
<p><strong>定义一个返回this对象的函数</strong></p>
<p>内置的赋值运算符把它的左侧运算对象当成<strong>左值</strong>返回（参见4.4节，第129页），因此为了与它保持一致，combine函数（重载赋值运算符）必须返回引用类型（参见6.3.2节，第202页）。因为此时的左侧运算对象是一个Sales_data的对象，所以返回类型应该是Sales_data&amp;。</p>
<h3 id="7-1-3-定义类相关的非成员函数"><a href="#7-1-3-定义类相关的非成员函数" class="headerlink" title="7.1.3 定义类相关的非成员函数"></a>7.1.3 定义类相关的非成员函数</h3><p>我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来（参见6.1.2节，第168页）。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。</p>
<blockquote>
<p>一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。</p>
</blockquote>
<p><strong>定义read和print函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726041043380.png"></p>
<p>第一点，read和print分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能被拷贝的类型，因此我们只能通过引用来传递它们（参见6.2.2节，第188页）。而且，因为读取和写入的操作会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。</p>
<p>第二点，print函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。</p>
<p><strong>定义add函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726041120522.png"></p>
<h3 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a>7.1.4 构造函数</h3><p>每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数（constructor）。</p>
<p>不同于其他成员函数，构造函数不能被声明成const的（参见7.1.2节，第231页）。</p>
<p><strong>合成的默认构造函数</strong></p>
<p>类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数（default constructor）。默认构造函数无须任何实参。</p>
<p>如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：</p>
<p>如果存在类内的初始值（参见2.6.1节，第64页），用它来初始化成员。</p>
<p>否则，默认初始化（参见2.2.1节，第40页）该成员。</p>
<p><strong>某些类不能依赖于合成的默认构造函数</strong></p>
<blockquote>
<p>只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。</p>
</blockquote>
<blockquote>
<p>如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。</p>
</blockquote>
<p>如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。</p>
<p><strong>&#x3D; default的含义</strong></p>
<p>在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上&#x3D; default来要求编译器生成构造函数。其中，&#x3D; default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果&#x3D; default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。</p>
<p><strong>构造函数初始值列表</strong></p>
<blockquote>
<p>构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p>
</blockquote>
<h3 id="7-1-5-拷贝、赋值和析构"><a href="#7-1-5-拷贝、赋值和析构" class="headerlink" title="7.1.5 拷贝、赋值和析构"></a>7.1.5 拷贝、赋值和析构</h3><h2 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a>7.2 访问控制与封装</h2><p>在C++语言中，我们使用访问说明符（access specifiers）加强类的封装性</p>
<p>定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。</p>
<p>定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。</p>
<h3 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a>7.2.1 友元</h3><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726041734487.png"></p>
<p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。</p>
<blockquote>
<p>一般来说，最好在类定义开始或结束前的位置集中声明友元。</p>
</blockquote>
<p><strong>关键概念：封装的益处</strong></p>
<p>封装有两个重要的优点：</p>
<p>确保用户代码不会无意间破坏封装对象的状态。</p>
<p>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</p>
<p><strong>友元的声明</strong></p>
<p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>
<p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。</p>
<h2 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a>7.3 类的其他特性</h2><h3 id="7-3-1-类成员再探"><a href="#7-3-1-类成员再探" class="headerlink" title="7.3.1 类成员再探"></a>7.3.1 类成员再探</h3><p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。用来定义类型的成员必须先定义后使用。</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726041953519.png"></p>
<p><strong>令成员作为内联函数</strong></p>
<p>我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义：虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过，<strong>最好</strong>只在类外部定义的地方说明inline，这样可以使类更容易理解。</p>
<blockquote>
<p>inline成员函数也应该与相应的类定义在同一个头文件中。</p>
</blockquote>
<p><strong>重载成员函数</strong></p>
<p><strong>可变数据成员</strong></p>
<p>有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入mutable关键字做到这一点。</p>
<p>一个可变数据成员（mutable data member）永远不会是const，即使它是const对象的成员。</p>
<p><strong>类数据成员的初始值</strong></p>
<p>类内初始值必须使用&#x3D;的初始化形式（初始化Screen的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化screens所用的）。</p>
<blockquote>
<p>当我们提供一个类内初始值时，必须以符号&#x3D;或者花括号表示。</p>
</blockquote>
<h3 id="7-3-2-返回-this的成员函数"><a href="#7-3-2-返回-this的成员函数" class="headerlink" title="7.3.2 返回*this的成员函数"></a>7.3.2 返回*this的成员函数</h3><p><strong>从const成员函数返回＊this</strong></p>
<blockquote>
<p>一个const成员函数如果以引用的形式返回＊this，那么它的返回类型将是常量引用。</p>
</blockquote>
<p><strong>基于const的重载</strong></p>
<p>通过区分成员函数是否是const的，我们可以对其进行重载</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726042483856.png"></p>
<p><strong>建议：对于公共代码使用私有功能函数</strong></p>
<h3 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a>7.3.3 类类型</h3><p>每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。</p>
<p><strong>类的声明</strong></p>
<p>我们也能仅仅声明类而暂时不定义它</p>
<p>这种声明有时被称作前向声明（forward declaration），它向程序中引入了名字Screen并且指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型（incomplete type），也就是说，此时我们已知Screen是一个类类型，但是不清楚它到底包含哪些成员。</p>
<p>不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。</p>
<p>一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针</p>
<h3 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a>7.3.4 友元再探</h3><p>类还可以把其他的类定义成友元，也可以把其他类（之前已定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。</p>
<p><strong>类之间的友元关系</strong></p>
<p>友元关系不存在传递性。</p>
<p><strong>令成员函数作为友元</strong></p>
<p>除了令整个Window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726042842056.png"></p>
<p>首先定义Window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。</p>
<p>接下来定义Screen，包括对于clear的友元声明。</p>
<p>最后定义clear，此时它才可以使用Screen的成员。</p>
<p><strong>函数重载和友元</strong></p>
<p>尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明</p>
<p><strong>友元声明和作用域</strong></p>
<p>类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中（参见7.2.1节，第241页）。</p>
<p>甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726043654206.png"></p>
<p>友元声明的作用是影响访问权限，它本身并非普通意义上的声明。</p>
<h2 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a>7.4 类的作用域</h2><p><strong>作用域和定义在类外部的成员</strong></p>
<p>一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。</p>
<p>函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726044971921.png"></p>
<h3 id="7-4-1-名字查找与类的作用域"><a href="#7-4-1-名字查找与类的作用域" class="headerlink" title="7.4.1 名字查找与类的作用域"></a>7.4.1 名字查找与类的作用域</h3><blockquote>
<p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p>
</blockquote>
<p><strong>用于类成员声明的名字查找</strong></p>
<p>这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。</p>
<p><strong>类型名要特殊处理</strong></p>
<p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726045253509.png"></p>
<blockquote>
<p>类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。</p>
</blockquote>
<p><strong>成员定义中的普通块作用域的名字查找</strong></p>
<p>成员函数中使用的名字按照如下方式解析：</p>
<p>首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。</p>
<p>如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。</p>
<p>如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。</p>
<p><strong>类作用域之后，在外围的作用域中查</strong></p>
<blockquote>
<p>尽管外层的对象被隐藏掉了，但我们仍然可以用作用域运算符访问它。</p>
</blockquote>
<h2 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a>7.5 构造函数再探</h2><h3 id="7-5-1-构造函数初始值列表"><a href="#7-5-1-构造函数初始值列表" class="headerlink" title="7.5.1 构造函数初始值列表"></a>7.5.1 构造函数初始值列表</h3><p>随着构造函数体一开始执行，初始化就完成了。</p>
<p><strong>建议：使用构造函数初始值</strong></p>
<p>在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。</p>
<p><strong>成员初始化的顺序</strong></p>
<p>构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。</p>
<p>成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p>
<blockquote>
<p>最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。</p>
</blockquote>
<p><strong>默认实参和构造函数</strong></p>
<h3 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a>7.5.2 委托构造函数</h3><p>C++11新标准扩展了构造函数初始值的功能，使得我们可以定义所谓的委托构造函数（delegating constructor）。一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。</p>
<p>当这些受委托的构造函数执行完后，接着执行istream&amp;构造函数体的内容。</p>
<h3 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3 默认构造函数的作用"></a>7.5.3 默认构造函数的作用</h3><p>默认初始化在以下情况下发生：</p>
<p>当我们在块作用域内不使用任何初始值定义一个非静态变量（参见2.2.1节，第39页）或者数组时（参见3.5.1节，第101页）。</p>
<p>当一个类本身含有类类型的成员且使用合成的默认构造函数时（参见7.1.4节，第235页）。</p>
<p>当类类型的成员没有在构造函数初始值列表中显式地初始化时（参见7.1.4节，第237页）。</p>
<p>值初始化在以下情况下发生：</p>
<p>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时（参见3.5.1节，第101页）。</p>
<p>当我们不使用初始值定义一个局部静态变量时（参见6.1.1节，第185页）。</p>
<p>当我们通过书写形如T（ ）的表达式显式地请求值初始化时，其中T是类型名（vector的一个构造函数只接受一个实参用于说明vector大小（参见3.3.1节，第88页），它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。</p>
<h3 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a>7.5.4 隐式的类类型转换</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数（converting constructor）。</p>
<blockquote>
<p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p>
</blockquote>
<p><strong>只允许一步类类型转换</strong></p>
<p>编译器只会自动地执行一步类型转换</p>
<p><strong>抑制构造函数定义的隐式转换</strong></p>
<p>关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的。只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复</p>
<p><strong>explicit构造函数只能用于直接初始化</strong></p>
<p>发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用&#x3D;）（参见3.2.1节，第76页）。此时，我们只能使用直接初始化而不能使用explicit构造函数</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047200089.png"></p>
<p><strong>为转换显式地使用构造函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047246654.png"></p>
<h3 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a>7.5.5 聚合类</h3><p>聚合类（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：</p>
<p>所有成员都是public的。</p>
<p>没有定义任何构造函数。</p>
<p>没有类内初始值（参见2.6.1节，第64页）。</p>
<p>没有基类，也没有virtual函数</p>
<p>我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047334451.png"></p>
<p>初始值的顺序必须与声明的顺序一致，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化（参见3.5.1节，第101页）。</p>
<h3 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a>7.5.6 字面值常量类</h3><p>数据成员都是字面值类型的聚合类（参见7.5.5节，第266页）是字面值常量类。</p>
<p>如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：</p>
<p>数据成员都必须是字面值类型。</p>
<p>类必须至少含有一个constexpr构造函数。</p>
<p>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式（参见2.4.4节，第58页）；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。</p>
<p>类必须使用析构函数的默认定义，该成员负责销毁类的对象（参见7.1.5节，第239页）。</p>
<p><strong>constexpr构造函数</strong></p>
<p>尽管构造函数不能是const的（参见7.1.4节，第235页），但是字面值常量类的构造函数可以是constexpr（参见6.5.2节，第213页）函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。</p>
<p>constexpr构造函数可以声明成&#x3D; default（参见7.1.4节，第237页）的形式（或者是删除函数的形式，我们将在13.1.6节（第449页）介绍相关知识）。否则，constexpr构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合constexpr函数的要求（意味着它能拥有的唯一可执行语句就是返回语句（参见6.5.2节，第214页））。综合这两点可知，constexpr构造函数体一般来说应该是空的。我们通过前置关键字constexpr就可以声明一个constexpr构造函数了</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047654646.png"></p>
<p>constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726047729145.png"></p>
<h2 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a>7.6 类的静态成员</h2><p><strong>声明静态成员</strong></p>
<p>我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public的或private的。静态数据成员的类型可以是常量、引用、指针、类类型等。</p>
<p>类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。</p>
<p>静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。</p>
<p><strong>使用类的静态成员</strong></p>
<p>使用作用域运算符直接访问静态成员。</p>
<p><strong>定义静态成员</strong></p>
<p>当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句</p>
<p>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。</p>
<blockquote>
<p>要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。</p>
</blockquote>
<p><strong>静态成员的类内初始化</strong></p>
<p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr（参见7.5.6节，第267页）。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。</p>
<blockquote>
<p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p>
</blockquote>
<p><strong>静态成员能用于某些场景，而普通成员不能</strong></p>
<p>静态数据成员可以是不完全类型（参见7.3.3节，第249页）。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用</p>
<p><img src="/../images/C-C-Primer-Chapter-7/1726054107164.png"></p>
<p>静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参</p>
<p><img src="/../images/C-C-Primer-Chapter-7/image-20240922130807902.png"></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:04.000Z" title="2024/9/22 12:01:04">2024-09-22</time></span><span class="level-item">an hour read (About 7158 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-6/">[C++]C++Primer Chapter 6</a></p><div class="content"><h1 id="6-函数"><a href="#6-函数" class="headerlink" title="6 函数"></a>6 函数</h1><h3 id="6-1-函数基础"><a href="#6-1-函数基础" class="headerlink" title="6.1 函数基础"></a>6.1 函数基础</h3><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。</p>
<p>执行函数的第一步是（隐式地）定义并初始化它的形参。因此，当调用fact函数时，首先创建一个名为val的int变量，然后将它初始化为调用时所用的实参5。</p>
<p>当遇到一条return语句时函数结束执行过程。和函数调用一样，return语句也完成两项工作：一是返回return语句中的值（如果有的话），二是将控制权从被调函数转移回主调函数。函数的返回值用于初始化调用表达式的结果，之后继续完成调用所在的表达式的剩余部分。</p>
<p><strong>形参和实参</strong></p>
<p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是<strong>并没有规定实参的求值顺序</strong>（参见4.1.3节，第123页）。编译器能以任意可行的顺序对实参求值。</p>
<h3 id="6-1-1-局部对象"><a href="#6-1-1-局部对象" class="headerlink" title="6.1.1 局部对象"></a>6.1.1 局部对象</h3><p>在C++语言中，名字有作用域（参见2.2.4节，第43页），对象有生命周期（lifetime）。理解这两个概念非常重要。</p>
<p>名字的作用域是程序文本的一部分，名字在其中可见。</p>
<p>对象的生命周期是程序执行过程中该对象存在的一段时间。</p>
<p>在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。局部变量的生命周期依赖于定义的方式。</p>
<p><strong>自动对象</strong></p>
<p>对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。我们把只存在于块执行期间的对象称为自动对象（automatic object）。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。</p>
<p><strong>局部静态对象</strong></p>
<p>某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。<strong>局部静态对象（local static object）</strong>在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。</p>
<h3 id="6-1-2-函数声明"><a href="#6-1-2-函数声明" class="headerlink" title="6.1.2 函数声明"></a>6.1.2 函数声明</h3><p>函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也称作函数原型（function prototype）。</p>
<p><strong>在头文件中进行函数声明</strong></p>
<p>我们建议变量在头文件（参见2.6.3节，第68页）中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。</p>
<blockquote>
<p>定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。</p>
</blockquote>
<h3 id="6-1-3-分离式编译"><a href="#6-1-3-分离式编译" class="headerlink" title="6.1.3 分离式编译"></a>6.1.3 分离式编译</h3><p>分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。</p>
<p><strong>编译和链接多个源文件</strong></p>
<p>假设fact函数的定义位于一个名为fact.cc的文件中，它的声明位于名为Chapter6.h的头文件中。显然与其他所有用到fact函数的文件一样，fact.cc应该包含Chapter6.h头文件。另外，我们在名为factMain.cc的文件中创建main函数，main函数将调用fact函数。要生成可执行文件（executable file），必须告诉编译器我们用到的代码在哪里。</p>
<h2 id="6-2-参数传递"><a href="#6-2-参数传递" class="headerlink" title="6.2 参数传递"></a>6.2 参数传递</h2><p>每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。</p>
<blockquote>
<p>形参初始化的机理与变量初始化一样。</p>
</blockquote>
<h3 id="6-2-1-传值参数"><a href="#6-2-1-传值参数" class="headerlink" title="6.2.1 传值参数"></a>6.2.1 传值参数</h3><blockquote>
<p>在C++语言中，建议使用引用类型的形参替代指针。</p>
</blockquote>
<h3 id="6-2-2-传引用参数"><a href="#6-2-2-传引用参数" class="headerlink" title="6.2.2 传引用参数"></a>6.2.2 传引用参数</h3><p><strong>使用引用避免拷贝</strong></p>
<p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</p>
<p><strong>使用引用形参返回额外信息</strong></p>
<h3 id="6-2-3-const形参和实参"><a href="#6-2-3-const形参和实参" class="headerlink" title="6.2.3 const形参和实参"></a>6.2.3 const形参和实参</h3><p><strong>尽量使用常量引用</strong></p>
<p>把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。就像刚刚看到的，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。</p>
<p>当一个a函数的形参是const，a函数要将这个参数作为实参传递给另外一个b函数，最理想的方法是b函数的参数应该也是const，如果无法满足，正确的做法应该是在a函数内部定义一个局部对象，拷贝一份这个形参，然后将局部对象作为参数传递给b函数。</p>
<h3 id="6-2-4-数组形参"><a href="#6-2-4-数组形参" class="headerlink" title="6.2.4 数组形参"></a>6.2.4 数组形参</h3><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组（参见3.5.1节，第102页）以及使用数组时（通常）会将其转换成指针（参见3.5.3节，第105页）。</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725946405478.png"></p>
<p>尽管表现形式不同，但上面的三个函数是等价的：每个函数的唯一形参都是const int＊类型的。当编译器处理对print函数的调用时，只检查传入的参数是否是const int＊类型</p>
<p>管理指针形参有三种常用的技术：</p>
<p><strong>使用标记指定数组长度</strong></p>
<p>管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串（参见3.5.4节，第109页）。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符停止</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725946548477.png"></p>
<p><strong>使用标准库规范</strong></p>
<p>管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库技术的启发，关于其细节将在第II部分详细介绍。使用该方法，我们可以按照如下形式输出元素内容</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725946542490.png"></p>
<p><strong>显式传递一个表示数组大小的形参</strong></p>
<p>第三种管理数组实参的方法是专门定义一个表示数组大小的形参，在C程序和过去的C++程序中常常使用这种方法。使用该方法，可以将print函数重写成如下形式</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725946585366.png"></p>
<p><strong>数组形参和const</strong></p>
<p>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针（参见2.4.2节，第56页）。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针</p>
<p><strong>数组引用形参</strong></p>
<p>C++语言允许将变量定义成数组的引用（参见3.5.1节，第101页），基于同样的道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725946674459.png"></p>
<p>因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，这一用法也无形中限制了print函数的可用性，我们只能将函数作用于大小为10的数组</p>
<p>16.1.1节（第578页）将要介绍我们应该如何编写这个函数，使其可以给引用类型的形参传递任意大小的数组</p>
<p><strong>传递多维数组</strong></p>
<p>当将多维数组传递给函数时，真正传递的是指向数组首元素的指针（参见3.6节，第115页）。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725946770314.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725946799107.png"></p>
<h3 id="6-2-5-main：处理命令行选项"><a href="#6-2-5-main：处理命令行选项" class="headerlink" title="6.2.5 main：处理命令行选项"></a>6.2.5 main：处理命令行选项</h3><p><img src="/../images/C-C-Primer-Chapter-6/1725946835300.png"></p>
<p>第二个形参argv是一个数组，它的元素是指向C风格字符串的指针；第一个形参argc表示数组中字符串的数量。</p>
<p>当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0</p>
<blockquote>
<p>当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。</p>
</blockquote>
<h3 id="6-2-6-含有可变形参的函数"><a href="#6-2-6-含有可变形参的函数" class="headerlink" title="6.2.6 含有可变形参的函数"></a>6.2.6 含有可变形参的函数</h3><p>为了编写能处理不同数量实参的函数，C++11新标准提供了两种主要的方法：如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模板，关于它的细节将在16.4节（第618页）介绍。</p>
<p>C++还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。本节将简要介绍省略符形参，不过需要注意的是，这种功能一般只用于与C函数交互的接口程序。</p>
<p><strong>initializer_list形参</strong></p>
<p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组（参见3.5节，第101页）。initializer_list类型定义在同名的头文件中，它提供的操作如表6.1所示。</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725947030833.png"></p>
<p>initializer_list对象中的<strong>元素永远是常量值</strong>，我们无法改变initializer_list对象中元素的值。</p>
<p>如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内</p>
<p><strong>省略符形参</strong></p>
<p>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为varargs的C标准库功能。通常，省略符形参不应用于其他目的。你的C编译器文档会描述如何使用varargs。</p>
<blockquote>
<p>省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
</blockquote>
<p>省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725947187334.png"></p>
<h2 id="6-3-返回类型和return语句"><a href="#6-3-返回类型和return语句" class="headerlink" title="6.3 返回类型和return语句"></a>6.3 返回类型和return语句</h2><h3 id="6-3-1-无返回值函数"><a href="#6-3-1-无返回值函数" class="headerlink" title="6.3.1 无返回值函数"></a>6.3.1 无返回值函数</h3><h3 id="6-3-2-有返回值函数"><a href="#6-3-2-有返回值函数" class="headerlink" title="6.3.2 有返回值函数"></a>6.3.2 有返回值函数</h3><blockquote>
<p>在含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的。很多编译器都无法发现此类错误。运行时的行为是未定义的。</p>
</blockquote>
<p><strong>值是如何被返回的</strong></p>
<p>返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p>
<p><strong>不要返回局部对象的引用或指针</strong></p>
<p><strong>返回类类型的函数和调用运算符</strong></p>
<p><strong>引用返回左值</strong></p>
<p><strong>列表初始化返回值</strong></p>
<p>C++11新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化（参见3.3.1节，第88页）；否则，返回的值由函数的返回类型决定。</p>
<p><strong>主函数main的返回值</strong></p>
<p>为了使返回值与机器无关，cstdlib头文件定义了两个预处理变量（参见2.3.2节，第49页），我们可以使用这两个变量分别表示成功与失败</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725947537988.png"></p>
<p><strong>递归</strong></p>
<p>如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数（recursive function）。</p>
<h3 id="6-3-3-返回数组指针"><a href="#6-3-3-返回数组指针" class="headerlink" title="6.3.3 返回数组指针"></a>6.3.3 返回数组指针</h3><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用（参见3.5.1节，第102页）。虽然从语法上来说，要想定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名（参见2.5.1节，第60页）</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725947623474.png"></p>
<p><strong>声明一个返回数组指针的函数</strong></p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725947705178.png"></p>
<p><strong>使用尾置返回类型</strong></p>
<p>在C++11新标准中还有一种可以简化上述func声明的方法，就是使用尾置返回类型（trailing return type）。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。</p>
<p>尾置返回类型跟在形参列表后面并以一个-&gt;符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725947829947.png"></p>
<p><strong>使用decltype</strong></p>
<p>如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725947866943.png"></p>
<p>arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd的类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。<strong>有一个地方需要注意：</strong>decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个＊符号。</p>
<h2 id="6-4-函数重载"><a href="#6-4-函数重载" class="headerlink" title="6.4 函数重载"></a>6.4 函数重载</h2><p>如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为重载（overloaded）函数。</p>
<p><strong>定义重载函数</strong></p>
<p>对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。</p>
<p>不允许两个函数除了返回类型外其他所有的要素都相同。</p>
<p><strong>重载和const形参</strong></p>
<p>一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来</p>
<p>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的</p>
<p>当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。</p>
<p><strong>const_cast和重载</strong></p>
<p>const_cast在重载函数的情景中最有用</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725948182712.png"></p>
<p>这个函数的参数和返回类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果仍然是const string的引用。因此我们需要一种新的shorterString函数，当它的实参不是常量时，得到的结果是一个普通的引用，使用const_cast可以做到这一点</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725948295464.png"></p>
<p>在这个版本的函数中，首先将它的实参强制转换成对const的引用，然后调用了shorterString函数的const版本。const版本返回对const string的引用，这个引用事实上绑定在了某个初始的非常量实参上。因此，我们可以再将其转换回一个普通的string&amp;，这显然是安全的。</p>
<p><strong>调用重载的函数</strong></p>
<p>当调用重载函数时有三种可能的结果：</p>
<p>1.编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。</p>
<p>2.找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配（no match）的错误信息。</p>
<p>3.有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为二义性调用（ambiguous call）。</p>
<h3 id="6-4-1-重载与作用域"><a href="#6-4-1-重载与作用域" class="headerlink" title="6.4.1 重载与作用域"></a>6.4.1 重载与作用域</h3><p>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名</p>
<h2 id="6-5-特殊用途语言特性"><a href="#6-5-特殊用途语言特性" class="headerlink" title="6.5 特殊用途语言特性"></a>6.5 特殊用途语言特性</h2><h3 id="6-5-1-默认实参"><a href="#6-5-1-默认实参" class="headerlink" title="6.5.1 默认实参"></a>6.5.1 默认实参</h3><p>我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p>
<p><strong>使用默认实参调用函数</strong></p>
<p>尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</p>
<p><strong>默认实参声明</strong></p>
<p>在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p>
<blockquote>
<p>通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p>
</blockquote>
<p><strong>默认实参初始值</strong></p>
<p>局部变量不能作为默认实参。除此之外，只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参</p>
<h3 id="6-5-2-内联函数和constexpr函数"><a href="#6-5-2-内联函数和constexpr函数" class="headerlink" title="6.5.2 内联函数和constexpr函数"></a>6.5.2 内联函数和constexpr函数</h3><p><strong>内联函数可避免函数调用的开销</strong></p>
<p>将函数指定为内联函数（inline），通常就是将它在每个调用点上“内联地”展开。</p>
<blockquote>
<p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p>
</blockquote>
<p><strong>constexpr函数</strong></p>
<p>constexpr函数（constexpr function）是指能用于常量表达式（参见2.4.4节，第58页）的函数。</p>
<p>定义constexpr函数的方法与其他函数类似，不过要遵循几项约定：函数的返回类型及所有形参的类型都得是字面值类型（参见2.4.4节，第59页），而且函数体中必须有且只有一条return语句</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725949081206.png"></p>
<p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，constexpr函数中可以有空语句、类型别名（参见2.5.1节，第60页）以及using声明。</p>
<blockquote>
<p>constexpr函数不一定返回常量表达式。</p>
</blockquote>
<p><strong>把内联函数和constexpr函数放在头文件内</strong></p>
<p>和其他函数不一样，内联函数和constexpr函数可以在程序中多次定义。毕竟，编译器要想展开函数仅有函数声明是不够的，还需要函数的定义。不过，对于某个给定的内联函数或者constexpr函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和constexpr函数通常定义在头文件中。</p>
<h3 id="6-5-3-调试帮助"><a href="#6-5-3-调试帮助" class="headerlink" title="6.5.3 调试帮助"></a>6.5.3 调试帮助</h3><p>C++程序员有时会用到一种类似于头文件保护（参见2.6.3节，第67页）的技术，以便有选择地执行调试代码。基本思想是，程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。</p>
<p><strong>assert预处理宏</strong></p>
<p>assert是一种预处理宏（preprocessor marco）。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。assert宏使用一个表达式作为它的条件：</p>
<p><img src="/../images/C-C-Primer-Chapter-6/image-20240922130516672.png"></p>
<p>首先对expr求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。</p>
<p><strong>NDEBUG预处理变量</strong></p>
<p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。</p>
<p>我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725949430286.png"></p>
<p>这条命令的作用等价于在main.c文件的一开始写#define NDEBUG。</p>
<p>assert应该仅用于验证那些确实不可能发生的事情。我们可以把assert当成调试程序的一种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。</p>
<p>除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码；如果定义了NDEBUG，这些代码将被忽略掉：</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725949488042.png"></p>
<p>我们使用变量__func__输出当前调试的函数的名字。编译器为每个函数都定义了__func__，它是const char的一个静态数组，用于存放函数的名字。</p>
<p>除了C++编译器定义的__func__外，预处理器还定义了另外4个对于程序调试很有用的名字：</p>
<p>__FILE__存放文件名的字符串字面值。</p>
<p>__LINE__存放当前行号的整型字面值。</p>
<p>__TIME__存放文件编译时间的字符串字面值。</p>
<p>__DATE__存放文件编译日期的字符串字面值。</p>
<h2 id="6-6-函数匹配"><a href="#6-6-函数匹配" class="headerlink" title="6.6 函数匹配"></a>6.6 函数匹配</h2><p><strong>确定候选函数和可行函数</strong></p>
<p>函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数（candidate function）。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见。</p>
<p>第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数（viable function）。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p>
<p>在使用实参数量初步判别了候选函数后，接下来考察实参的类型是否与形参匹配。和一般的函数调用类似，实参与形参匹配的含义可能是它们具有相同的类型，也可能是实参类型和形参类型满足转换规则。</p>
<p><strong>寻找最佳匹配（如果有的话）</strong></p>
<p>如果在检查了所有实参之后没有任何一个函数脱颖而出，则该调用是错误的。编译器将报告二义性调用的信息。</p>
<blockquote>
<p>调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。</p>
</blockquote>
<h3 id="6-6-1-实参类型转换"><a href="#6-6-1-实参类型转换" class="headerlink" title="6.6.1 实参类型转换"></a>6.6.1 实参类型转换</h3><p>有时间再看。</p>
<h2 id="6-7-函数指针"><a href="#6-7-函数指针" class="headerlink" title="6.7 函数指针"></a>6.7 函数指针</h2><p>函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p>
<p>要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725950202450.png"></p>
<p><strong>使用函数指针</strong></p>
<p>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725950254391.png"></p>
<p>我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针</p>
<p><strong>重载函数的指针</strong></p>
<p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配</p>
<p><strong>函数指针形参</strong></p>
<p>虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725950359746.png"></p>
<p>直接使用函数指针类型显得冗长而烦琐。类型别名（参见2.5.1节，第60页）和decltype（参见2.5.3节，第62页）能让我们简化使用了函数指针的代码</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725950417865.png"></p>
<p><strong>返回指向函数的指针</strong></p>
<p>虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。</p>
<p>要想声明一个返回函数指针的函数，最简单的办法是使用类型别名</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725950505765.png"></p>
<p>和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针</p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725950529974.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725950564265.png"></p>
<p><img src="/../images/C-C-Primer-Chapter-6/1725950558981.png"></p>
<p><strong>将auto和decltype用于函数指针类型</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-09-22T04:01:00.000Z" title="2024/9/22 12:01:00">2024-09-22</time></span><span class="level-item">19 minutes read (About 2870 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2024/09/22/C-C-Primer-Chapter-5/">[C++]C++Primer Chapter 5</a></p><div class="content"><h1 id="5-语句"><a href="#5-语句" class="headerlink" title="5 语句"></a>5 语句</h1><h2 id="5-1-简单语句"><a href="#5-1-简单语句" class="headerlink" title="5.1 简单语句"></a>5.1 简单语句</h2><h2 id="5-2-语句作用域"><a href="#5-2-语句作用域" class="headerlink" title="5.2 语句作用域"></a>5.2 语句作用域</h2><h2 id="5-3-条件语句"><a href="#5-3-条件语句" class="headerlink" title="5.3 条件语句"></a>5.3 条件语句</h2><h3 id="5-3-1-if语句"><a href="#5-3-1-if语句" class="headerlink" title="5.3.1 if语句"></a>5.3.1 if语句</h3><h3 id="5-3-2-switch语句"><a href="#5-3-2-switch语句" class="headerlink" title="5.3.2 switch语句"></a>5.3.2 switch语句</h3><p>switch语句（switch statement）提供了一条便利的途径使得我们能够在若干固定选项中做出选择。</p>
<p><img src="/../images/C-C-Primer-Chapter-5/1725942532319.png"></p>
<p>case关键字和它对应的值一起被称为case标签（case label）。case标签必须是整型常量表达式。</p>
<p><img src="/../images/C-C-Primer-Chapter-5/1725942502014.png"></p>
<p>即使不准备在default标签下做任何工作，定义一个default标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做。</p>
<p><strong>switch内部的变量定义</strong></p>
<p>switch的执行流程有可能会跨过某些case标签。如果程序跳转到了某个特定的case，则switch结构中该case标签之前的部分会被忽略掉。这种忽略掉一部分代码的行为引出了一个有趣的问题：如果被略过的代码中含有变量的定义该怎么办？</p>
<p>答案是：如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。</p>
<p><img src="/../images/C-C-Primer-Chapter-5/1725942726914.png"></p>
<p>如果需要为某个case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有case标签都在变量的作用域之外。</p>
<p><img src="/../images/C-C-Primer-Chapter-5/1725942745906.png"></p>
<h2 id="5-4-迭代语句"><a href="#5-4-迭代语句" class="headerlink" title="5.4 迭代语句"></a>5.4 迭代语句</h2><h3 id="5-4-1-while语句"><a href="#5-4-1-while语句" class="headerlink" title="5.4.1 while语句"></a>5.4.1 while语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725942801324.png"></p>
<blockquote>
<p>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程。</p>
</blockquote>
<h3 id="5-4-2-for语句"><a href="#5-4-2-for语句" class="headerlink" title="5.4.2 for语句"></a>5.4.2 for语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725942926719.png"></p>
<p>init-statement必须是以下三种形式中的一种：声明语句、表达式语句或者空语句</p>
<p>init-statement负责初始化一个值，这个值将随着循环的进行而改变。condition作为循环控制的条件，只要condition为真，就执行一次statement。如果condition第一次的求值结果就是false，则statement一次也不会执行。expression负责修改init-statement初始化的变量，这个变量正好就是condition检查的对象，修改发生在每次循环迭代之后。</p>
<h3 id="5-4-3-范围for语句"><a href="#5-4-3-范围for语句" class="headerlink" title="5.4.3 范围for语句"></a>5.4.3 范围for语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725943065748.png"></p>
<p>expression表示的必须是一个序列，比如用花括号括起来的初始值列表（参见3.3.1节，第88页）、数组（参见3.5节，第101页）或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员（参见3.4节，第95页）。</p>
<p>在范围for语句中，预存了end（）的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了（参见3.4.1节，第98页）。</p>
<h3 id="5-4-4-do-while语句"><a href="#5-4-4-do-while语句" class="headerlink" title="5.4.4 do while语句"></a>5.4.4 do while语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725943185144.png"></p>
<h2 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a>5.5 跳转语句</h2><p>跳转语句中断当前的执行过程。C++语言提供了4种跳转语句：break、continue、goto和return。</p>
<h3 id="5-5-1-break语句"><a href="#5-5-1-break语句" class="headerlink" title="5.5.1 break语句"></a>5.5.1 break语句</h3><h3 id="5-5-2-continue语句"><a href="#5-5-2-continue语句" class="headerlink" title="5.5.2 continue语句"></a>5.5.2 continue语句</h3><h3 id="5-5-3-goto语句"><a href="#5-5-3-goto语句" class="headerlink" title="5.5.3 goto语句"></a>5.5.3 goto语句</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725943324855.png"></p>
<p>其中，label是用于标识一条语句的标示符。带标签语句（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p>
<p><img src="/../images/C-C-Primer-Chapter-5/1725943337648.png"></p>
<blockquote>
<p>不要在程序中使用goto语句，因为它使得程序既难理解又难修改。</p>
</blockquote>
<h2 id="5-2-try语句块和异常处理"><a href="#5-2-try语句块和异常处理" class="headerlink" title="5.2 try语句块和异常处理"></a>5.2 try语句块和异常处理</h2><p>异常是指存在于运行时的反常行为，这些行为超出了函数正常功能的范围。典型的异常包括失去数据库连接以及遇到意外输入等。处理反常行为可能是设计所有系统最难的一部分。</p>
<p>在C++语言中，异常处理包括：</p>
<p><strong>throw表达式（throw expression）</strong>，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发（raise）了异常。</p>
<p><strong>try语句块（try block）</strong>，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句（catch clause）结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句“处理”异常，所以它们也被称作异常处理代码（exception handler）。</p>
<p><strong>一套异常类（exception class）</strong>，用于在throw表达式和相关的catch子句之间传递异常的具体信息。</p>
<h3 id="5-6-1-throw表达式"><a href="#5-6-1-throw表达式" class="headerlink" title="5.6.1 throw表达式"></a>5.6.1 throw表达式</h3><p>throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。</p>
<p><img src="/../images/C-C-Primer-Chapter-5/1725943584527.png"></p>
<p>在这段代码中，如果ISBN不一样就抛出一个异常，该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给能处理该异常的代码。</p>
<p>类型runtime_error是标准库异常类型的一种，定义在stdexcept头文件中。关于标准库异常类型更多的知识将在5.6.3节（第176页）介绍。我们必须初始化runtime_error的对象，方式是给它提供一个string对象或者一个C风格的字符串（参见3.5.4节，第109页），这个字符串中有一些关于异常的辅助信息。</p>
<h3 id="5-6-2-try语句块"><a href="#5-6-2-try语句块" class="headerlink" title="5.6.2 try语句块"></a>5.6.2 try语句块</h3><p><img src="/../images/C-C-Primer-Chapter-5/1725943641521.png"></p>
<p>try语句块的一开始是关键字try，随后紧跟着一个块，这个块就像大多数时候那样是花括号括起来的语句序列。</p>
<p>跟在try块之后的是一个或多个catch子句。catch子句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明（称作异常声明，exception declaration）以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。</p>
<p><img src="/../images/C-C-Primer-Chapter-5/1725943730068.png"></p>
<p>每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串（即const char＊）。其中，runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。</p>
<p>在复杂系统中，程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个try语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。</p>
<p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。如果最终还是没能找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。</p>
<p>对于那些没有任何try语句块定义的异常，也按照类似的方式处理：毕竟，没有try语句块也就意味着没有匹配的catch子句。如果一段程序没有try语句块且发生了异常，系统会调用terminate函数并终止当前程序的执行。</p>
<p><strong>编写异常安全的代码非常困难</strong></p>
<p>异常中断了程序的正常流程。异常发生时，调用者请求的一部分计算可能已经完成了，另一部分则尚未完成。通常情况下，略过部分程序意味着某些对象处理到一半就戛然而止，从而导致对象处于无效或未完成的状态，或者资源没有正常释放，等等。</p>
<p>那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全（exception safe）的代码。然而经验表明，编写异常安全的代码非常困难，这部分知识也（远远）超出了本书的范围。对于一些程序来说，当异常发生时只是简单地终止程序。此时，我们不怎么需要担心异常安全的问题。但是对于那些确实要处理异常并继续执行的程序，就要加倍注意了。我们必须时刻清楚异常何时发生，异常发生后程序应如何确保对象有效、资源无泄漏、程序处于合理状态，等等。</p>
<h3 id="5-6-3-标准异常"><a href="#5-6-3-标准异常" class="headerlink" title="5.6.3 标准异常"></a>5.6.3 标准异常</h3><p>C++标准库定义了一组类，用于报告标准库函数遇到的问题。这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中</p>
<p>exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。</p>
<p>stdexcept头文件定义了几种常用的异常类，详细信息在表5.1中列出。</p>
<p><img src="/../images/C-C-Primer-Chapter-5/1725944160121.png"></p>
<p>new头文件定义了bad_alloc异常类型，这种类型将在12.1.2节（第407页）详细介绍。</p>
<p>type_info头文件定义了bad_cast异常类型，这种类型将在19.2节（第731页）详细介绍。</p>
<p>我们只能以默认初始化（参见2.2.1节，第40页）的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。</p>
<p>其他异常类型的行为则恰好相反：应该使用string对象或者C风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。</p>
<p>异常类型只定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符串（参见3.5.4节，第109页）的const char＊。该字符串的目的是提供关于异常的一些文本信息。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/C/page/0/">Previous</a></div><div class="pagination-next"><a href="/tags/C/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/C/">1</a></li><li><a class="pagination-link" href="/tags/C/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar1.jpg" alt="ErlsrnBy04"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ErlsrnBy04</p><p class="is-size-6 is-block">学生</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京，中国</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">2</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ErlsrnBy04" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-22T05:17:42.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BC%98%E5%8C%96/">[C++] 返回值优化</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:27.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-14/">[C++]C++Primer Chapter 14</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:25.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-13/">[C++]C++Primer Chapter 13</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:22.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-12/">[C++]C++Primer Chapter 12</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-09-22T04:01:19.000Z">2024-09-22</time></p><p class="title"><a href="/2024/09/22/C-C-Primer-Chapter-11/">[C++]C++Primer Chapter 11</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/09/"><span class="level-start"><span class="level-item">September 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-S081/"><span class="tag">MIT 6.S081</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/Snake.svg" alt="ErlsrnBy04" height="28"></a><p class="is-size-7"><span>&copy; 2024 ErlsrnBy04</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/ErlsrnBy04"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'folded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>